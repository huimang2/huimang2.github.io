<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://huimang2.github.io/tag/etc/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://huimang2.github.io/" rel="alternate" type="text/html" />
  <updated>2023-06-11T22:25:50+09:00</updated>
  <id>https://huimang2.github.io/tag/etc/feed.xml</id>

  
  
  

  
    <title type="html">Rubisco’s Programming Note | </title>
  

  
    <subtitle>프로그래밍 노트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">입출력장치</title>
      <link href="https://huimang2.github.io/etc/computer-input-output-unit" rel="alternate" type="text/html" title="입출력장치" />
      <published>2023-06-11T01:00:00+09:00</published>
      <updated>2023-06-11T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-input-output-unit</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-input-output-unit">&lt;h1 id=&quot;장치-컨트롤러device-controller&quot;&gt;장치 컨트롤러(Device Controller)&lt;/h1&gt;

&lt;p&gt;입출력장치는 하드디스크, 마우스, 모니터 등과 같이 컴퓨터 외부에 연결되어 CPU와 정보를 교환할 수 있는 장치입니다.&lt;/p&gt;

&lt;p&gt;입출력 장치는 종류가 다양하기 때문에 CPU와 정보를 주고 받는 방식을 규격화하기 어렵습니다. 또한 CPU에 비하여 데이터 전송률이 낮기 때문에 CPU와 직접적으로 통신하게 되면 CPU의 성능이 좋더라도 이를 활용할 수 없게 됩니다. 이러한 문제를 해결하기 위한 하드웨어를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 컨트롤러(Device Controller)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크의-장치-컨트롤러&quot;&gt;하드디스크의 장치 컨트롤러&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img098.png&quot; alt=&quot;img098&quot; /&gt;&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 CPU와 입출력장치 간의 통신을 중개하여 각 장치들을 규격화 해주며, 오류를 검출하고 버퍼링을 통해 CPU와 데이터 전송률을 맞추는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 레지스터&lt;/code&gt;로 구성되며, CPU는 버스를 통해 장치 컨트롤러에 데이터를 전송합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img099.png&quot; alt=&quot;img099&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 레지스터는 CPU와 입출력장치 사이에 주고 받을 데이터를 저장하는 레지스터로, 버퍼 역할을 합니다. 최근에는 입출력 장치와 주고 받을 데이터가 많아졌기 때문에 데이터 레지스터 대신에 RAM을 사용하기도 합니다.&lt;/p&gt;

&lt;p&gt;상태 레지스터는 입출력장치가 입출력 작업할 준비가 되었는지, 입출력 작업 완료가 되었는지, 입출력장치에 오류가 없는지 등의 상태 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;제어 레지스터는 입출력장치가 수행할 내용에 대한 제어 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;h1 id=&quot;장치-드라이버device-driver&quot;&gt;장치 드라이버(Device Driver)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 드라이버(Device Driver)&lt;/code&gt;는 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램 입니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러가 입출력장치를 연결하는 하드웨어라면, 장치 드라이버는 입출력장치를 연결하는 소프트웨어 입니다. 장치 드라이버를 통해 CPU가 입출력장치를 제어할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;usb-장치-드라이버&quot;&gt;USB 장치 드라이버&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img100.png&quot; alt=&quot;img100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요즘은 OS가 장치 드라이버를 자동으로 설치해주는 경우가 많은데, 이전에는 프린터를 컴퓨터에 연결하여 사용하려면 해당 프린터에 대한 프린트 드라이버를 설치해야 했습니다. 장치 드라이버가 설치되지 않는다면 CPU가 프린터를 동작시키는 방식을 모르기 때문에 해당 프린터를 사용할 수 없게 됩니다. 즉, 장치 드라이버를 인식하고 실행하는 주체는 운영체제(OS) 입니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력-방식&quot;&gt;입출력 방식&lt;/h1&gt;

&lt;p&gt;입출력장치가 CPU와 정보를 교환하는 방식에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로그램-입출력programmed-inputoutput-pio&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/code&gt;은 프로그램 명령어를 통해 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송한 후 입출력장치의 상태를 주기적으로 확인하여 데이터 송수신을 제어합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 메모리에 저장된 정보를 하드디스크에 저장한다고 한다면 CPU는 쓰기 명령어를 전송하고 상태 레지스터의 확인하고 입출력 장치가 사용가능하다면 데이터를 전송합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크-쓰기-제어&quot;&gt;하드디스크 쓰기 제어&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img101.png&quot; alt=&quot;img101&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 주기적으로 상태 레지스터를 확인하는 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴링(Polling)&lt;/code&gt;이라고 하며, 그러므로 프로그램 입출력 방식을 폴링 방식이라고도 합니다.&lt;/p&gt;

&lt;h6 id=&quot;폴링-순환&quot;&gt;폴링 순환&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img102.png&quot; alt=&quot;img102&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 입출력 방식은 가장 간단하고 최소의 하드웨어를 필요로 하지만, 반복적으로 입출력장치의 상태를 점검하여 CPU의 효율을 저하시키키며 입출력이 완료될 때까지 CPU가 동작하지 못한다는 단점이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램 입출력 방식은 CPU가 입출력장치에 접근하는 방식에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-맵-입출력memmory-mapped-io&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소공간으로 취급하여 접근하는 방식입니다.&lt;/p&gt;

&lt;p&gt;메모리의 일부 공간을 입출력 포트에 할당하여 메모리 주소 공간이 축소되지만, 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 동일하기 때문에 CPU 로직이 단순해집니다. 주로 ARM 계열의 RISC에서 사용하며, LOAD나 STORE 명령을 통해 접근할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;고립형-입출력isolated-io&quot;&gt;고립형 입출력(Isolated I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력(Isolated I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 분리하는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;입출력장치에 접근하기 위한 별도의 명령어가 필요하고 CPU 로직이 복잡해지지만, 메모리 주소 공간 전체를 활용할 수 있습니다. 주로 x86 계열의 CISC에서 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-기반-입출력interrupt-driven-io&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/code&gt;은 인터럽트를 기반으로 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송하면 장치 컨트롤러에서 명령어를 수행한 후 CPU에 인터럽트 요청 신호를 보냅니다. 인터럽트 요청신호를 받은 CPU는 하던 일을 멈추고 인터럽트 서비스 루틴을 실행합니다.&lt;/p&gt;

&lt;p&gt;여러 입출력장치에서 인터럽트가 동시에 발생한 경우 우선순위를 고려하여 우선순위가 높은 인터럽트를 먼저 처리합니다. 우선순위를 반영한 인터럽트를 처리하는 방식에는 여러 방식이 존재하지만 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그래머블 인터럽트 컨트롤러(Programmable Interrupt Controller, PIC)&lt;/code&gt;라는 하드웨어를 사용하여 처리합니다.&lt;/p&gt;

&lt;h6 id=&quot;pic&quot;&gt;PIC&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img103.png&quot; alt=&quot;img103&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 장치 컨트롤러와 CPU 사이에서 어떤 인터럽트를 먼저 처리할 것인지를 판단하여 CPU에게 인터럽트 신호를 전송합니타.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img104.png&quot; alt=&quot;img104&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 보통 여러 개를 계층적으로 사용하여 사용하는 경우가 많습니다.&lt;/p&gt;

&lt;h2 id=&quot;dma-입출력direct-memory-access-io&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/code&gt;은 입출력장치와 메모리가 CPU를 거치지 않고 상호작용할 수 있는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;프로그램 입출력과 인터럽트 기반 입출력은 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거치게 되어 하드디스크 백업과 같은 대용량 데이터의 전송이 필요하다면 CPU의 부담이 커지게 됩니다. 이를 해결하기 위한 입출력 방식이 DMA 입출력 방식이며, DMA 입출력 방식은 입출력장치가 CPU를 거치지 않고 직접 메모리에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;DMA 입출력을 위해서는 시스템 버스에 연결된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 컨트롤러&lt;/code&gt;라는 하드웨어가 필요합니다. CPU가 DMA 컨트롤러에 명령어를 보내면 DMA 컨트롤러는 CPU를 대신하여 입출력 작업을 수행하고, 입출력 작업이 끝나면 인터럽트 신호를 통해 CPU에게 입출력 작업이 끝났음을 알립니다. 그동안 CPU는 다른 작업을 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img105.png&quot; alt=&quot;img105&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img106.png&quot; alt=&quot;img106&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img107.png&quot; alt=&quot;img107&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 시스템 버스는 공용 자원이기 때문에 CPU와 DMA 컨트롤러는 동시에 시스템 버스를 사용할 수 없습니다. 그러므로 DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을때 조금씩 시스템 버스를 사용하거나 CPU가 일시적으로 시스템 버스를 사용하지 않도록 요청을 보내고 시스템 버스를 사용합니다.&lt;/p&gt;

&lt;p&gt;DMA 컨트롤러는 메모리에서 데이터를 가져오기 위해 시스템 버스를 한 번, 장치컨트롤러에 데이터를 전송하기 위해 시스템 버스를 또 한 번 사용하여 총 2번 사용하게 됩니다. 그만큼 CPU가 시스템 버스를 사용하지 못하는 문제가 발생하는데, 이를 해결하기 위해 입출력장치를 입출력 버스(I/O Bus)라는 별도의 버스에 연결하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img108.png&quot; alt=&quot;img108&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 그래픽 카드나 SSD를 연결하는 PCIe 슬롯은 입출력 버스와 연결됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img109.png&quot; alt=&quot;img109&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">장치 컨트롤러(Device Controller)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 파이프라인</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-pipeline" rel="alternate" type="text/html" title="명령어 파이프라인" />
      <published>2023-06-06T01:00:00+09:00</published>
      <updated>2023-06-06T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-pipeline</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-pipeline">&lt;h1 id=&quot;명령어-파이프라인instruction-pipeline&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/code&gt;은 CPU의 성능을 향상시키기 위해 명령어 처리를 여러 단계로 나누어 동시에 실행하는 명령어 병렬 처리 기법입니다.&lt;/p&gt;

&lt;p&gt;CPU의 명령어가 처리되는 과정은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출(fetch)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행(execution)&lt;/code&gt; 2단계로 나눌 수 있다고 했는데, 이를 비슷한 시간 간격으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 인출(Instruction Fetch)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 해석(Instruction Decode)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 실행(Execute Instruction)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결과 저장(Write Back)&lt;/code&gt; 4단계로 나눌 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 명령어 인출(Instruction Fetch)&lt;/strong&gt; : 명령어를 기억장치로 부터 인출&lt;br /&gt;
&lt;strong&gt;2. 명령어 해석(Instruction Decode)&lt;/strong&gt; : 디코더를 사용하여 명령어 해석&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행(Execute Instruction)&lt;/strong&gt; : 해석된 명령어에 따라 데이터 연산을 수행&lt;br /&gt;
&lt;strong&gt;4. 결과 저장(Write Back)&lt;/strong&gt; : 명령어대로 처리된 데이터를 메모리에 기록&lt;/p&gt;

&lt;p&gt;만약 명령어 파이프라인을 사용하지 않는다면 다음과 같이 명령어가 순차적으로 실행 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img088.png&quot; alt=&quot;img088&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어 파이프라인을 사용한다면 각 명령어를 겹쳐 동시에 실행함으로써 명령어 처리 시간을 줄여 CPU의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img089.png&quot; alt=&quot;img089&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;파이프라인-위험pipeline-hazard&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/code&gt;은 파이프라인 기법을 사용하는데 있어서 발생할 수 있는 문제점을 말합니다.&lt;/p&gt;

&lt;p&gt;파이프라인 위험에는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt; 3가지로 나눌 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-위험data-hazard&quot;&gt;데이터 위험(Data Hazard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;은 명령어 간의 의존성으로 인해 아직 수행되지 않은 명령어의 결과값을 참조함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같이 명령어1, 명령어2가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;명령어1 : R&lt;sub&gt;1&lt;/sub&gt; ← R&lt;sub&gt;2&lt;/sub&gt; + R&lt;sub&gt;3&lt;/sub&gt;&lt;br /&gt;
명령어2 : R&lt;sub&gt;4&lt;/sub&gt; ← R&lt;sub&gt;1&lt;/sub&gt; * R&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어1은 R&lt;sub&gt;2&lt;/sub&gt;와 R&lt;sub&gt;3&lt;/sub&gt; 레지스터값을 더하여 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 저장하고, 명령어2는 R&lt;sub&gt;1&lt;/sub&gt;과 R&lt;sub&gt;2&lt;/sub&gt; 레지스터값을 곱하여 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장합니다.&lt;/p&gt;

&lt;p&gt;이 경우 아래와 같이 명령어 파이프라인을 사용한다면 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 명령어1의 저장단계가 수행되기 전에 명령어2의 인출 및 해석이 발생하기 때문에 잘못된 결과값이 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img090.png&quot; alt=&quot;img090&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 데이터 위험이라고 합니다. 데이터 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img091.png&quot; alt=&quot;img091&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;제어-위험control-harzard&quot;&gt;제어 위험(Control Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;은 Jump나 Call, Interupt 같은 분기 명령어에 의해 프로그램 카운터(PC)가 갑작스럽게 변함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;기본적으로 명령어는 프로그램 카운터가 순차적으로 증가하여 실행됩니다. 하지만 분기(branch) 명령어를 싱행하게 된다면 프로그램 카운터가 비순차적으로 변하기 때문에 동시에 실행되는 명령어가 필요없어지게 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img092.png&quot; alt=&quot;img092&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 제어 위험이라고 합니다. 제어 위험의 경우 인출 단계 이후에 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img093.png&quot; alt=&quot;img093&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;구조적-위험structural-harzard&quot;&gt;구조적 위험(Structural Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt;은 서로 다른 명령어가 같은 자원에 접근함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Load 명령어의 경우 데이터를 인출하기 위해 메모리에 접근하는 단계가 있어는데, 다음과 같이 동일한 레지스터에 쓰기 접근을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img094.png&quot; alt=&quot;img094&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 구조적 위험이라고 합니다. 구조적 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img095.png&quot; alt=&quot;img095&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;슈퍼스칼라supserscalar&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/code&gt;는 CPU 내에 파이프라인을 여러 개 두어 명령어를 동시에 실행하는 기술로서, 멀티 스레드 프로세서를 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img096.png&quot; alt=&quot;img096&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이론적으로는 파이프라인 개수에 비례하여 CPU의 처리 속도가 증가하지만, 그만큼 파이프라인 위험도 증가하므로 실제로 파이프라인 개수에 비례하여 처리 속도가 증가하지는 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;명령어-집합-구조instruction-set-architecture-isa&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/code&gt;는 CPU가 이해할 수 있는 기계어 명령어들의 집합을 의미합니다. 하드웨어와 시스템 소프트웨어 사이의 인터페이스를 정의하며, 최하위 레벨의 프로그래밍 인터페이스로서 CPU가 실행할 수 있는 모든 명령어를 포함합니다.&lt;/p&gt;

&lt;p&gt;ISA를 물리적으로 구현한 CPU 내부의 하드웨어 구조를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마이크로 아키텍쳐(Micro Architecture)&lt;/code&gt;라고 합니다. CPU 제조사마다 마이크로 아키텍쳐가 다르므로 ISA 역시 서로 다릅니다. 대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;cisccomplex-instruction-set-computer&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;는 복잡한 명령어 집합을 가지는 CPU로서, 인텔이나 AMD의 x86, x86-64는 CISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;CISC는 복잡하고 다양한 가변 길이 명령어를 사용하며, 상대적으로 적은 수의 명령어만으로도 프로그램을 실행할 수 있습니다. 그렇기 때문에 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높은 아키텍쳐였으나, 가변 길이 명령어를 사용하므로 명령어 파이프라이닝이 불리하며 속도가 느리고 가격이 비싸다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 하드웨어 스택(Stack)이 내장되어 있으며, 서브루틴의 return 주소나 파라미터, 지역변수 등을 저장하는데 사용됩니다. 따라서 call, ret, push, pop 같은 명령어를 통해 스택 데이터를 관리할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;riscreduced-instruction-set-computer&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;는 명령어 집합의 수를 줄여 하드웨어 구조를 간단하게 만든 CPU로서, ARM 계열의 CPU는 RISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;RISC는 짧고 규격화된 명령어를 사용하여 명령어 파이프라이닝에 유리합니다. 또한 메모리 접근을 최소화 하고 많은 범용 레지스터를 사용하므로 속도가 빠르며, 전력소모가 적고 가격이 저렴합니다.&lt;/p&gt;

&lt;p&gt;CISC와 달리 스택 관련 명령어가 존재하지 않기 때문에 서브루틴의 return 주소나 파라미터, 지역변수 등은 소프트웨어적으로 처리해야 합니다.&lt;/p&gt;

&lt;h6 id=&quot;cisc--risc-비교&quot;&gt;CISC / RISC 비교&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img097.png&quot; alt=&quot;img097&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 파이프라인(Instruction Pipeline)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 사이클과 인터럽트</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-cycle" rel="alternate" type="text/html" title="명령어 사이클과 인터럽트" />
      <published>2023-05-29T01:00:00+09:00</published>
      <updated>2023-05-29T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-cycle</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-cycle">&lt;h1 id=&quot;명령어-사이클instruction-cycle&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/h1&gt;

&lt;p&gt;CPU는 프로그램 명령어를 클럭에 따라 일정한 주기를 반복하여 실행하는데, 이 주기를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 CPU가 하나의 명령어를 실행하는 데 필요한 전체 처리 과정으로서, CPU가 프로그램을 실행한 순간부터 전원을 끄거나 오류가 발생하여 프로그램이 중단될 때까지 반복됩니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 주 기억 장치로부터 명령어를 읽어오는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출 사이클(Fetch Cycle)&lt;/code&gt;과 명령어를 실행하는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행 사이클(Execution Cycle)&lt;/code&gt;로 분리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img079.png&quot; alt=&quot;img079&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인출-사이클fetch-cycle&quot;&gt;인출 사이클(Fetch Cycle)&lt;/h2&gt;

&lt;p&gt;인출 사이클의 진행은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img080.png&quot; alt=&quot;img080&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- PC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR], PC &amp;lt;- PC + 1&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : IR &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 프로그램 카운터(PC)에 저장된 명령어 주소를 CPU 내부 버스를 통해 메모리 주소 레지스터(MAR)로 보냅니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 명령어를 읽어서 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)에 저장합니다. 동시에 프로그램 카운터가 1 증가합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 명령어를 명령어 레지스터(IR)에 저장합니다.&lt;/p&gt;

&lt;h2 id=&quot;실행-사이클execution-cycle&quot;&gt;실행 사이클(Execution Cycle)&lt;/h2&gt;

&lt;p&gt;실행 사이클 동안에는 CPU가 명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산들을 수행합니다. CPU가 수행하는 연산에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 이동&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 처리&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 저장&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 제어&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;명령어는 연산 코드(Operation Code)와 오퍼랜드(operand)로 구성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img081.png&quot; alt=&quot;img081&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 사이클에서 수행되는 마이크로 연산들은 명령어의 연산 코드에 의해 결정되며, 명령어 실행에 필요한 데이터가 저장된 주소는 오퍼랜드에 의해 결정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-이동-load-addr-명령어&quot;&gt;데이터 이동: Load addr 명령어&lt;/h3&gt;

&lt;p&gt;Load ddr 명령어은 기억장치에 저장되어 있는 데이터를 CPU 내부 누산기(AC)에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 데이터를 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-저장-sta-addr-명령어&quot;&gt;데이터 저장: STA addr 명령어&lt;/h3&gt;

&lt;p&gt;STA addr 명령어은 누산기(AC)에 저장된 데이터를 기억장치에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- AC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : M[MAR] &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 누산기(AC)에 저장된 데이터를 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 MAR가 지정하는 기억장치 주소에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-처리-add-addr-명령어&quot;&gt;데이터 처리: ADD addr 명령어&lt;/h3&gt;

&lt;p&gt;ADD addr 명령어은 기억장치에 저장된 데이터를 누산기(AC)에 저장된 값에 더하여 그 결과를 다시 누산기에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img082.png&quot; alt=&quot;img082&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- AC + MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 저장할 데이터를 MAR가 지정하는 기억장치 주소로부터 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 산술논리연산장치(ALU)에서 연산하여 그 결과값을 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로그램-제어-jump-addr-명령어&quot;&gt;프로그램 제어: JUMP addr 명령어&lt;/h3&gt;

&lt;p&gt;JUMP addr 명령어은 오퍼랜드가 가리키는 주소의 명령어로 실행 순서를 변경하는 분기(branch) 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : PC &amp;lt;- IR(addr)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어 레지스터(IR)에 저장된 오퍼랜드를 PC에 저장하여 명령어 순서를 변경합니다.&lt;/p&gt;

&lt;h1 id=&quot;인터럽트interrupt&quot;&gt;인터럽트(Interrupt)&lt;/h1&gt;

&lt;p&gt;인터럽트는 컴퓨터 내부나 외부에서 발생하는 갑작스러운 사건에 대응하는 기능입니다. 인터럽트 요청이 발생하면 CPU는 현재 처리 순서를 중단하고 요구된 인터럽트 서비스 프로그램을 먼저 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img083.png&quot; alt=&quot;img083&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 그림처럼 명령어 사이클은 인출(fetch)과 실행(execution) 사이클이 반복되는데, 실행 사이클이 끝날때마다 CPU는 반복적으로 인터럽트 요청이 발생했는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img084.png&quot; alt=&quot;img084&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 요청이 발생했다면 프로그램 실행을 중단하고 인터럽트 처리를 합니다. 인터럽트 요청을 처리한 이후에는 다시 프로그램을 재실행합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h2&gt;

&lt;p&gt;인터럽트는 크게 내부 인터럽트와 외부 인터럽트로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;내부 인터럽트&lt;/code&gt;는 다음과 같은 상황에서 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 하드웨어 고장&lt;/strong&gt; : 정전, 패리티 비터 오류 등&lt;br /&gt;
&lt;strong&gt;2. 실행할 수 없는 명령어&lt;/strong&gt; : 정의되지 않은 명령어&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행 오류&lt;/strong&gt; : 0으로 나눈 경우&lt;br /&gt;
&lt;strong&gt;4. 사용 권한 위배&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주로 긴급한 상황에 발생하기 때문에 상태 레지스터의 인터럽트 플래그를 통한 제어가 불가능합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외부 인터럽트&lt;/code&gt;는 주로 입출력 장치에 의해 발생하며, 여기에는 타이머 인터럽트와 입출력 인터럽트가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 타이머 인터럽트&lt;/strong&gt; : 일정한 시간 간격으로 CPU에게 인터럽트를 요청합니다.&lt;br /&gt;
&lt;strong&gt;2. 입출력 인터럽트&lt;/strong&gt; : 속도가 비교적 느린 입출력장치의 사용 준비가 완료되었음을 알리기 위해 인터럽트를 요청합니다.&lt;/p&gt;

&lt;p&gt;외부 인터럽트는 인터럽트 플래그를 통해 제어할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-처리-순서&quot;&gt;인터럽트 처리 순서&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img087.png&quot; alt=&quot;img087&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 입출력장치에서 CPU에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 요청 신호(Interrupt Request, INTR)&lt;/code&gt;를 보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img085.png&quot; alt=&quot;img085&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; CPU는 실행 사이클을 끝내고 인터럽트 요청신호를 확인합니다. 인터럽트 요청을 확인 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 가능 플래그(Interrupt Enable Flag, IE)&lt;/code&gt;를 통해 현재 인터럽트를 받아들일 수 있는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img086.png&quot; alt=&quot;img086&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 인터럽트를 받아들일 수 있다면 현재 실행하던 프로그램을 중단하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC(Program Counter)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SR(Status Register)&lt;/code&gt;를 스택에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 벡터(Interrupt Vector)&lt;/code&gt;를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 서비스 루틴(Interrupt Service Routine, ISR)&lt;/code&gt;을 실행합니다.&lt;/p&gt;

&lt;p&gt;ISR는 인터럽트가 발생한 경우 인터럽트를 처리하기 위한 프로그램으로, 일반적으로 메모리에 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; ISR 실행이 끝나면 스택에 저장한 PC와 SR값을 복구하여 프래그램 실행을 재개합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 사이클(Instruction Cycle)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">레지스터와 카운터</title>
      <link href="https://huimang2.github.io/etc/computer-register-and-counter" rel="alternate" type="text/html" title="레지스터와 카운터" />
      <published>2023-05-19T01:00:00+09:00</published>
      <updated>2023-05-19T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-register-and-counter</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-register-and-counter">&lt;h1 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h1&gt;

&lt;p&gt;레지스터는 여러 비트를 저장하는 기억 소자입니다. 일반적으로 D 플립플롭으로 구성되어 있으며, 하나의 플립플롭은 1비트를 구성합니다. 즉, 8개의 플립플롭은 8비트, 16개의 플립플롭은 16비트 레지스터가 됩니다.&lt;/p&gt;

&lt;p&gt;레지스터는 주로 CPU 내부에서 연산결과를 중간저장하거나 데이터를 선택할 때 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;로드load-신호&quot;&gt;로드(Load) 신호&lt;/h2&gt;

&lt;p&gt;로드 신호는 레지스터를 동작시키는 신호입니다. 레지스터에 저장된 데이터를 입력값으로 변경시키는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img067.png&quot; alt=&quot;img067&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ClrN 신호는 비동기 카운터로 우선은 무시하시면 됩니다.&lt;/p&gt;

&lt;p&gt;로드(Load)는 클럭(Clk)과 AND 게이트로 연결하여 로드가 1일때 클럭 신호에 따라 레지스터 값을 변경할 수 있습니다. 그러나 클럭 신호가 다른 신호와 묶이는 경우 타이밍 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위해서 다음과 같이 레지스터의 CE(Clock Enable)에 로드를 연결하여 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img068.png&quot; alt=&quot;img068&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로드가 0인 경우 클럭 신호와 상관없이 레지스터에 저장된 데이터는 이전 상태를 유지하게 되며, 로드가 1인 경우 클럭 신호에 따라 레지스터의 데이터가 입력값으로 변경됩니다.&lt;/p&gt;

&lt;h2 id=&quot;쉬프트-레지스터shift-register&quot;&gt;쉬프트 레지스터(Shift Register)&lt;/h2&gt;

&lt;p&gt;쉬프트 레지스터는 플립플롭에 출력과 입력을 연결하는 방법에 따라 데이터를 왼쪽 또는 오른쪽으로 자리이동하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;쉬프트 레지스터의 종류는 직렬 쉬프트 레지스터와 병렬 쉬프트 레지스터가 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;직렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 입력(Serial in, SI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 출력(Serial out, SO)&lt;/code&gt;을 가지는 레지스터로, 데이터가 한 번에 한 비트씩 쉬프트 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img069.png&quot; alt=&quot;img069&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Shift 신호는 CE와 연결되며, 신호가 1인 경우 쉬프트 레지스터가 동작하며, 신호가 0인 경우 데이터가 쉬프트 되지 않고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 초기 레지스터 값이 0101이고 직렬 입력(SI)이 1101인 경우 타이밍도는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img070.png&quot; alt=&quot;img070&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 번의 클럭 주기마다 데이터가 쉬프트 됨을 확인 할 수 있습니다. 또한 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되는데, 4번의 클럭 주기동안 SO는 초기 레지스터 값인 0101이 출력됨을 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;병렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 입력(Parallel in, PI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 출력(Parallel out, PO)&lt;/code&gt;을 가지는 레지스터 이며, 다음과 같이 플립플롭과 멀티플렉서(MUX)를 통해 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img071.png&quot; alt=&quot;img071&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직렬 쉬프트 레지스터와 달리 한 클럭에 모든 데이터가 동시에 로드되고 동시에 출력됩니다. 이때 쉬프트 신호와 로드 신호가 멀티플렉서의 제어신호가 됩니다.&lt;/p&gt;

&lt;p&gt;쉬프트 신호가 1인 경우 로드 신호에 상관없이 데이터가 쉬프트되며, 쉬프트 신호가 0, 로드 신호가 1이면 레지스터에 데이터가 저장됩니다. 두 신호가 모두 0인 경우에는 레지스터 상태가 유지됩니다.&lt;/p&gt;

&lt;p&gt;위에 그림과 같이 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되므로 병렬 데이터를 직렬 데이터로 변환하기 위해 해당 레지스터를 사용할 수도 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h1&gt;

&lt;p&gt;카운터는 고정된 순환 회로를 통해 클럭 펄스의 갯수를 처리하기 위한 논리회로입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 2진수 값이 1씩 증가하는 2진 카운터가 있으며, n비트의 레지스터를 통해 2&lt;sup&gt;n&lt;/sup&gt;-1 까지 카운트할 수 있습니다. 예를 들어 3비트의 레지스터를 통해서는 0 ~ 7까지 카운트 할 수 있으며 다음과 같이 순환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img072.png&quot; alt=&quot;img072&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카운터에는 동기식 카운터와 비동기식 카운터가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비동기식-카운터&quot;&gt;비동기식 카운터&lt;/h2&gt;

&lt;p&gt;리플 카운터라고도 불리는 비동기식 카운터는 이전 플립플롭의 출력이 다음 플립플롭의 클럭으로 사용되는 카운터 입니다.&lt;/p&gt;

&lt;p&gt;보통 J-K 플립플롭 또는 T 플립플롭으로 설계되며, 숫자가 증가하는 상향 카운터(Up Counter)와 숫자가 감소하는 하향 카운터(Down Counter)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img074.png&quot; alt=&quot;img074&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 카운터는 카운트가 1씩 증가하는 상향 카운터이며, 다음과 같은 타이밍도로 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img073.png&quot; alt=&quot;img073&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Enable이 1인 경우 진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Clock 주기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10진수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;하향 카운터의 경우 Q’ 출력을 클럭으로 사용하며, 카운트가 1씩 감소합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img075.png&quot; alt=&quot;img075&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티플렉서를 통해 상하향 카운터를 만들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img076.png&quot; alt=&quot;img076&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비동기식 카운터는 동기식 카운터에 비해 회로는 간단하지만 전달지연이 커진다는 단점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;동기식-카운터&quot;&gt;동기식 카운터&lt;/h2&gt;

&lt;p&gt;동기식 카운터는 비동기식 카운터의 전달지연을 보완하기 위해 플립플롭에 공통의 클럭신호를 사용하는 카운터입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img077.png&quot; alt=&quot;img077&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 플립플롭은 동일한 클럭신호를 받으며, 이전 플립플롭의 출력이 1인 경우에만 다음 플립플롭이 토글됩니다.&lt;/p&gt;

&lt;h2 id=&quot;링-카운터&quot;&gt;링 카운터&lt;/h2&gt;

&lt;p&gt;링 카운터는 마지막 플립플롭의 출력이 첫 번째 플립플롭의 입력으로 피드백되는 링 형태로 구성된 카운터를 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img078.png&quot; alt=&quot;img078&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링카운터는 모든 플립플롭이 0이라면 000만 출력되기 때문에 최소한 1비트는 1로 프리셋할 필요가 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">레지스터(Register)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">논리회로</title>
      <link href="https://huimang2.github.io/etc/computer-logic-gate" rel="alternate" type="text/html" title="논리회로" />
      <published>2023-04-24T01:00:00+09:00</published>
      <updated>2023-04-24T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-logic-gate</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-logic-gate">&lt;p&gt;지난번 글에서 컴퓨터는 2진수를 통해 데이터를 인식한다고 설명했습니다. 트랜지스터는 전류가 흐르거나 흐르지 않는 상태를 통해 1 또는 0으로 나타낼 수 있습니다. 즉, 트랜지스터를 통해 컴퓨터가 인식할 수 있는 데이터를 나타낼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;논리회로logic-gate&quot;&gt;논리회로(Logic Gate)&lt;/h1&gt;

&lt;p&gt;트랜지스터를 도식화하면 다음과 같은데, Gate에 전압을 걸어주거나 걸어주지 않는 것으로 Drain으로 전류를 흐르게 하거나 흐르지 않게 할 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img022.png&quot; alt=&quot;img022&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 트랜지스터의 특성을 통해 스위치 역할을 함으로써 &lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;논리회로(Logic Gate)&lt;/code&gt;를 만들 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;not-gate&quot;&gt;NOT gate&lt;/h2&gt;

&lt;p&gt;NOT gate는 참을 거짓으로, 거짓을 참으로 출력하는 회로입니다. 즉, Gate에 전류가 흐르면 거짓, 전류가 흐르지 않으면 참을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img023.png&quot; alt=&quot;img023&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A에 전류가 흐르지 않으면 GND로 전류가 흐르지 않아서 출력선으로 전류가 흐르게 됩니다. 즉, 참을 출력합니다.&lt;/p&gt;

&lt;p&gt;반면에 A에 전류가 흐르면 GND로 전류가 흐를 수 있어서 출력선으로는 전류가 흐르지 않습니다. 즉, 거짓을 출력합니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NOT A&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \bar A $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img024.png&quot; alt=&quot;img024&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;and-gate&quot;&gt;AND gate&lt;/h2&gt;

&lt;p&gt;AND gate는 두 입력선이 모두 참이면 참, 아니면 거짓을 출력하는 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img025.png&quot; alt=&quot;img025&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-1&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A AND B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ A \cdot B $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img026.png&quot; alt=&quot;img026&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;or-gate&quot;&gt;OR gate&lt;/h2&gt;

&lt;p&gt;OR gate는 두 입력선 중 하나라도 참이면 참을 출력하는 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img027.png&quot; alt=&quot;img027&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-2&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A OR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ A + B $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img028.png&quot; alt=&quot;img028&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nand-gate&quot;&gt;NAND gate&lt;/h2&gt;

&lt;p&gt;NAND gate는 AND gate의 반대값을 출력하는 회로입니다. 즉, 모든 입력이 참일 경우에만 거짓을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img029.png&quot; alt=&quot;img029&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-3&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A NAND B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \overline {A \cdot B} $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img030.png&quot; alt=&quot;img030&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nor-gate&quot;&gt;NOR gate&lt;/h2&gt;

&lt;p&gt;NOR gate는 OR gate의 반대값을 출력하는 회로입니다. 즉, 두 입력선 중 하나라도 참일 경우에는 거짓을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img031.png&quot; alt=&quot;img031&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-4&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A NOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \overline {A + B} $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img032.png&quot; alt=&quot;img032&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;xor-gate&quot;&gt;XOR gate&lt;/h2&gt;

&lt;p&gt;XOR gate는 배타적 논리합을 구현한 회로입니다. 즉, 두 입력선의 값이 서로 다른 경우에만 참을 출력합니다.
논리식은 $ A \oplus B $로 나타내며, $ \bar A \cdot B + A \cdot \bar B $와 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표-5&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar A \cdot B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ A \cdot \bar B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A XOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 논리식을 토대로 회로를 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img033.png&quot; alt=&quot;img033&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img034.png&quot; alt=&quot;img034&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;xnor-gate&quot;&gt;XNOR gate&lt;/h2&gt;

&lt;p&gt;XOR gate는 XOR gate의 반대값을 출력하는 회로입니다. 즉, 두 입력선의 값이 서로 같은 경우에만 참을 출력합니다.
논리식은 $ \overline {A \oplus B} $ 또는 $ A⊙B $로 나타내며, $ \bar A \cdot \bar B + A \cdot B $와 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표-6&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar A \cdot \bar B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ A \cdot B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A XNOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 논리식을 토대로 회로를 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img035.png&quot; alt=&quot;img035&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img036.png&quot; alt=&quot;img036&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;조합회로combinational-circuit&quot;&gt;조합회로(Combinational Circuit)&lt;/h1&gt;

&lt;p&gt;조합회로는 출력값이 입력값에만 영향을 받는 논리회로입니다. 논리회로에 입력이 주어지면 바로 출력이 나오며, 이전의 회로 상태가 출력에 영향을 미치지 않습니다. 즉, 메모리 소자를 가지지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;가산기adder&quot;&gt;가산기(Adder)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가산기(Adder)&lt;/code&gt;는 입력들의 합을 출력하는 논리회로입니다. 가산기에는 2개의 입력을 더하는 반가산기(Half Adder, HA)와, 3개의 입력을 더하는 전가산기(Full Adder, FA)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. 반가산기(Half Adder, HA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반가산기(HA)&lt;/code&gt;는 2진수 한 자리를 덧셈하여 캐리(Carry)와 덧셈의 결과를 출력합니다. 반가산기의 진리표는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;캐리(C)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;덧셈(S)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;진리표를 보면, 올림수인 캐리는 AND gate, 덧셈의 결과는 XOR gate와 동일함을 알 수 있습니다. 회로는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img037.png&quot; alt=&quot;img037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반가산기의 경우 캐리에 대한 입력을 받지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최하위 비트(Least Significant Bit, LSB)&lt;/code&gt;에서만 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 전가산기(Full Adder, FA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전가산기(FA)&lt;/code&gt;는 반가산기에 캐리를 추가한 3개의 입력을 더하여 캐리와 덧셈의 결과를 출력하는 회로입니다. 전가산기의 진리표는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C&lt;sub&gt;in&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C&lt;sub&gt;out&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;진리표만으로는 회로를 설계하기 어렵습니다. 논리식을 설계하기위해 카르노맵을 그려보겠습니다. 카르노맵에 대한 설명은 이 글에서 생략합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img038.png&quot; alt=&quot;img038&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카르노맵을 통해 다음과 같은 논리식을 설계할 수 있습니다.&lt;/p&gt;

&lt;p&gt;$$
\begin{aligned}
C_{out}
&amp;amp;= \bar A \cdot B \cdot C_{in} + A \cdot \bar B \cdot C_{in} + A \cdot B \cdot \bar C_{in} + A \cdot B \cdot C_{in} \\
&amp;amp;= (\bar A \cdot B + A \cdot \bar B) \cdot C_{in} + A \cdot B \cdot (\bar C_{in} + C_{in}) \\
&amp;amp;= (A \oplus B) \cdot C_{in} + A \cdot B \\
\\
S &amp;amp;= \bar A \cdot B \cdot \bar C_{in} + A \cdot \bar B \cdot \bar C_{in} + \bar A \cdot \bar B \cdot C_{in} + A \cdot B \cdot C_{in} \\
&amp;amp;= (\bar A \cdot B + A \cdot \bar B) \cdot \bar C_{in} + (\bar A \cdot \bar B + A \cdot B) \cdot C_{in} \\
&amp;amp;= A \oplus B \cdot \bar C_{in} + A \odot B \cdot C_{in} \\
&amp;amp;= A \oplus B \cdot \bar C_{in} + \overline{A \oplus B} \cdot C_{in} \\
&amp;amp;= A \oplus B \oplus C_{in}
\end{aligned}
$$&lt;/p&gt;

&lt;p&gt;해당 논리식을 토대로 회로를 그리면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img039.png&quot; alt=&quot;img039&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2개의 반가산기와 OR gate로 구성되어 있음을 알 수 있습니다. 간략화하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img040.png&quot; alt=&quot;img040&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전가산기 n개를 병렬로 연결한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리플 캐리 가산기(Ripple Cary Adder)&lt;/code&gt;라는 n비트 가산기를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img041.png&quot; alt=&quot;img041&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가산기의 B 입력을 부호 플래그와 XOR하여 사용한다면 덧셈과 뺄셈이 모두 가능한 회로가 됩니다. 이것은 2의 보수법을 이용한 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img042.png&quot; alt=&quot;img042&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. 캐리 예측 가산기(Carry Look-ahead Adder, CLA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리플 캐리 가산기는 전가산기를 통해 간단하게 설계할 수 있지만, 비트수가 늘어날수록 연산속도가 느려진다는 문제가 있습니다. 왜냐하면 캐리를 입력으로 받기 때문에 상위 비트는 하위 비트가 계산될 때까지 연산을 하지 못하고 대기해야 하기 때문입니다. 이것을 해결하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;캐리 예측 가산기(CLA)&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;캐리 예측 가산기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 전가산기(Partial Full Adder, PFA)&lt;/code&gt;로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생성(Generation)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전파(Propagation)&lt;/code&gt; 함수를 입력받아 이전 비트의 계산결과를 기다릴 필요 없이 연산을 한번에 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 전가산기(PFA)&lt;/code&gt;는 전가산기(FA)에서 캐리 생성과 관련된 회로를 제외한 회로입니다. 캐리는 PFA에서 2개의 출력선에 의해 결정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img043.png&quot; alt=&quot;img043&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;생성(G) 함수&lt;/strong&gt;는 이전 비트의 결과값에 상관없이 캐리의 생성여부를 결정합니다. 부분 전가산기의 AND gate에 의해 출력된 값이 이에 해당합니다.&lt;/p&gt;

&lt;p&gt;$ G(A, B) = A \cdot B $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;전파(P) 함수&lt;/strong&gt;는 이전 비트의 결과값에 따른 캐리의 생성여부를 출력합니다. 부분 전가산기의 XOR gate에 의해 출력된 값이 이에 해당합니다.&lt;/p&gt;

&lt;p&gt;$ P(A, B) = A \oplus B $&lt;/p&gt;

&lt;p&gt;G와 P를 통해 S와 C를 구하는 논리식을 다음과 같이 세울 수 있습니다.&lt;/p&gt;

&lt;p&gt;$$
S_{i} = P_{i} \oplus C_{i} \\
C_{i+1} = G_{i} + P_{i} \cdot C_{i}
$$&lt;/p&gt;

&lt;p&gt;부분 전가산기 4개로 4비트 전가산기를 구성한다면 4개의 캐리에 대한 회로를 구성해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img044.png&quot; alt=&quot;img044&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 구성된 4비트 가산기를 2개 연결하면 8비트 가산기, 4개 연결하면 16비트 가산기를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img045.png&quot; alt=&quot;img045&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;디코더decoder--인코더encoder&quot;&gt;디코더(Decoder) / 인코더(Encoder)&lt;/h2&gt;

&lt;p&gt;디코더는 입력 변수들의 최소항(minterm)을 생성하는 논리회로입니다. n개의 입력을 통해 2&lt;sup&gt;n&lt;/sup&gt;개의 최소항을 출력합니다.&lt;/p&gt;

&lt;p&gt;최소항은 진리표에서 하나의 행만 1이 되고 나머지는 0이 되는 곱을 말합니다. 예를 들어 2개의 입력을 통해 다음과 같이 4개의 최소항을 생성할 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;해당 진리표를 통해 다음과 같이 회로를 그릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img046.png&quot; alt=&quot;img046&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 회로를 활성화 또는 비활성화 시키기위해 다음과 같이 Enable 입력을 연결하면 2X4 디코더가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img047.png&quot; alt=&quot;img047&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2X4 디코더를 2개 연결한다면 3X8 디코더를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img048.png&quot; alt=&quot;img048&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;인코더는 디코더의 반대입니다. 2&lt;sup&gt;n&lt;/sup&gt;개의 입력으로 부터 n개의 이진코드를 출력합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;인코더는 OR gate를 통해 간단하게 회로를 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img049.png&quot; alt=&quot;img049&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인코더를 통해 암호화된 출력이 디코더의 입력이 된다면 원래의 입력으로 해독할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img050.png&quot; alt=&quot;img050&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티플렉서multiplexer-mux&quot;&gt;멀티플렉서(Multiplexer, MUX)&lt;/h2&gt;

&lt;p&gt;멀티플렉서는 n개의 선택선 입력을 통해 2n개의 데이터 입력 중 하나를 선택하여 출력선으로 연결하는 논리회로입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 선택기(Data Selector)&lt;/code&gt;라고도 불립니다.&lt;/p&gt;

&lt;p&gt;CPU에서 연산을 하기 위해서는 RAM으로부터 데이터를 가져와야합니다. 이때 데이터를 가져오는 가장 간단한 방법은 램과 레지스터를 1:1로 연결하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img051.png&quot; alt=&quot;img051&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4비트만 연결해도 16개의 출력선이 필요하여 너무 복잡해집니다. 이를 해결하기 위해 멀티플렉서를 사용합니다. 멀티플렉서는 여러 입력 가운데서 하나의 입력을 선택하여 출력합니다.&lt;/p&gt;

&lt;p&gt;n개의 제어 입력을 통해 2&lt;sup&gt;n&lt;/sup&gt;개의 데이터 입력을 제어할 수 있습니다. 아래는 4비트의 입력선을 제어하기 위한 4X1 멀티플렉서 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img052.png&quot; alt=&quot;img052&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어 입력선은 디코더와 동일하며, 디코더의 출력선은 데이터 입력선과 AND 연산을 통해 입력선을 선택할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;멀티플렉서를 통해 메모리에서 출력된 데이터는 버스(bus)를 통해 CPU의 레지스터로 전달됩니다. 이때 2&lt;sup&gt;n&lt;/sup&gt;개의 출력선 중 하나를 선택하여 전송하는데, 이것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디멀티플렉서(Demultiplexer, DMUX)&lt;/code&gt;에 의해 수행됩니다.&lt;/p&gt;

&lt;p&gt;디멀티플렉서의 회로 또한 n개의 제어 입력이 필요하며, 하나의 데이터 입력선과 AND 연산을 통해 출력선을 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img053.png&quot; alt=&quot;img053&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;순차회로sequential-circuit&quot;&gt;순차회로(Sequential Circuit)&lt;/h1&gt;

&lt;p&gt;순차회로는 출력값이 이전 상태와 현재 입력값에 영향을 받는 논리회로입니다. 즉, 조합회로에 기억 기능이 추가된 회로입니다.&lt;/p&gt;

&lt;p&gt;순차회로는 클럭 신호에 의해 상태가 변하는 동기회로와 그렇지 않은 비동기회로로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;순차회로가 1비트의 정보를 기억하는 방법은 피드백(Feedback) 경로라 불리는 폐루프를 형성하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img054.png&quot; alt=&quot;img054&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 회로와 같이 피드백을 통해 NOT 게이트 사이에 비트 정보를 저장할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;래치latch&quot;&gt;래치(Latch)&lt;/h2&gt;

&lt;p&gt;래치는 클럭 입력을 가지지 않는 비동기회로입니다. 래치는 SR래치와 D래치가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. S-R 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SR래치에서 S는 Set을 의미하며 1을 출력하고, R은 Reset을 의미하며 0을 출력합니다. 각각의 출력 Q와 Q’은 다시 입력으로 들어가서 피드백을 형성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img055.png&quot; alt=&quot;img055&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;R&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$ R = 1, S = 0 $ 이면 $ Q = 0$ 이 출력되며, 출력된 Q는 S가 연결된 NOR 게이트로 피드백됩니다. $ S = 0 $ 이므로 $ \bar Q = 1 $ 이 출력되며, 출력된 $ \bar Q $ 는 R이 연결된 NOR 게이트로 피드백 됩니다. R이 연결된 NOR 게이트의 입력은 1, 1이 되므로 $ Q = 0 $ 이 되어 Reset 상태가 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ Q = 0, \bar Q = 1 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;반면 $ R = 0, S = 1 $ 이면 $ \bar Q = 0 $ 이 출력되며, 출력된 $ \bar Q $ 는 R이 연결된 NOR 게이트로 피드백됩니다. $ R = 0 $ 이므로 $ Q = 1 $ 이 출력되며, 출력된 Q는 S가 연결된 NOR 게이트로 피드백됩니다. NOR 게이트의 입력은 1, 1이 되므로 $ \bar Q = 0 $ 이 되어 Set 상태가 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ Q = 1, \bar Q = 0 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;$ R = 0, S = 0 $ 이면 $ Q = Q, \bar Q = \bar Q $ 가 되어 상태가 유지되며, $ R = 1, S = 1 $ 이면 Q와 $ \bar Q $ 가 0, 1 로 진동하게 되므로 입력이 제한됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;NAND 게이트를 사용하여 SR 래치를 만들 수도 있습니다. 이 경우 입력이 반전됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img056.png&quot; alt=&quot;img056&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;R&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$ R = 0, S = 1 $ 이면 $ Q = 0, \bar Q = 1 $ 이 되어 reset 상태가 되며, $ R = 1, S = 0 $ 이면 $ Q = 1, \bar Q = 0 $ 이 되어 set 상태가 됩니다.&lt;/p&gt;

&lt;p&gt;또한 $ R = 0, S = 0 $ 이면 Q와 $ \bar Q $ 가 0, 1 로 진동하므로 입력이 제한되며, $ R = 1, S = 1 $ 이면 $ Q = Q, \bar Q = \bar Q $ 가 되어 상태가 유지됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 게이트형 S-R 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게이트형 SR 래치는 Enable 이라 불리는 게이트 신호를 통해 출력을 결정하는 기억회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img057.png&quot; alt=&quot;img057&quot; /&gt;&lt;/p&gt;

&lt;p&gt;E 신호가 HIGH인 경우 래치의 입력이 출력에 반영되고, E 신호가 LOW인 경우 래치의 입력은 출력에 반영되지 않고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. D 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;D 래치는 하나의 입력을 통해 출력 Q를 결정하는 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img058.png&quot; alt=&quot;img058&quot; /&gt;&lt;/p&gt;

&lt;p&gt;S = 0, R = 0 인 입력과 S = 1, R = 1 인 입력을 배제하여 입력과 출력이 동일한 회로를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;플립플롭flip-flop&quot;&gt;플립플롭(Flip-Flop)&lt;/h2&gt;

&lt;p&gt;플립플롭은 클럭 입력을 가지는 동기회로입니다.&lt;/p&gt;

&lt;p&gt;엄밀하게 말하자면 래치 또한 클럭신호를 가질 수 있습니다. 하지만 CLOCK 신호가 HIGH인 동안 동작하는 래치와 달리 플립플롭의 경우 CLOCK 신호가 HIGH가 되는 순간에만 동작합니다.&lt;/p&gt;

&lt;h6 id=&quot;래치의-경우&quot;&gt;래치의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img059.png&quot; alt=&quot;img059&quot; /&gt;&lt;/p&gt;

&lt;p&gt;래치는 위와 같이 CLOCK이 HIGH이면 INPUT을 출력하고 CLOCK이 LOW이면 상태를 유지합니다.&lt;/p&gt;

&lt;h6 id=&quot;플립플롭의-경우&quot;&gt;플립플롭의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img060.png&quot; alt=&quot;img060&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플립플롭의 경우 CLOCK이 HIGH가 되는 순간에만 INPUT을 출력하고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. S-R 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;S-R 플립플롭은 다음과 같이 게이트형 S-R 래치 2개로 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img061.png&quot; alt=&quot;img061&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에 있는 래치를 마스터, 뒤에 있는 래치를 슬레이브라고 하기때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마스터-슬레이브 플립플롭&lt;/code&gt;이라고도 합니다.&lt;/p&gt;

&lt;p&gt;아래 타이밍을 살펴보면 CLOCK이 HIGH인 순간에만 Q&lt;sub&gt;1&lt;/sub&gt;의 상태가 Q&lt;sub&gt;2&lt;/sub&gt;에 반영되고 &lt;sub&gt;2&lt;/sub&gt;의 상태가 유지되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img062.png&quot; alt=&quot;img062&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. D 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;D 플립플롭은 다음과 같이 D 래치 2개로 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img063.png&quot; alt=&quot;img063&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. J-K 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JK 플립플롭은 S = 1, R = 1 입력이 제한되는 문제를 보완하기 위한 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img064.png&quot; alt=&quot;img064&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 회로를 JK 래치라고 하며, J = 1, K = 1이 입력되면 $ Q = \bar Q $ 로 토글됩니다. 물론 하나의 JK 래치로는 반복적으로 토글되므로 2개의 JK 래치를 통해 플립플롭으로 구성한다면 CLOCK이 HIGH가 되는 순간에만 토글이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img065.png&quot; alt=&quot;img065&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;J&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;K&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. T 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;T 플립플롭은 JK 플립플롭에서 D 플립플롯처럼 입력을 하나만 주는 회로입니다. T가 0이면 이전값을 유지하고, T가 1이면 출력값이 토글 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img066.png&quot; alt=&quot;img066&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;T&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">지난번 글에서 컴퓨터는 2진수를 통해 데이터를 인식한다고 설명했습니다. 트랜지스터는 전류가 흐르거나 흐르지 않는 상태를 통해 1 또는 0으로 나타낼 수 있습니다. 즉, 트랜지스터를 통해 컴퓨터가 인식할 수 있는 데이터를 나타낼 수 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">데이터의 표현</title>
      <link href="https://huimang2.github.io/etc/computer-binary" rel="alternate" type="text/html" title="데이터의 표현" />
      <published>2023-04-23T01:00:00+09:00</published>
      <updated>2023-04-23T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-binary</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-binary">&lt;p&gt;지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;정보의-단위&quot;&gt;정보의 단위&lt;/h1&gt;

&lt;p&gt;컴퓨터는 MOSFET을 통해 전류가 흐르거나 흐르지 않는 상태를 인식할 수 있습니다. 전류가 흐르면 1, 전류가 흐르지 않는다면 0으로 나타낼 수 있는데, 이렇게 0과 1을 표현하는 가장 작은 정보 단위를 비트(bit)라고 합니다.&lt;/p&gt;

&lt;p&gt;1비트를 통해서는 2가지 정보를 알 수 있으며, 2비트로는 (0, 0), (0, 1), (1, 0), (1, 1) 이렇게 4가지 정보를 알 수 있습니다. n비트를 통해서는 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/strong&gt;가지 정보를 표현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로그램은 수많은 비트로 이루어져 있어서 비트 단위로 데이터를 나타내기 힘들기 때문에, 데이터는 8개의 비트를 묶어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바이트(byte)&lt;/code&gt;를 정보의 기본단위로 사용합니다. 즉, 1byte는 8bit에 해당하며, 2&lt;sup&gt;8&lt;/sup&gt; = 256가지의 정보를 나타낼 수 있습니다. 보통 1byte로는 하나의 문자를 나타낼 수 있지만, 한글이나 한자 등 동양권 문자의 경우 1byte로 나타낼 수 없어서 하나의 문자당 2byte를 사용합니다.&lt;/p&gt;

&lt;p&gt;8bit가 모여 1byte가 된 것처럼, byte는 1000개씩 묶어 더 큰 단위를 나타낼 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;데이터-단위&quot;&gt;데이터 단위&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단위&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트(bit)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0, 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;바이트(Byte)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8 bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;킬로바이트(KB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메가바이트(MB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 KB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기가바이트(GB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;테라바이트(TB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페타바이트(PB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 TB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 외에도 CPU가 한 번에 처리할 수 있는 정보의 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;워드(word)&lt;/code&gt;로 나타냅니다.&lt;/p&gt;

&lt;h1 id=&quot;이진법&quot;&gt;이진법&lt;/h1&gt;

&lt;p&gt;컴퓨터는 0과 1을 사용하는 2진법(binary)을 통해 데이터를 이해합니다. 2진법은 자릿값이 올라감에 따라 그 크기가 2배씩 커지게 되므로 2진법을 십진법으로 바꾸기 위해서는 자릿수마다 2&lt;sup&gt;n&lt;/sup&gt;을 곱한 값을 모두 더하면 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어 이진수 0b1101을 십진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b1101 = 1 * 2&lt;sup&gt;3&lt;/sup&gt; + 1 * 2&lt;sup&gt;2&lt;/sup&gt; + 0 * 2&lt;sup&gt;1&lt;/sup&gt; + 1 * 2&lt;sup&gt;0&lt;/sup&gt; = 8 + 4 + 1 = 13&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴퓨터가 이진수로 음수를 표현하는 방법은 3가지가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;부호-비트와-절댓값-방법&quot;&gt;부호 비트와 절댓값 방법&lt;/h2&gt;

&lt;p&gt;2진법으로 수를 표현할 때, 가장 왼쪽에 있는 비트의 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위 비트(Most Significant Bit, MSB)&lt;/code&gt;라고 합니다. 부호 비트와 절댓값 방법은 최상위 비트를 이용하여 음수를 표현합니다.&lt;/p&gt;

&lt;p&gt;예를 정수 13의 경우 다음과 같이 2진법으로 나타낼 수 있습니다.(보통 정수 자료형은 4byte의 크기를 가집니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 -13으로 나타내기 위해서는 최상위 비트를 1로 바꾸면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 1비트가 부호를 표현하기 위해 사용되어 표현할 수 있는 절대값의 범위는 절반으로 줄어들게 됩니다. (0 ~ 2&lt;sup&gt;16&lt;/sup&gt; - 1)&lt;/p&gt;

&lt;p&gt;또한 +0과 -0이 따로 존재하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;1의-보수법&quot;&gt;1의 보수법&lt;/h2&gt;

&lt;p&gt;1의 보수법은 비트를 반전시켜 음수를 표현하는 방법입니다. 이 방법을 사용하면 비트의 NOT 연산만으로도 음수를 표현할 수 있어서 연산이 간단해집니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법을 통해 연산을 하는 데 있어서 캐리(carry)가 중요합니다. 캐리는 상태 레지스터의 플래그를 설명할 때 언급한 적이 있는데, 올림수나 빌림수 여부를 나타냅니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;캐리를 최하위 비트에 더해주면 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b0111 + 0b0001 = 0b1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 2진수는 10진수로 나타내면 8이 되며, 이는 13 - 5와 동일한 결과입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 1의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법은 부호 비트와 절댓값 방법과 마찬가지로 +0과 -0이 따로 존재한다는 문제점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2의-보수법&quot;&gt;2의 보수법&lt;/h2&gt;

&lt;p&gt;2의 보수법은 1의 보수법을 통해 표현한 값에 1을 더하여 음수를 표현하는 방법입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2의 보수법을 통해 연산을 하는 데 있어서 1의 보수법과 달리 캐리가 발생하면 캐리를 버립니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법과 달리 캐리를 버린 값이 최종 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 2의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 -0은 2의 보수를 구하는 과정에서 최상위 비트를 초과한 오버플로우가 발생하여 +0이 됩니다. 그러므로 2의 보수법에서는 하나의 0만 존재하게 됩니다. 때문에 현재 대부분의 시스템에서는 2의 보수법을 사용하여 음수를 표현합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CPU의 작동 원리</title>
      <link href="https://huimang2.github.io/etc/computer-cpu" rel="alternate" type="text/html" title="CPU의 작동 원리" />
      <published>2023-04-22T01:00:00+09:00</published>
      <updated>2023-04-22T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-cpu</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-cpu">&lt;p&gt;CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img003.png&quot; alt=&quot;img003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원자는 최외각 전자가 8개일 때 가장 안정적인 구조를 가지게 되므로 순수한 실리콘의 경우 전자가 이동하지 않으므로 전류가 흐를 수 없습니다. 그러므로 최외각 전자가 3개이거나 5개인 원소를 첨가하여 전류가 흐를 수 있는 상태로 만들게 되는데, 이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도핑(Doping)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;붕소(B)와 같이 최외각 전자가 3개인 원소를 첨가하게 되면 빈 자리가 생기게 되는데, 이를 양공이라고 합니다. 공유결합하고 있는 최외각 전자가 양공으로 이동하면서 전류가 흐를 수 있으며, 해당 반도체를 P형 반도체라고 합니다.&lt;/p&gt;

&lt;p&gt;인(P)과 같이 최외각 전자가 5개인 원소를 첨가하게 되면 자유전자가 1개 늘어 전류가 흐를 수 있으며, 해당 반도체는 N형 반도체라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img004.png&quot; alt=&quot;img004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 반도체는 전기적으로 중성상태에 있습니다. 두 반도체를 서로 연결한다면 N형 반도체의 자유전자가 P형 반도체의 양공으로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;N형 반도체는 상대적으로 자유전자를 빼앗겨 (+)전하를 가지게 되고, P형 반도체는 상대적으로 자유전자를 얻으면서 (-)전하를 가지게 되면서 전기장이 형성됩니다.&lt;/p&gt;

&lt;p&gt;어느정도 이동하다가 P형 반도체의 전자 반발력으로 인해 자유전자가 양공으로 이동하지 못하게 되는데, 이때 양공이 채워져 더이상 전자가 이동할 수 없는 영역을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공핍영역&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img005.png&quot; alt=&quot;img005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 건전지의 (+)극을 N형 반도체에 연결하고 (-)극을 P형 반도체에 연결한다면 공핍영역이 넓어져 전자가 이동할 수
없습니다. 이것을 역방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img006.png&quot; alt=&quot;img006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 반대로 연결한다면 공핍영역의 전기장을 극복하고 전자가 P형 반도체에서 N형 반도체로 이동하면서 전류가 흐를 수 있게 됩니다. 이것은 순방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img007.png&quot; alt=&quot;img007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 순방향으로 연결할 때만 전류가 흐를 수 있으며, 이때 전류의 방향은 P형 반도체에서 N형 반도체로 흐릅니다. 즉, 전류를 한방향으로 흐를 수 있게 하는데, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다이오드(Diode)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img008.png&quot; alt=&quot;img008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여담으로 전자가 공핍영역을 지날 때 빛으로 에너지를 발산하기도 하는데, 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;발광 다이오드(Light Emitting Diode)&lt;/code&gt; 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LED&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img009.png&quot; alt=&quot;img009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 2개의 P형 반도체 사이에 N형 반도체를 연결하여 건전지를 각각 순방향과 역방향으로 연결해 보겠습니다. 이 경우 순방향으로 연결된 회로에만 전류가 흐릅니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img010.png&quot; alt=&quot;img010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 순방향 회로의 전압을 높여준다면 공핍영역에 의한 전자 반발력보다 건전지에 의한 양전하의 반발력이 더 커지면서 역방향 회로를 통해서도 전류가 흐를 수 있게 됩니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img011.png&quot; alt=&quot;img011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역방향 회로에 전압을 더 높여준다면 더 많은 전자가 공핍영역을 통과할 수 있으므로 더 많은 전류가 흐르도록 할 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img012.png&quot; alt=&quot;img012&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 전압을 높이거나 낮추어 전류의 흐름을 제어하는 장치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜지스터(Transistor)&lt;/code&gt;라고 합니다. 트랜지스터는 위와 같은 PNP 트랜지스터와 NPN 트랜지스터가 있습니다.&lt;/p&gt;

&lt;p&gt;CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOSFET&lt;/code&gt;이라는 0.1nm 크기의 트랜지스터로 구성되어 있습니다. MOSFET은 금속(Metal)과 반도체(Semiconductor) 사이에 부도체인 산화막(Oxide)이 들어있는 적층 구조로 되어 있습니다. 이 구조를 MOS 구조라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img019.png&quot; alt=&quot;img019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반도체 기판이 N형이면 NMOS, P형이면 PMOS라고 부르며, 산화물인 SiO2로는 전류가 흐르지 않습니다. 아래와 같이 건전지를 연결해보겠습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img020.png&quot; alt=&quot;img020&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 오른쪽 회로가 역방향으로 연결되었기 때문에 전류가 흐르지 않습니다. 이번에는 가운데 금속에 전압을 걸어봅시다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img021.png&quot; alt=&quot;img021&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 산화물에 의하여 전류는 흐르지 않지만 위에서 아래로 전기장이 걸리면서 전자가 산화물 아래에 모이게 됩니다. 이 전자들이 N형 반도체를 이어주는 통로가 되어 전류가 흐르게 됩니다.&lt;/p&gt;

&lt;p&gt;즉, MOSFET이란 MOS의 전계 효과(Field Efect)를 활용한 트랜지스터(Transistor)입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컴퓨터의 구조</title>
      <link href="https://huimang2.github.io/etc/computer-architecture" rel="alternate" type="text/html" title="컴퓨터의 구조" />
      <published>2023-04-21T01:00:00+09:00</published>
      <updated>2023-04-21T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-architecture</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-architecture">&lt;h1 id=&quot;중앙처리장치cpu&quot;&gt;중앙처리장치(CPU)&lt;/h1&gt;

&lt;p&gt;CPU는 컴퓨터에서 기억, 해석, 연산, 제어라는 4가지의 주요 기능을 담당하는 장치입니다.&lt;/p&gt;

&lt;p&gt;컴퓨터의 대뇌에 해당하며, 프로그램의 명령어를 해석하여 데이터를 연산 및 처리함으로써 컴퓨터의 각 장치들을 제어합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img001.png&quot; alt=&quot;img001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터&lt;/code&gt; 3가지로 구성되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;산술논리장치&quot;&gt;산술논리장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치(Arithmetic and Logical Unit, ALU)&lt;/code&gt;는 덧셈과 뺄셈 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술연산&lt;/code&gt;과 논리합, 논리곱, 배타적 논리합과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리연산&lt;/code&gt;을 계산하는 디지털 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img013.png&quot; alt=&quot;img013&quot; /&gt;&lt;/p&gt;

&lt;p&gt;산술논리장치는 논리합을 계산하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가산기(adder)&lt;/code&gt;, 보수값을 출력하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보수기(complementer)&lt;/code&gt;, 산술 및 논리 연산의 결과를 일시적으로 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;누산기(accumulator)&lt;/code&gt;, 명령어를 수행하기 위해 필요한 데이터를 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터(data register)&lt;/code&gt; 등으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;산술논리장치가 수행하는 마이크로 연산은 다음과 같이 분류할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;산술-연산&quot;&gt;산술 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ADD&lt;/td&gt;
      &lt;td&gt;X ← A + B&lt;/td&gt;
      &lt;td&gt;A와 B를 더합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUB&lt;/td&gt;
      &lt;td&gt;X ← A + (~B + 1)&lt;/td&gt;
      &lt;td&gt;A에 B를 뺍니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MUL&lt;/td&gt;
      &lt;td&gt;X ← A × B&lt;/td&gt;
      &lt;td&gt;A와 B를 곱합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIV&lt;/td&gt;
      &lt;td&gt;X ← A ÷ B&lt;/td&gt;
      &lt;td&gt;A를 B로 나눕니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INC&lt;/td&gt;
      &lt;td&gt;X ← A + 1&lt;/td&gt;
      &lt;td&gt;A를 1 증가 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DEC&lt;/td&gt;
      &lt;td&gt;X ← A - 1&lt;/td&gt;
      &lt;td&gt;A를 1 감소 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NEG&lt;/td&gt;
      &lt;td&gt;X ← ~A + 1&lt;/td&gt;
      &lt;td&gt;A의 음수값을 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h6 id=&quot;논리-연산&quot;&gt;논리 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AND&lt;/td&gt;
      &lt;td&gt;X ← A &amp;amp; B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 AND 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;X ← A | B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 OR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NOT&lt;/td&gt;
      &lt;td&gt;X ← ~A&lt;/td&gt;
      &lt;td&gt;A의 보수를 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XOR&lt;/td&gt;
      &lt;td&gt;X ← A ^ B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 XOR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASR&lt;/td&gt;
      &lt;td&gt;X ← A » n, A[7] ← A[7]&lt;/td&gt;
      &lt;td&gt;부호를 유지시킨 채 A를 오른쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSR&lt;/td&gt;
      &lt;td&gt;X ← A » n&lt;/td&gt;
      &lt;td&gt;A를 오른쪽으로쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROL&lt;/td&gt;
      &lt;td&gt;X ← A « 1, A[0] ← A[7]&lt;/td&gt;
      &lt;td&gt;첫 번째 비트를 마지막 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROR&lt;/td&gt;
      &lt;td&gt;X ← A » 1, A[7] ← A[0]&lt;/td&gt;
      &lt;td&gt;마지막 비트를 첫 번째 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;산술논리장치는 제어장치로부터 전달받은 제어신호를 통해 두 데이터 레지스터의 값을 연산하여 결과값을 누산기에 저장합니다. 이때 연산 결과에 대한 부가정보를 상태 레지스터에 저장합니다. 상태 레지스터의 구조는 CPU마다 다를 수 있으며, 상태 레지스터에 저장되는 플래그의 종류는 다음과 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;상태-레지스터-플래그&quot;&gt;상태 레지스터 플래그&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;플래그 종류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;부호&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부호 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td&gt;연산 결과의 부호를 나타냅니다. 1이면 음수, 0이면 양수임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제로 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td&gt;연산 결과가 0인지 여부를 나타냅니다. 1이면 0, 0이면 0이 아님을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;캐리 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td&gt;연산 결과에서 올림수나 빌림수가 발생했는지를 나타냅니다. 1이면 올림수나 빌림수가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;오버플로우 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;연산 과정에서 오버플로우가 발생했는지를 나타냅니다. 1이면 오버플로우가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터럽트 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td&gt;인터럽트가 가능한지를 나타냅니다. 1이면 인터럽트가 가능함을, 0이면 불가능함을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;슈퍼바이저 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P&lt;/td&gt;
      &lt;td&gt;커널모드로 실행중인지 사용자모드로 실행중인지를 나타냅니다. 1이면 커널모드, 0이면 사용자모드임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;제어장치&quot;&gt;제어장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치(Control Unit, CU)&lt;/code&gt;는 입출력장치 간 통신 및 조율을 제어하는 제어 신호를 보내고, 명령어를 읽고 해석하여 데이터 처리의 순서를 결정하는 장치입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img014.png&quot; alt=&quot;img014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어장치는 클럭(Clock), 명령어, 상태 플래그, 제어신호를 받아들이고, CPU 내부의 ALU나 레지스터 또는 CPU 외부의 제어버스로 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클럭(clock)&lt;/code&gt;이란 컴퓨터 부품을 움직이게 할 수 있는 시간 단위입니다. 클럭은 1과 0이 반복되어 나타나는데, 이 반복의 기본 단위를 클럭의 주기(period)라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img015.png&quot; alt=&quot;img015&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1초동안 반복되는 주기의 횟수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주파수(frequency)&lt;/code&gt;라고 하며, 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;헤르츠(Hz)&lt;/code&gt;를 사용합니다. 인텔 코어 i5를 기준으로 기본 클럭이 2.4GHz 이며, 이것은 1초에 2.4 × 10^9번의 주기가 반복됨을 의미합니다. 그러므로 오버클럭을 하게 되면 주기가 증가하여 CPU의 처리속도를 증가시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;정리하면, 제어장치는 클럭에 맞추어 명령어 레지스터로부터 해석할 명령어를 가져와서 적절한 제어신호를 내보냅니다.&lt;/p&gt;

&lt;h2 id=&quot;레지스터&quot;&gt;레지스터&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터(register)&lt;/code&gt;는 CPU 내부의 작은 임시 저장장치 입니다. 프로그램 속의 명령어와 데이터는 프로그램 실행 전/후로 레지스터에 저장됩니다. CPU 내부에는 다양한 레지스터가 존재하며, 각기 다른 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. 프로그램 카운터(Program Counter, PC)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램 카운터는 메모리에서 읽어들일 명령어의 주소를 저장합니다. 프로그램을 순차적으로 처리하기 위해 프로그램의 순서를 카운트하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 포인터(Instruction Pointer, IP)&lt;/code&gt;라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 명령어 레지스터(Instruction Register, IR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어 레지스터는 메모리에서 읽어들인 명령어를 저장하는 레지스터 입니다. 제어장치는 IR에 있는 명령어를 해석하여 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. 메모리 주소 레지스터(Memory Address Register, MAR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터 입니다. CPU가 읽고자 하는 주소 값을 주소 버스로 보내기 위해서는 MAR를 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 버퍼 레지스터는 메모리와 주고 받을 값을 저장하는 레지스터 입니다. 메모리에 값을 쓰기 위해서는 MBR을 거쳐야 하며, 메모리의 데이터 버스를 통해 값을 전달받을 때도 MBR을 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;5. 상태 레지스터(Status Register, SR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산 결과 또는 CPU의 상태에 대한 부가적인 정보를 저장하고 있는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;6. 작업 레지스터(Working Resister, WR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ALU와 직접 연결되어 있는 레지스터로, 연산 과정의 중간값이나 결과를 저장하는 누산기 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;7. 범용 레지스터(General Resister, GR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일반적인 상황에서 자유롭게 사용할 수 있는 레지스터로, 데이터와 주소를 모두 저장할 수 있습니다. ALU와는 연결되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;8. 스택 포인터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스택 포인터는 스택 주소 지정 방식에 사용되는 레지스터 입니다. 메모리 스택 영역의 꼭대기 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img016.png&quot; alt=&quot;img016&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;9. 베이스 레지스터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;베이스 레지스터는 프로그램 카운터와 함께 변위 주소 지정 방식에 사용되는 레지스터 입니다. 주소를 지정하기 위한 기준이 되는 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p&gt;변위 주소 지정 방식은 오퍼랜드의 필드값과 특정 레지스터 값을 더하여 유효 주소를 얻게 되는데, 오퍼랜더 값과 프로그램 카운터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대 주소 지정 방식&lt;/code&gt;, 오퍼랜더 값과 베이스 레지스터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변위 주소 지정 방식&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;메모리&quot;&gt;메모리&lt;/h1&gt;

&lt;p&gt;메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 장치입니다.&lt;/p&gt;

&lt;p&gt;메모리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 주소 레지스터(MAR)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 버퍼 레지스터(MBR)&lt;/code&gt;로 구성되며, CPU와 데이터를 주고 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 버스(system bus)&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;시스템 버스는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 버스(address bus)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 버스(data bus)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 버스(control bus)&lt;/code&gt;로 구성됩니다.&lt;/p&gt;

&lt;p&gt;메모리는 크게 읽기 전용 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM(Read Only Memory)&lt;/code&gt;과 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAM(Random Access Memory)&lt;/code&gt;, 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;플래시 메모리(Flash Memory)&lt;/code&gt;로 나눌 수 있으며, 통상적으로 메모리는 RAM을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;

&lt;p&gt;RAM의 종류는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDR SDRAM&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. DRAM(Dynamic RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRAM은 전원이 연결되어 있더라도 저장된 데이터가 동적으로 사라지는 RAM 입니다. 그렇기 때문에 데이터의 소멸을 막기 위해서는 주기적으로 저장된 데이터를 재활성화(refresh) 해야 합니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 낮고 저렴하며 집적도가 높아 대용량으로 설계하기 용이하기 때문에 일반적으로 메모리에 사용되는 RAM은 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. SRAM(Static RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SRAM은 전원이 연결되어 있다면 저장된 데이터가 사라지지 않는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 높고 가격이 비싸며 집적도가 낮기 때문에 일반적으로 대용량으로 설계할 필요가 없고 빨라야 하는 캐시 메모리에서 사용되는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. SDRAM(Synchronous RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SDRAM은 클럭 신호와 동기화되는 발전된 형태의 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. DDR SDRAM(Double Data Rate SDRAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 데이터를 주고 받는 대역폭을 넓혀 속도를 빠르게 만든 SDRAM 입니다. 최근 대중적으로 사용하는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 SDRAM 보다 대역폭이 두 배 넓다면, DDR2 SDRAM은 DDR SDRAM 보다 대역폭이 두 배 넓습니다. 즉, DDR2 SDRAM은 SDRAM 보다 대역폭이 네 배 넓습니다.&lt;/p&gt;

&lt;p&gt;동일하게 DDR3 SDRAM은 DDR2 SDRAM 보다 대역폭이 두 배 넓으며, DDR4 SDRAM은 DDR3 SDRAM 보다 대역폭이 두 배 넓습니다. 그러므로 DDR4 SDRAM 4G는 DDR3 SDRAM 8G와 속도가 동일합니다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-메모리&quot;&gt;캐시 메모리&lt;/h2&gt;

&lt;p&gt;캐시 메모리는 CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치 입니다. CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 사용합니다.&lt;/p&gt;

&lt;p&gt;캐시 메모리는 계층적으로 L1, L2, L3 캐시 메모리로 구성할 수 있으며, 일반적으로 L1 캐시와 L2 캐시는 CPU 내부에, L3 캐시는 CPU 외부에 위치합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img017.png&quot; alt=&quot;img017&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 프로세서의 경우 코어마다 L1, L2 캐시가 있기 때문에 데이터의 일관성을 유지하기 위해 캐시 메모리를 동기화 시키는 것이 중요합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img018.png&quot; alt=&quot;img018&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캐시 메모리는 메모리보다 용량이 작기 때문에 메모리의 일부 내용을 저장합니다. 그렇기 때문에 CPU가 자주 사용할 법한 내용을 예측하여 캐시 메모리에 저장합니다.&lt;/p&gt;

&lt;p&gt;CPU는 최근에 접근했던 메모리 공간에 다시 접근하려고 하며, 접근한 메모리 공간 근처를 접근하려는 경향이 있는데, 이러한 경향을 바탕으로 만들어진 원리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조 지역성의 원리&lt;/code&gt;라고 합니다. 이 원리를 바탕으로 캐시 메모리를 사용한다면 캐시 메모리의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;보조기억장치&quot;&gt;보조기억장치&lt;/h1&gt;

&lt;p&gt;보조기억장치는 현재 실행되지 않는 프로그램이나 데이터를 저장하고 있다가 필요한 경우 RAM으로 데이터를 전달하는 장치 입니다.&lt;/p&gt;

&lt;p&gt;메모리는 보조기억장치에 비하여 비쌀 뿐만 아니라 전원이 꺼지면 저장된 내용을 잃어버린다는 단점이 존재합니다. 그러므로 데이터를 영구적으로 저장하기 위해서는 보조 기억장치에 데이터를 저장해야 합니다.&lt;/p&gt;

&lt;p&gt;보조기억장치에는 하드디스크와 플래시 메모리가 있습니다. 하드디스크는 자기적인 방식으로 데이터를 저장하는 장치이며, 플래시 메모리는 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치입니다. 대표적으로 SSD가 플래시 메모리에 속합니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력장치&quot;&gt;입출력장치&lt;/h1&gt;

&lt;p&gt;입출력장치는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 장치입니다. 대표적인 입출력 장치로 키보드, 모니터, 마우스 등이 있습니다.&lt;/p&gt;

&lt;p&gt;컴퓨터로 데이터를 처리하기 위해서는 입력장치를 통해 컴퓨터로 데이터를 입력해야 하며, 컴퓨터가 처리한 결과의 데이터는 출력장치를 통해 사용자가 읽을 수 있는 형태로 돌려주어야 합니다.&lt;/p&gt;

&lt;p&gt;입력장치는 컴퓨터가 인식할 수 있는 형태로 변환시켜 메모리로 읽어 들이는 장치이고, 출력장치는 컴퓨터에서 처리된 내용을 사용자가 인식할 수 있는 형태로 바꾸어 표시하는 장치입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">중앙처리장치(CPU)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Oh My Zsh</title>
      <link href="https://huimang2.github.io/etc/oh-my-zsh" rel="alternate" type="text/html" title="Oh My Zsh" />
      <published>2023-01-07T18:00:00+09:00</published>
      <updated>2023-01-07T18:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/oh-my-zsh</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/oh-my-zsh">&lt;p&gt;이번 글에서는 우분투에 zsh Configuration 프레임워크인 Oh My Zsh를 설치해보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;커널kenel과-쉘shell&quot;&gt;커널(Kenel)과 쉘(Shell)&lt;/h1&gt;

&lt;p&gt;oh my zsh를 설치하기 전에 커널(Kernel)과 쉘(Shell)이 무엇인지 알 필요가 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/zsh/img001.png&quot; alt=&quot;img001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터는 크게 물리적인 형태를 가지고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하드웨어(HardWare)&lt;/code&gt;와 형태는 없지만 하드웨어를 동작시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소프트웨어(Software)&lt;/code&gt;로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;소프트웨어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제(Operating System, OS)&lt;/code&gt;와 운영체제 위에서 동작하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;응용 소프웨어(Application Software)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;운영체제는 하드웨어를 효율적으로 사용하기 위해 메모리나 CPU의 자원을 관리하고 여러 프로그램이 필요로 하는 공통적인 서비스를 제공하는 소프트웨어입니다. 리눅스(Linux), 윈도우(Windows), 맥OS(Mac OS)등이 운영체제에 해당합니다.&lt;/p&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kenel)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 소프트웨어(System Software)&lt;/code&gt;로 구분됩니다.&lt;/p&gt;

&lt;p&gt;커널은 운영체제의 핵심부로써, 하드웨어의 자원을 관리하는 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;커널의 경우 컴퓨터 자원만을 바라보고 있기 때문에 사용자 또는 응용 소프트웨어와 상호작용 않습니다. 그러므로 커널과 상호작용하기 위한 인터페이스가 필요한데, 이때 사용하는 시스템 소프트웨어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/zsh/img002.png&quot; alt=&quot;img002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 운영체제에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령 프롬프트(Command Prompt)&lt;/code&gt;가 쉘에 해당합니다.&lt;/p&gt;

&lt;h1 id=&quot;zsh와-oh-my-zsh&quot;&gt;zsh와 Oh My Zsh&lt;/h1&gt;

&lt;p&gt;리눅스는 표준 쉘로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bash&lt;/code&gt;를 사용합니다. BASH는 &lt;code class=&quot;language-plaintext bgcolor orange highlighter-rouge&quot; style=&quot;color:orangered&quot;&gt;Bourne-again shell&lt;/code&gt;의 약자로, 유닉스의 오리지날 쉘인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sh(Bourne Shell)&lt;/code&gt;을 기반으로 만들어졌습니다. 대표적인 리눅스 기반 GNU 운영체제인 우분투(Ubuntu) 역시 bash를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh&lt;/code&gt;는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 확장형 sh입니다. Mac OS 10.15 버전인 카탈리나부터는 기본 쉘로 zsh를 사용합니다.&lt;/p&gt;

&lt;p&gt;zsh는 커스텀이 비교적 자유로우며, 각종 테마나 플러그인의 추가/삭제가 가능합니다. 또한 경로를 자동으로 추론하거나 타이핑 교정, 명령어 추천 등 많은 기능을 포함합니다.&lt;/p&gt;

&lt;h6 id=&quot;경로-자동추론&quot;&gt;경로 자동추론&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img003.gif&quot; alt=&quot;img003&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/h/u/ws&lt;/code&gt;를 입력후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TAB&lt;/code&gt;키를 누르면 가장 비슷한 경로를 추론하여 자동완성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;타이핑-교정&quot;&gt;타이핑 교정&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img004.gif&quot; alt=&quot;img004&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;commit를 cmmit로 잘못입력했다면 이를 교정하여 commit를 입력할 것을 추천합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;명령어-추천&quot;&gt;명령어 추천&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img005.gif&quot; alt=&quot;img005&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git c&lt;/code&gt;를 입력후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TAB&lt;/code&gt;키를 누르면 c로 시작하는 명령어 옵션을 추천해줍니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Oh My Zsh&lt;/code&gt;는 zsh의 이러한 환경설정을 다루기위한 프레임워크입니다. 프레임워크 없는 zsh는 빈 껍데기에 불과하다고 보면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ohmyz.sh/&quot; target=&quot;_blank&quot;&gt;공식 홈페이지&lt;/a&gt;에 적힌 설명에 따르면 oh-my-zsh를 사용하면 카페에서 낮선 사람들이 다가와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;대단해! 너 천재야?&quot;&lt;/code&gt;라고 묻는다고 합니다 :)&lt;/p&gt;

&lt;p&gt;본격적으로 맥의 감성을 우분투에 반영해보겟습니다.&lt;/p&gt;

&lt;h1 id=&quot;oh-my-zsh-설치&quot;&gt;Oh My Zsh 설치&lt;/h1&gt;

&lt;h2 id=&quot;zsh-설치&quot;&gt;zsh 설치&lt;/h2&gt;

&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh&lt;/code&gt;를 설치해야합니다. apt를 통해 zsh를 설치해주도록 합시다.&lt;/p&gt;

&lt;h6 id=&quot;zsh-설치-1&quot;&gt;zsh 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img006.png&quot; alt=&quot;img006&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;oh-my-zsh-설치-1&quot;&gt;oh my zsh 설치&lt;/h2&gt;

&lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oh-my-zsh&lt;/code&gt;를 설치해주도록 합시다. curl이나 wget을 통해 sh 스크립트 파일을 다운받고 실행시키면 됩니다.&lt;/p&gt;

&lt;h6 id=&quot;curl을-통한-설치&quot;&gt;curl을 통한 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;wget을-통한-설치&quot;&gt;wget을 통한 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; -&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료되면 zsh를 기본 쉘로 변경할 것인지 묻는데, y를 입력하면 터미널이 실행될 때 기본쉘로 zsh를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img007.png&quot; alt=&quot;img007&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;테마-설정&quot;&gt;테마 설정&lt;/h2&gt;

&lt;p&gt;이제 테마를 설정하겠습니다. 테마는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.zshrc&lt;/code&gt; 파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSH_THEME&lt;/code&gt;를 설정하여 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 해당 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;nano ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ZSH_THEME가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;robbyrussell&lt;/code&gt;로 입력되어 있습니다. 이 부분에 사용하고 싶은 테마를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;저는 국룰(?)인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;agnoster&lt;/code&gt; 테마를 사용하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img008.png&quot; alt=&quot;img008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + O&lt;/code&gt;를 눌러 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + X&lt;/code&gt;를 눌러 nano 에디터를 빠져나옵니다.&lt;/p&gt;

&lt;p&gt;설정된 테마를 적용하기 위해 .zshrc를 소싱합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img009.png&quot; alt=&quot;img009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 테마를 사용할 경우 폰트가 깨지는 문제가 발생할 수 있으므로, 이를 해결하기 위해 powerline 폰트를 설치합니다.&lt;/p&gt;

&lt;h6 id=&quot;powerline-폰트-설치&quot;&gt;powerline 폰트 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;fonts-powerline
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img010.png&quot; alt=&quot;img010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다른 테마는 아래 페이지에서 확인이 가능합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&quot; target=&quot;_blank&quot;&gt;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;플러그인-설치&quot;&gt;플러그인 설치&lt;/h1&gt;

&lt;h2 id=&quot;syntax-hightlight&quot;&gt;syntax hightlight&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax hightlight&lt;/code&gt;는 말그대로 구문을 강조하는 플러그인 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GITHUB: &lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot; target=&quot;_blank&quot;&gt;https://github.com/zsh-users/zsh-syntax-highlighting&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bash의 경우 명령어와 옵션을 구분하지 않고 모두 흰색으로 입력됩니다.&lt;/p&gt;

&lt;h6 id=&quot;bash의-경우&quot;&gt;bash의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img017.png&quot; alt=&quot;img017&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zsh에 해당 플러그인을 설치한다면 구문이 강조되어 사용할 수 있는 명령어는 녹색으로, 사용할 수 없는 명령어는 빨간색으로, 옵션은 흰색으로 입력됩니다.&lt;/p&gt;

&lt;h6 id=&quot;사용할-수-있는-명령어의-경우&quot;&gt;사용할 수 있는 명령어의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img018.png&quot; alt=&quot;img018&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;사용할-수-없는-명령어의-경우&quot;&gt;사용할 수 없는 명령어의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img019.png&quot; alt=&quot;img019&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;oh-my-zsh에서 플러그인을 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.oh-my-zsh/custom/plugins&lt;/code&gt; 폴더에 플러그인을 다운받고 .zshrc 파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins&lt;/code&gt;를 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;우선 git를 통해 플러그인을 다운로드 받겠습니다. (git가 설치되어 있음을 전제로 합니다.)&lt;/p&gt;

&lt;h6 id=&quot;syntax-hightlight-플러그인-다운로드&quot;&gt;syntax hightlight 플러그인 다운로드&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/zsh-users/zsh-syntax-hightlighting.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img011.png&quot; alt=&quot;img011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집-1&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;nano ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처음에 plgins에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(git)&lt;/code&gt;가 설정되어 있습니다. 여기에 구분자를 스페이스로 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh-syntax-hightlight&lt;/code&gt;를 추가해주도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img012.png&quot; alt=&quot;img012&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + O&lt;/code&gt;를 눌러 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + X&lt;/code&gt;를 눌러 nano 에디터를 빠져나옵니다.&lt;/p&gt;

&lt;p&gt;.zshrc를 소싱하면 플러그인이 바로 적용됩니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱-1&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img013.png&quot; alt=&quot;img013&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;autosuggestions&quot;&gt;autosuggestions&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autosuggestions&lt;/code&gt;는 히스토리 기반으로 최근에 입력한 명령어를 미리보기 형태로 보여주는 플러그인 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GITHUB: &lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions&quot; target=&quot;_blank&quot;&gt;https://github.com/zsh-users/zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;autosuggestions-플러그인-적용&quot;&gt;autosuggestions 플러그인 적용&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img016.png&quot; alt=&quot;img016&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플러그인을 적용하기 위해서는 syntax highlighte 플러그인을 적용한 방식 그대로 설정하면 됩니다.&lt;/p&gt;

&lt;h6 id=&quot;autosuggestions-플러그인-다운로드&quot;&gt;autosuggestions 플러그인 다운로드&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/zsh-users/zsh-autosuggestions.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img014.png&quot; alt=&quot;img014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집-2&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img015.png&quot; alt=&quot;img015&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;.zshrc를 소싱하면 플러그인이 바로 적용됩니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱-2&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img016.png&quot; alt=&quot;img016&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">이번 글에서는 우분투에 zsh Configuration 프레임워크인 Oh My Zsh를 설치해보도록 하겠습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">향상된 SSH 프로토콜 : Mosh</title>
      <link href="https://huimang2.github.io/etc/mosh" rel="alternate" type="text/html" title="향상된 SSH 프로토콜 : Mosh" />
      <published>2022-09-03T05:00:00+09:00</published>
      <updated>2022-09-03T05:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/mosh</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/mosh">&lt;h1 id=&quot;mosh란&quot;&gt;Mosh란?&lt;/h1&gt;

&lt;p&gt;Mosh는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mobile Shell&lt;/code&gt;의 약자로, 모바일 환경에서 원격 터미널을 원활하게 사용할 수 있도록 해주는 프로토콜입니다. 기존 SSH의 상위 호환 프로토콜이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;SSH의 경우 TCP 프로토콜을 사용하기 때문에 세션으로 연결되어야만 통신이 가능합니다. 그렇기 때문에 모바일 환경과 같이 세션의 연결이 불안정한 네트워크의 경우 세션의 연결이 끊어지면 다시 세션을 연결하기 때문에 입출력의 지연이 발생하고, 시간내에 세션에 연결하지 못하면 기존에 구성해둔 작업환경을 다시 구성해야 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;반면에 Mosh는 UDP 프로토콜을 사용하여 세션의 연결상태를 지속할 필요가 없으며, 입출력을 따로 연결하고 세션의 상태를 보존하기때문에 명령에 대한 연결지연이 없습니다.&lt;/p&gt;

&lt;p&gt;하지만 UDP를 통해서 Mosh 서버에 직접적인 연결이 불가하여 SSH를 통해 간접적으로 접속해야 하며, 하나의 접속에 대하여 하나의 포트를 필요로 하기때문에 방화벽의 유지관리에 많은 비용이 들 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;mosh-설치&quot;&gt;Mosh 설치&lt;/h1&gt;

&lt;p&gt;Ubuntu 20.04 LTS 환경인 원격 서버에 Mosh를 설치하여 윈도우 환경에서 접속해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;우선 원격서버에 접속하고 apt를 업데이트 하세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;apt를 통해 mosh를 설치하세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mosh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mosh는 60000 ~ 61000번의 UDP 포트를 사용합니다. 우선 os 방화벽에서 해당포트를 열어주세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ufw allow 60000:61000/udp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원격서버에서도 포트를 열어야합니다. 이전에 작성한 &lt;a href=&quot;/etc/docker#방화벽-오픈open&quot; target=&quot;_blank&quot;&gt;도커(Docker) 설치하기&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;p&gt;윈도우에서 Mosh 프로토콜을 통해 통신하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cygwin&lt;/code&gt;을 설치하거나 크롬 브라우저에 extention을 설치하여 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;저는 크롬 브라우저에 &lt;a href=&quot;https://chrome.google.com/webstore/detail/mosh/ooiklbnjmhbcgemelgfhaeaocllobloj&quot; target=&quot;_blank&quot;&gt;extension&lt;/a&gt;을 설치하겠습니다.&lt;/p&gt;

&lt;p&gt;extionstion을 설치하면 Mosh app이 설치됩니다. 실행시키면 다음과 같은 화면이 뜹니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-01.png&quot; alt=&quot;img01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;os 유저이름과 ip주소, ssh 포트를 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Connect&lt;/code&gt;를 클릭하면 됩니다. 그전에 ssh key를 통해 접속하므로 비밀키를 입력해야합니다. 오른쪽에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add ssh key&lt;/code&gt;를 클릭하고, 비밀키를 메모장으로 열어서 키값을 복사하여 입력하세요.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-02.png&quot; alt=&quot;img02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Passphrase를 입력하라고 뜹니다.. 다음 명령어를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Passphrase&lt;/code&gt;를 설정합니다. 그냥 엔터를 입력하면 Passphrase 없이 비밀키만으로 접속가능합니다.&lt;/p&gt;

&lt;div data-lang=&quot;CMD&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;비밀키 경로] &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 비밀키를 복사하여 입력한후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Connect&lt;/code&gt;를 누르면 ssh를 통해 원격 서버에 접속되고 mosh 통신이 시작됩니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-03.png&quot; alt=&quot;img03&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">Mosh란?</summary>
      

      
      
    </entry>
  
</feed>
