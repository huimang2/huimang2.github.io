<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://huimang2.github.io/tag/etc/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://huimang2.github.io/" rel="alternate" type="text/html" />
  <updated>2023-07-24T05:49:01+09:00</updated>
  <id>https://huimang2.github.io/tag/etc/feed.xml</id>

  
  
  

  
    <title type="html">Rubisco’s Programming Note | </title>
  

  
    <subtitle>프로그래밍 노트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">자료구조</title>
      <link href="https://huimang2.github.io/etc/data-structure" rel="alternate" type="text/html" title="자료구조" />
      <published>2023-07-10T01:00:00+09:00</published>
      <updated>2023-07-10T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/data-structure</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/data-structure">&lt;h1 id=&quot;자료구조란&quot;&gt;자료구조란?&lt;/h1&gt;

&lt;p&gt;자료구조란 여러 데이터를 논리적인 규칙을 통해 나열하고 이를 효율적으로 처리하기 위한 사용법을 정의한 것입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 도서관에는 여러 책이 있습니다. 각각의 책을 이름 순서로 나열할 수도 있지만, 이렇게 된다면 원하는 책을 쉽게 찾는 것이 어렵게 됩니다. 이때 각각의 책들을 주제에 따라 유형을 나누어 분류한다면 조금 더 원하는 책을 쉽게 찾을 수 있습니다. 우리 나라에서는 한국 십진분류법에 따라 10가지 유형으로 나누어 책을 분류하는데, 이것이 자료구조에 해당합니다.&lt;/p&gt;

&lt;p&gt;정수형을 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 역시 자료구조 입니다. int는 4바이트의 메모리를 할당받으며, 첫 비트는 부호를 표현하고 나머지 공간은 2진수의 정수를 표현합니다. 또한 덧셈, 뺄셈, 나눗셈, 곱셈 등 여러 연산을 정의하고 있습니다.&lt;/p&gt;

&lt;p&gt;자료구조는 알고리즘과 밀접한 관련이 있습니다. 알고리즘은 문제 해결을 위한 일련의 절차를 정의한 것입니다. 예를 들어 도서관에서 책을 분류하는 것이 자료구조라면, 원하는 책을 찾는 방법이 알고리즘에 해당합니다.&lt;/p&gt;

&lt;p&gt;보통 알고리즘은 자료구조에 의존적이기 때문에 자료구조가 정의된다면 적용할 알고리즘은 명확해집니다. 책의 일련번호가 한국 십진분류법에 따른 자료구조를 가진다면 자연과학에 관련된 책을 찾기 위해서는 400번대의 일련번호를 가진 책을 찾는 알고리즘을 적용하면 됩니다. 이렇듯 효율적인 문제해결을 위해서는 자료구조가 우선 정의되는 것이 중요합니다.&lt;/p&gt;

&lt;h1 id=&quot;자료구조의-종류&quot;&gt;자료구조의 종류&lt;/h1&gt;

&lt;p&gt;자료구조는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단순 자료구조(Primitive Data Structure)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복합 자료구조(Non-Primitive Data Structure)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;단순 자료구조는 int, float, character 등 프로그래밍 언어에서 통상적으로 제공되는 기본 데이터 형식입니다.&lt;/p&gt;

&lt;p&gt;복합 자료구조는 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선형 자료구조(Linear Data Structure)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비선형 자료구조(Non-Linear Data Structure)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;선형 자료구조에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배열(Array)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리스트(List)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스택(Stack)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;큐(Queue)&lt;/code&gt; 등이 있으며, 비선형 자료구조에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래프(Graph)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리(Tree)&lt;/code&gt; 등이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img147.png&quot; alt=&quot;img147&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;배열array&quot;&gt;배열(Array)&lt;/h2&gt;

&lt;p&gt;배열은 동일한 타입의 데이터들을 저장하고 고정된 크기를 가지며, 메모리의 물리적인 순서를 통해 인덱스가 부여됩니다. 배열에 저장된 데이터는 인덱스를 통해 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img148.png&quot; alt=&quot;img148&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배열은 다른 데이터 구조를 구축하기 위한 블록으로 사용되며, 정렬에 용이하지만 구조를 재구성하는데 어려움이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;연결-리스트linked-list&quot;&gt;연결 리스트(Linked List)&lt;/h2&gt;

&lt;p&gt;연결 리스트는 인덱스가 아닌 참조를 통해 순차적으로 연결되는 구조입니다. 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;노드(Node)&lt;/code&gt;라는 단위요소에 저장되며, 각 노드는 데이터를 참조하는 key와 다음 노드를 참조하는 next로 구성되어 있습니다. 또한 첫 번째 요소를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt;, 마지막 요소를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt;이 포함됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img149.png&quot; alt=&quot;img149&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리스트는 데이터의 추가 및 삭제시 구조를 재구성할 필요가 없이 참조만 변경하면 되기 때문에 동적인 메모리 할당에 효율적입니다. 하지만 배열보다 메모리를 더 많이 사용하며, 데이터를 찾기위해 head부터 tail까지 순회하기 때문에 검색에는 비효율적입니다.&lt;/p&gt;

&lt;h2 id=&quot;스택stack&quot;&gt;스택(Stack)&lt;/h2&gt;

&lt;p&gt;스택은 배열이나 리스트로 구성되어 순서가 보존되는 선형 데이터 구조이며, 마지막에 입력된 데이터부터 처리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후입선출(Last In First Out, LIFO)&lt;/code&gt; 메커니즘을 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img150.png&quot; alt=&quot;img150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택은 수학적 표현식을 분석하거나 재귀함수의 호출을 구현하는데 효율적인 구조입니다.&lt;/p&gt;

&lt;h2 id=&quot;큐queue&quot;&gt;큐(Queue)&lt;/h2&gt;

&lt;p&gt;큐는 스택과 비슷하지만 먼저 입력된 데이터부터 처리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선입선출(First In First Out, FIFO)&lt;/code&gt; 메커니즘을 가집니다. 또한 첫 번째 요소를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;back&lt;/code&gt;과, 마지막 요소를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front&lt;/code&gt;가 포함됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img151.png&quot; alt=&quot;img151&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐는 앞서 설명했던 CPU 스케줄링이나 캐시(Cache)를 구현하기에 효율적인 구조입니다.&lt;/p&gt;

&lt;h2 id=&quot;그래프graph&quot;&gt;그래프(Graph)&lt;/h2&gt;

&lt;p&gt;그래프는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;노드(node)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간선(edge)&lt;/code&gt;으로 이루어진 집합(collection) 입니다. 각각의 노드는 간선으로 연결되며, 간선은 방향을 가지거나 방향을 가지지 않을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img152.png&quot; alt=&quot;img152&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래프는 네트워크나 검색엔진 알고리즘 등 다양한 알고리즘에 응용이 가능한 구조입니다.&lt;/p&gt;

&lt;h2 id=&quot;트리tree&quot;&gt;트리(Tree)&lt;/h2&gt;

&lt;p&gt;트리는 일종의 그래프이며, 노드가 계층적인 구조를 가집니다. 최상위 노드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;루트 노드(root node)&lt;/code&gt;이며, 상위 노드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부모 노드(parent node)&lt;/code&gt;와 하위 노드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식 노드(child node)&lt;/code&gt;로 구성됩니다. 같은 부모 노드를 가지는 자식 노드의 집합은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형제 노드(siblings node)&lt;/code&gt;가 되며, 자식이 없는 노드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단말 노드(leaf node)&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img153.png&quot; alt=&quot;img153&quot; /&gt;&lt;/p&gt;

&lt;p&gt;트리는 탐색 알고리즘이나 머신러닝 알고리즘에 많이 사용되는 구조입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">자료구조란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">교착상태</title>
      <link href="https://huimang2.github.io/etc/computer-deadlock" rel="alternate" type="text/html" title="교착상태" />
      <published>2023-07-03T01:00:00+09:00</published>
      <updated>2023-07-03T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-deadlock</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-deadlock">&lt;h1 id=&quot;교착상태deadlack란&quot;&gt;교착상태(Deadlack)란?&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교착상태(Deadlock)&lt;/code&gt;란 멀티프로세스나 멀티스레드 환경에서 발생할 수 있는 상황으로, 각 프로세스 또는 스레드가 서로가 가지고 있는 자원을 점유한 채로 다른 프로세스 또는 스레드가 필요로 하는 자원을 기다리는 상태를 말합니다. 이러한 상태에서는 모든 프로세스 또는 스레드가 무한히 기다리는 현상이 발생하며, 작업이 진행되지 않고 시스템이 정체되는 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;식사하는 철학자들 문제는 교착상태를 설명하는 대표적인 예시입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img140.png&quot; alt=&quot;img140&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다섯 명의 철학자가 하나의 원탁에 앉아 식사를 한다. 각각의 철학자들 사이에는 포크가 하나씩 있고, 앞에는 접시가 있다. 접시 안에 든 요리는 스파게티 같은 면 요리이기 때문에 식사를 하기 위해서는 동시에 두 개의 포크가 필요하다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다. 따라서 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하고 있어야만 한다. 또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다. 이 때, 어떤 철학자도 굶지 않고 식사할 수 있도록 하는 방법은 무엇인가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;철학자들이 다음의 과정을 통해 식사를 한다고 가정해 봅시다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;① 일정 시간 생각을 한다.&lt;br /&gt;
② 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.&lt;br /&gt;
③ 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.&lt;br /&gt;
④ 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.&lt;br /&gt;
⑤ 오른쪽 포크를 내려놓는다.&lt;br /&gt;
⑥ 왼쪽 포크를 내려놓는다.&lt;br /&gt;
⑦ 다시 1번으로 돌아간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 경우 모든 철학자가 왼쪽 포크를 들고 오른쪽 포크를 기다린다면 어떠한 경우에서도 식사를 할 수 없는 상태가 되는데, 이것이 교착상태 입니다.&lt;/p&gt;

&lt;h1 id=&quot;자원-할당-그래프&quot;&gt;자원 할당 그래프&lt;/h1&gt;

&lt;p&gt;교착상태를 파악하기 위해서는 자원 할당 그래프를 그려서 어떤 프로세스가 어떤 자원을 할당받아 사용 중인지 확인할 수 있습니다. 자원할당 그래프는 프로세스를 원으로, 자원을 사각형으로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img141.png&quot; alt=&quot;img141&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img142.png&quot; alt=&quot;img142&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스가 자원을 할당받았다면 자원에서 프로세스로 화살표를 그려 표시합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img143.png&quot; alt=&quot;img143&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스가 자원을 할당받기 위해 기다린다면 프로세스에서 자원으로 화살표를 그려 표시합니다. 아래 그림은 프로세스4가 자원2를 할당받기 위해 대기상태인 경우입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img144.png&quot; alt=&quot;img144&quot; /&gt;&lt;/p&gt;

&lt;p&gt;식사하는 철학자 문제를 자원할당 그래프로 나타내면 다음과 같이 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img145.png&quot; alt=&quot;img145&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;교착상태-발생-조건&quot;&gt;교착상태 발생 조건&lt;/h1&gt;

&lt;p&gt;교착상태가 발생하기 위해서는 다음의 네 가지 조건이 동시에 충족되어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;1. 상호 배제(Mutual Exclusion)&lt;/font&gt;:&lt;/strong&gt; 자원은 한 번에 하나의 프로세스 또는 스레드만이 사용할 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;2. 점유와 대기(Hold and Wait)&lt;/font&gt;:&lt;/strong&gt; 프로세스 또는 스레드가 이미 자원을 할당받았는데 추가적인 자원을 기다리는 상태여야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;3. 비선점(No Preemption)&lt;/font&gt;:&lt;/strong&gt; 다른 프로세스 또는 스레드가 점유하고 있는 자원을 강제로 빼앗을 수 없어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;4. 원형 대기(Circular Wait)&lt;/font&gt;:&lt;/strong&gt; 프로세스 또는 스레드 간에 자원을 기다리는 원형 형태의 사슬이 형성되어야 합니다.&lt;/p&gt;

&lt;p&gt;식사하는 철학자 문제에서 포크는 한 번에 한 철학자만 사용할 수 있으며, 각 철학자는 왼쪽 포크를 점유하면서 오른쪽 포크를 기다리고 있습니다. 또한 포크를 강제로 뺏을 수 없으며, 자원 할당 그래프에서 본 것과 같이 원형 형태로 자원을 대기하고 있으므로 교착 상태에 있다고 볼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;교착상태-해결법&quot;&gt;교착상태 해결법&lt;/h1&gt;

&lt;h2 id=&quot;교착상태-예방deadlock-prevention&quot;&gt;교착상태 예방(Deadlock Prevention)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교착상태 예방(Deadlock Prevention)&lt;/code&gt;은 교착상태가 발생되지 않도록 사전에 예방하는 방법입니다. 교착상태가 발생하는 조건 중 적어도 하나가 성립하지 않게 만들면 교착상태를 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;상호 배제 조건을 없애기 위해는 여러 프로세스가 공유자원을 사용할 수 있도록 하면 되지만, 동기화 문제가 발생할 수 있습니다. 또한 식사하는 철학자 문제의 경우와 같이 하나의 포크를 여러 철학자가 동시에 사용하는 것은 현실적으로 불가능 합니다.&lt;/p&gt;

&lt;p&gt;점유와 대기 조건을 없애기 위해서는 프로세스 실행에 필요한 모든 자원을 한꺼번에 할당받거나 할당받지 않으면 됩니다. 예를 들어 식사하는 철학자 문제에서 오른쪽 포크와 왼쪽 포크를 한꺼번에 점유하도록 한다면 식사를 할 수 있습니다. 그러나 이것은 자원의 활용률을 낮출 수 있다는 단점이 있습니다. 어떤 철학자는 배가 많이 고파서 식사를 빨리 할 필요가 있지만 포크를 가지지 못하여 식사를 못할 수도 있고, 어떤 철학자는 오른손잡이라서 왼쪽 포크의 활용이 낮아 왼쪽 포크의 사용률이 낮아질 수 있습니다.&lt;/p&gt;

&lt;p&gt;비선점 조건을 없애는 방법은 선점이 가능한 자원에 한해서는 효과적일지는 몰라도 모든 자원이 선점 가능한 것이 아니라는 단점이 있습니다. 한 철학자가 포크를 가지고 있으면 다른 철학자는 해당 포크를 점유할 수 없습니다.&lt;/p&gt;

&lt;p&gt;원형 대기 조건을 없애기 위해서는 자원에 순서를 부여하고, 각 프로세스가 오름차순으로만 자원을 요청할 수 있도록 하면 됩니다. 예를 들어 아래 자원 할당 그래프와 같이 철학자1이 처음에 순서가 높은 포크5를 점유하지 못하게 하면 &lt;code class=&quot;language-plaintext bgcolor orange highlighter-rouge&quot; style=&quot;color:orangered&quot;&gt;철학자5 → 철학자4 → 철학자3 → 철학자2 → 철학자1&lt;/code&gt; 순서로 식사를 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img146.png&quot; alt=&quot;img146&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;교착상태-회피deadlock-avoidance&quot;&gt;교착상태 회피(Deadlock Avoidance)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교착상태 회피(Deadlock Avoidance)&lt;/code&gt;는 교착상태를 무분별한 자원 할당으로 인해 발생했다고 간주하며 교착상태가 발생하는 조건인지 확인하면서 적절히 회피하는 방법입니다.&lt;/p&gt;

&lt;p&gt;이 방법은 원형 대기가 발생하지 않도록 자원 할당 상태를 검사하면서 시스템이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전 상태&lt;/code&gt;인지 확인합니다. 안전 상태는 교착상태가 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태를 말합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 자원이 12개이고 프로세스 P1, P2, P3가 각각 5개, 2개, 2개의 자원을 할당받았고, 각각 최대 10개, 4개, 9개의 자원을 요구한다고 가정합시다. 이 상태에서 운영체제가 할당할 수 있는 자원은 3개가 남습니다.&lt;/p&gt;

&lt;p&gt;이때 P2에 2개의 자원을 할당하면 P2가 종료되고 자원을 반환하여 남은 자원은 5개가 됩니다(3 - 2 + 4 = 5). 그 후 P1에 5개의 자원을 할당하면 P1이 종료되고 자원을 반환하여 남은 자원은 10개가 되며(5 - 5 + 10 = 10), 마지막으로 P3에 7개의 자원을 할당하면 모든 프로세스가 자원을 할당받고 종료될 수 있습니다.&lt;/p&gt;

&lt;p&gt;P2 → P1 → P3 순서로 프로세스에게 자원을 할당하면 안전 상태가 되는데, 이 순서를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전 순서열&lt;/code&gt;이라고 합니다. 즉, 교착상태 회피는 안전 상태를 유지하도록 안전 순서열인지 검사하면서 자원을 할당합니다. 안전 순서열을 찾아내는 대표적인 알고리즘으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;은행원 알고리즘(Banker's Algorithm)&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-탐지-및-회복deadlock-detection--recovery&quot;&gt;교착상태 탐지 및 회복(Deadlock Detection &amp;amp; Recovery)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교착상태 탐지 및 회복(Deadlock Detection &amp;amp; Recovery)&lt;/code&gt;은 교착상태의 발생을 인정하고 사후에 조치하는 방법입니다. 프로세스가 자원을 요구하면 우선 할당하며, 교착상태가 탐지되면 이를 회복하는 알고리즘을 사용합니다.&lt;/p&gt;

&lt;p&gt;교착상태를 회복하는 방식에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선점을 통한 회복&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스의 강제 종료를 통한 회복&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;선점을 통한 회복은 교착상태가 회복될 때까지 한 프로세스에게 자원을 몰아줍니다.&lt;/p&gt;

&lt;p&gt;프로세스의 강제 종료를 통한 회복은 교착상태에 있는 모든 프로세스를 강제 종료하거나 교착상태가 해결될 때까지 한 프로세스씩 강제로 종료합니다. 전자의 경우 작업 내역을 한번에 잃어버릴 수 있는 위험이 있으며, 후자의 경우 오버헤드가 발생할 위험이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-무시deadlock-ignorance&quot;&gt;교착상태 무시((Deadlock Ignorance)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교착상태 무시((Deadlock Ignorance)&lt;/code&gt;는 교착상태를 무시하고 특별한 조치를 취하지 않는 방법입니다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타조 알고리즘&lt;/code&gt;이라고 하며, 교착상태의 발생 확률이 낮은 상황에서 효율적인 방법입니다. 유닉스(UNIX), 윈도우(Windows) 등 대부분의 운영체제는 이 방법을 사용합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">교착상태(Deadlack)란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스 동기화</title>
      <link href="https://huimang2.github.io/etc/computer-synchronization" rel="alternate" type="text/html" title="프로세스 동기화" />
      <published>2023-06-25T01:00:00+09:00</published>
      <updated>2023-06-25T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-synchronization</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-synchronization">&lt;h1 id=&quot;프로세스-동기화synchronization란&quot;&gt;프로세스 동기화(Synchronization)란?&lt;/h1&gt;

&lt;p&gt;프로세스 동기화란 프로세스의 실행 순서를 제어하고 동시에 접근할 수 없는 자원에 하나의 프로세스만 접근하게 하여 데이터의 일관성을 유지하는 과정을 말합니다.&lt;/p&gt;

&lt;p&gt;프로세스는 동시에 실행되면서 서로 영향을 주고 받는데, 이 과정에서 자원의 일관성이 보장되어야 합니다. 일관성이란 자원의 상태가 동일함을 의미합니다. 예를 들어 1번지에 저장되어 있는 데이터와 2번지에 저장되어 있는 데이터를 더한다고 할 때, 1번지와 2번지에 저장되어 있는 데이터는 연산이 종료될 때까지 값이 변하면 안됩니다.&lt;/p&gt;

&lt;p&gt;여러 프로세스들이 동시에 자원에 접근하는 상황에서는 명려어 실행 순서에 따라 결과값이 달라질 수 있는데, 이 상황을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경쟁 상태(Race Condition)&lt;/code&gt;라고 합니다. 경쟁 상태가 발생하면 자원의 일관성이 깨질 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생산자-소비자 문제(Producer Consumer Problem)&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;생산자-소비자-문제producer-consumer-problem&quot;&gt;생산자-소비자 문제(Producer Consumer Problem)&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sum: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자원을 공유하기 위해 프로세스 대신에 스레드를 생성했습니다. 스레드는 차후 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;producer 스레드는 10만번 더하고, consumer 스레드는 10만번 뺍니다. sum의 결과는 0이 예상되지만 동기화가 되지 않았기 때문에 일관성이 깨져 0이 출력되지 않는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;출력-결과&quot;&gt;출력 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img132.png&quot; alt=&quot;img132&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 스레드는 한줄의 코드 일지라도 sum의 값을 읽어 MBR에 저장하고 ALU에서 연산 후 sum에 연산값을 저장하는 등 여러 명령어로 구성되어 있습니다. producer가 공유 자원인 sum에 연산값을 저장하기도 전에 문맥 교환이 발생하여 consumer가 실행된다면 데이터의 일관성은 깨져버립니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;은행계좌 문제(Bank Account Problem)&lt;/code&gt;에서 명확히 확인할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;은행계좌-문제bank-account-problem&quot;&gt;은행계좌 문제(Bank Account Problem)&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로세스A&lt;/th&gt;
      &lt;th&gt;프로세스B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;잔액&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;잔액 읽기&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10만원 더하기&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;font color=&quot;orangered&quot;&gt;문맥교환&lt;/font&gt;&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;잔액 읽기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;20만원 더하기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;font color=&quot;orangered&quot;&gt;문맥교환&lt;/font&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;잔액 저장&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;110만원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;잔액 저장&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;font color=&quot;orangered&quot;&gt;120만원&lt;/font&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;프로세스A는 10만원을 더하고 프로세스B는 20만원을 더하므로 최종 잔액은 130만원이 되어야 하지만, 프로세스A에서 10만원을 더한 값을 저장하기도 전에 프로세스B가 실행되어 잔액의 일관성이 깨져버렸습니다.&lt;/p&gt;

&lt;h1 id=&quot;임계-구역critical-section&quot;&gt;임계 구역(Critical Section)&lt;/h1&gt;

&lt;p&gt;이처럼 공유 자원에 접근하는 코드 중 동시에 실행되면 문제가 발생하는 코드 영역을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;임계 구역(Critical Section)&lt;/code&gt;이라고 합니다. 프로세스가 임계구역에 동시에 접근하면 경쟁 상태가 되어 자원의 일관성은 깨져버립니다.&lt;/p&gt;

&lt;p&gt;임계 구역 문제를 해결하기 위해 운영체제는 다음과 같은 조건을 만족해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;상호 배제(Mutual Exclusion)&lt;/code&gt;: 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;유한 대기(Bounded Waiting)&lt;/code&gt;: 어떠한 프로세스도 무한 대기해서는 안됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;진행의 융통성(Progress)&lt;/code&gt;: 임계 구역에 어떠한 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스의 진행을 방해해서는 안됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;동기화-방법&quot;&gt;동기화 방법&lt;/h1&gt;

&lt;h2 id=&quot;뮤텍스-락mutex-lock&quot;&gt;뮤텍스 락(Mutex Lock)&lt;/h2&gt;

&lt;p&gt;뮤텍스 락은 상호 배제를 위한 동기화 메커니즘 입니다. 공유 자원인 lock이 하나 존재하며, acquire 함수를 통해 임계구역을 잠그고 release 함수를 통해 임계 구역의 잠금을 해제할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;뮤텍스-락&quot;&gt;뮤텍스 락&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로세스가 임계 구역에 진입하기 전에 acquire 함수가 호출합니다. 임계 구역이 잠겨 있다면(lock = true) 임계 구역이 열릴 때까지 임계 구역을 반복적으로 확인하는데, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바쁜 대기(busy waiting)&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;임계 구역이 열려 있다면 임계 구역을 잠근 후(lock = true) 임계 구역에 진입하고, 임계 구역의 작업이 끝난다면 release 함수를 호출하여 임계 구역의 잠금을 해제하고(lock = false) 임계 구역을 빠져나오게 합니다.&lt;/p&gt;

&lt;h6 id=&quot;뮤텍스-락-예제&quot;&gt;뮤텍스 락 예제&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 잠금&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 열림&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 잠금&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 열림&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sum: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;출력-결과-1&quot;&gt;출력 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img133.png&quot; alt=&quot;img133&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뮤텍스 락은 프로그래밍 언어에서 지원되는 경우가 많기 때문에 직접 구현할 일은 많지 않습니다.&lt;/p&gt;

&lt;h6 id=&quot;c언어-뮤텍스락-예제&quot;&gt;C언어 뮤텍스락 예제&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 잠금&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 열림&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 잠금&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 뮤텍스 락 열림&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer_tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sum: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;세마포어semaphore&quot;&gt;세마포어(Semaphore)&lt;/h2&gt;

&lt;p&gt;세마포어는 철도의 수신호를 의미하는 용어입니다. 철도의 수신호가 기차의 진행을 제어하듯이 세마포어도 프로세스의 임계구역 진입 여부를 제어합니다. 한번에 하나의 프로세스만 임계 구역에 들어갈 수 있는 뮤텍스 락과 달리 여러 프로세스가 임계구역에 들어가도록 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;세마포어는 임계 구역에 진입할 수 있는 프로세스의 개수를 나타내는 전역 변수 S와 임계 구역의 진입 가능 여부를 알려주는 wait 함수, 대기 상태인 프로세스에게 임계 구역에 진입 가능하다는 신호를 주는 signal 함수로 구현할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;세마포어&quot;&gt;세마포어&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로세스가 wait 함수를 호출할 때마다 임계구역에 진입할 수 있는 프로세스의 수인 S를 확인하고, S가 0이라면 S가 증가할 때까지 반복해서 확인합니다. S가 0보다 크다면 S를 1 감소시키고 임계구역에 진입합니다. 임계구역의 코드가 실행된 후 signal 함수를 호출하여 S를 1 증가시켜 줍니다.&lt;/p&gt;

&lt;p&gt;wait 함수를 보면 뮤텍스 락과 같이 바쁜 대기 상태인데, 이는 CPU 성능을 저하시키는 요인이 될 수 있습니다. 이를 해결하기 위해서 wait 함수에서 임계 구역에 진입하지 못하면 프로세스를 대기 상태로 만들고, signal 함수가 호출될 때 대기 상태에 있는 프로세스를 준비 상태로 만들어주면 됩니다. 대기 상태에 있는 프로세스는 CPU 자원을 사용하지 않기 때문에 작업 사이클의 낭비를 막을 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;바쁜-대기-상태-해결&quot;&gt;바쁜 대기 상태 해결&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 현재 프로세스의 PCB를 대기 큐에 삽입&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 현재 프로세스를 대기 상태로 전환&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대기 큐에 있는 p 프로세스의 PCB 제거&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// p 프로세스를 준비 상태로 전환&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 임계 구역&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세마포어 역시 뮤텍스 락과 마찬가지로 프로그래밍 언어에서 지원되는 경우가 많기 때문에 직접 구현할 일은 많지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;모니터monitor&quot;&gt;모니터(Monitor)&lt;/h2&gt;

&lt;p&gt;세마포어는 임계구역 앞뒤로 wait와 signal 함수를 직접 호출해야 하므로 사용자가 사용하기에 조금 불편한 점이 있습니다. 가령 프로그램 규모가 커지면 실수로 함수를 호출하지 않거나 잘못된 순서로 함수를 호출하여 예기치 않은 결과가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;모니터는 공유자원과 인터페이스를 하나로 묶어 관리함으로써 이러한 불편함을 해소한 동기화 도구 입니다. 뮤텍스 락이나 세마포어가 저수준 레벨의 언어에서 사용하기 적합한 도구라면 모니터는 고수준 레벨의 언어를 위한 도구입니다. 모니터를 사용하는 대표적인 언어는 자바가 있습니다.&lt;/p&gt;

&lt;p&gt;공유자원에 접근하고자 하는 프로세스는 특정 인터페이스를 위한 큐에 쌓이며, 하나의 인터페이스를 통해서만 공유자원에 접근할 수 있게 함으로써 상호배제 동기화가 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img134.png&quot; alt=&quot;img134&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 순서를 제어하기 위해서는 모니터 내부의 조건 변수를 사용합니다. 모니터 내부에는 조건 변수에 대한 큐가 존재하며, 공유자원과 인터페이스, 조건 변수를 캡슐화하여 추상화된 데이터 형(Abstract Data Type, ADT)을 형성합니다.&lt;/p&gt;

&lt;p&gt;모니터는 wait 함수를 통해 프로세스를 대기 상태로 전환하여 조건 변수 큐에 삽입합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img135.png&quot; alt=&quot;img135&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조건 변수에서 대기 상태인 프로세스는 signal 함수를 통해 실행 상태로 전환되어 인터페이스를 통해 공유자원에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img136.png&quot; alt=&quot;img136&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바에서는 모든 객체가 모니터를 가지고 있습니다. 임계구역은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드를 통해 설정할 수 있으며, 모니터를 가지는 스레드는 해당 객체에 락을 걸어 다른 스레드가 해당 객체에 접근할 수 없게 됩니다.&lt;/p&gt;

&lt;p&gt;예제 코드를 작성해보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;bankaccountjava&quot;&gt;BankAccount.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;consumerjava&quot;&gt;Consumer.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;잔액: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;producerjava&quot;&gt;Producer.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;잔액: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;examplejava&quot;&gt;Example.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--------------&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;잔액: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bankAccount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;money&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행시켜보면 동기화가 되지 않아 최종 잔액이 0원이 아닙니다.&lt;/p&gt;

&lt;h6 id=&quot;실행-결과&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img137.png&quot; alt=&quot;img137&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 BankAccount에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syncronized&lt;/code&gt; 키워드를 통해 임계영역을 설정할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;bankaccountjava-1&quot;&gt;BankAccount.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과-1&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img138.png&quot; alt=&quot;img138&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최종 잔액이 0원이 되었지만 중간과정에 잔액이 마이너스가 됩니다. 이때 실행 순서를 제어하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify()&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;bankaccountjava-2&quot;&gt;BankAccount.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BankAccount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notifyAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withdraw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;money&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notifyAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과-2&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img139.png&quot; alt=&quot;img139&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">프로세스 동기화(Synchronization)란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CPU 스케줄링</title>
      <link href="https://huimang2.github.io/etc/computer-scheduling" rel="alternate" type="text/html" title="CPU 스케줄링" />
      <published>2023-06-24T01:00:00+09:00</published>
      <updated>2023-06-24T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-scheduling</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-scheduling">&lt;h1 id=&quot;cpu-스케줄링cpu-scheduling&quot;&gt;CPU 스케줄링(CPU Scheduling)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU 스케줄링(CPU Scheduling)&lt;/code&gt;이란 운영체제가 프로세스에 합리적으로 CPU 자원을 할당하는 정책을 만드는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;앞서 말했듯이 멀티태스킹을 위해서는 운영체제가 CPU의 가동시간을 적절히 나누어 프로세스에게 사용시간을 분배합니다. 이때 시스템과 사용자의 입장에서 CPU 성능에 대한 척도가 다를 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;1. 시스템 입장에서의 성능 척도&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU 사용률(CPU Utilization)&lt;/strong&gt;: 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;처리량(Throughput)&lt;/strong&gt;: CPU가 단위 시간당 처리하는 프로세스의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;2. 사용자 입장에서의 성능 척도&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;대기시간(Waiting Time)&lt;/strong&gt;: 프로세스가 준비 상태에서 CPU를 할당 받을 때까지 대기한 시간&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응답시간(Response Time)&lt;/strong&gt;: 프로세스의 명령 요청 후 응답이 올 때까지의 시간&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반환시간(Turnaround Time)&lt;/strong&gt;: 프로세스가 시작해서 끝날 때까지 걸리는 시간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시스템 입장에서는 CPU를 쉬지않고 최대한 많이 가동시키는 것이 중요하고, 사용자 입장에서는 요청한 작업이 빨리 처리되는 것이 중요하므로 운영체제는 상황에 맞게 CPU 스케줄링을 설계할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;CPU 스케줄링은 스케줄링 방식에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선점형&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비선점형&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선점(preemptive)&lt;/code&gt;이란 빼앗을 수 있음을 의미합니다. 즉, 선점형 스케줄링의 경우 운영체제가 필요하다고 판단하면 실행중인 프로세스를 중단하고 다른 프로세스에게 CPU 자원을 할당하여 실행시킬 수 있습니다. 반대로 비선점형 스케줄링은 프로세스에게 할당된 CPU를 강제로 빼앗을 수 없고 프로세스의 사용이 끝난 이후 다른 프로세스에게 CPU의 자원을 할당할 수 있습니다.&lt;/p&gt;

&lt;p&gt;선점형 스케줄링이 경우 하나의 프로세스가 자원 독점하지 못하도록 막을 수 있지만 문맥교환 과정에서 오버헤드가 발생할 수 있습니다. 반대로 비선점형 스케줄링의 경우 문맥교환에 대한 오버헤드가 없지만 전체 시스템의 처리율이 떨어질 수 있습니다.&lt;/p&gt;

&lt;p&gt;운영체제는 PCB를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스케줄링 큐(Queue)&lt;/code&gt;에서 리스트 형태로 관리합니다. 보통 큐는 선입선출의 방식을 따르는 자료 구조이지만 스케줄링 큐는 스케줄링 전략에 따라 다른 자료구조를 가질 수도 있습니다. 스케줄링 큐는 프로세스 상태에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준비 큐(Ready Queue)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대기 큐(Waitubg Queue)&lt;/code&gt; 등 여러 큐가 존재합니다.&lt;/p&gt;

&lt;h2 id=&quot;비선점형-스케줄링&quot;&gt;비선점형 스케줄링&lt;/h2&gt;

&lt;h3 id=&quot;선입-선처리first-come-first-served-fcfs-알고리즘&quot;&gt;선입 선처리(First Come First Served, FCFS) 알고리즘&lt;/h3&gt;

&lt;p&gt;FCFS 알고리즘은 프로세스 도착순으로 CPU를 할당하는 CPU 스케줄링 알고리즘 입니다. 즉, 준비 큐에 도착한 순서대로 CPU에 자원을 할당합니다. 직관적이고 단순한 알고리즘 이지만 평균 대기시간이 길어지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;호위 효과(Convoy Effect)&lt;/code&gt; 문제가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img128.png&quot; alt=&quot;img128&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 그림을 보면 P&lt;sub&gt;1&lt;/sub&gt;은 20초, P&lt;sub&gt;2&lt;/sub&gt;는 3초, P&lt;sub&gt;3&lt;/sub&gt;은 7초, P&lt;sub&gt;4&lt;/sub&gt;는 5초의 실행시간을 추정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;도착시간이 0초로 모두 동일하다고 가정하면 FCFS 알고리즘의 경우 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;P&lt;sub&gt;1&lt;/sub&gt; →  P&lt;sub&gt;2&lt;/sub&gt; → P&lt;sub&gt;3&lt;/sub&gt; → P&lt;sub&gt;4&lt;/sub&gt;&lt;/strong&gt; 순서로 실행되며, P&lt;sub&gt;1&lt;/sub&gt;은 0초, P&lt;sub&gt;2&lt;/sub&gt;는 20초, P&lt;sub&gt;3&lt;/sub&gt;은 23초, P&lt;sub&gt;4&lt;/sub&gt;는 30초의 대기시간을 가지게 되어 평균 대기시간은 &lt;strong&gt;18.25초&lt;/strong&gt;가 됩니다. [(0 + 20 + 23 + 30) / 4 = 18.25]&lt;/p&gt;

&lt;p&gt;이는 아래 알고리즘과 비교하면 긴 대기시간을 가집니다.&lt;/p&gt;

&lt;h3 id=&quot;최단-작업-우선shortest-job-first-sjf-알고리즘&quot;&gt;최단 작업 우선(Shortest Job First, SJF) 알고리즘&lt;/h3&gt;

&lt;p&gt;SJF 스케줄링은 FCFS 알고리즘을 보완하여 실행시간이 짧다고 추정되는 프로세스에게 먼저 자원을 할당하는 CPU 스케줄링 알고리즘 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img128.png&quot; alt=&quot;img128&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도착시간이 0초로 모두 동일하다고 가정하면 SJF 알고리즘의 경우 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;P&lt;sub&gt;2&lt;/sub&gt; →  P&lt;sub&gt;4&lt;/sub&gt; → P&lt;sub&gt;3&lt;/sub&gt; → P&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; 순서로 실행되며, P&lt;sub&gt;2&lt;/sub&gt;는 0초, P&lt;sub&gt;4&lt;/sub&gt;는 3초, P&lt;sub&gt;3&lt;/sub&gt;은 8초, P&lt;sub&gt;1&lt;/sub&gt;은 15초의 대기시간을 가지게 되어 평균 대기시간은 &lt;strong&gt;6.5초&lt;/strong&gt;가 됩니다. [(0 + 3 + 8 + 15) / 4 = 6.5]&lt;/p&gt;

&lt;p&gt;SJF 알고리즘은 호위효과 문제가 해결되었지만 실행시간이 긴 프로세스의 경우 영원히 CPU를 할당받지 못하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기아(Starvation) 현상&lt;/code&gt;이 발생할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;최고-응답률-우선highest-response-ratio-next-hrn-알고리즘&quot;&gt;최고 응답률 우선(Highest Response-ratio Next, HRN) 알고리즘&lt;/h3&gt;

&lt;p&gt;HRN 알고리즘은 점유의 불평등 현상이 발생하는 SJF 알고리즘을 보완하여 응답률이 높은 프로세스에게 먼저 자원을 할당하는 CPU 알고리즘이며, 다음과 같은 계산을 통해 프로세스의 우선순위를 결정합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우선순위 = (대기시간 + 실행시간) / 실행시간&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img128.png&quot; alt=&quot;img128&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도착시간이 0초로 모두 동일하고 실행시간이 짧은 P&lt;sub&gt;2&lt;/sub&gt;가 처음 실행되었다고 가정하면 나머지 프로세스의 우선순위를 다음과 같이 계산할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P&lt;sub&gt;1&lt;/sub&gt;: (3 + 20) / 20 = 1.15&lt;/li&gt;
  &lt;li&gt;P&lt;sub&gt;3&lt;/sub&gt;: (23 + 7) / 7 = 4.3&lt;/li&gt;
  &lt;li&gt;P&lt;sub&gt;4&lt;/sub&gt;: (30 + 5) / 5 = 7&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러므로 P&lt;sub&gt;2&lt;/sub&gt; 다음으로 우선순위가 높은 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;P&lt;sub&gt;4&lt;/sub&gt; →  P&lt;sub&gt;3&lt;/sub&gt; → P&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; 순서로 프로세스가 실행됩니다. 대기 시간이 길어질수록 우선순위가 높아지므로 P&lt;sub&gt;4&lt;/sub&gt;의 기아현상도 해소할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;선점형-스케줄링&quot;&gt;선점형 스케줄링&lt;/h2&gt;

&lt;h3 id=&quot;라운드-로빈round-robin-rr-알고리즘&quot;&gt;라운드 로빈(Round Robin, RR) 알고리즘&lt;/h3&gt;

&lt;p&gt;RR 알고리즘은 FCFS 알고리즘을 선점형으로 변형한 알고리즘 입니다. 선점형 스케줄링의 경우 프로세스가 정해진 시간만큼 돌아가면서 CPU를 사용하며, 해당 시간을 초과하면 타임아웃 인터럽트에 의해 CPU 점유를 빼앗기고 준비 큐에 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;이 정해진 시간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타임 슬라이스(Time Slice)&lt;/code&gt;라고 하며, 선점형 스케줄링 알고리즘에서는 타임 슬라이스의 크기가 중요합니다. 타임 슬라이스가 너무 크면 선점형과 다를바 없어져 호위 효과 문제가 발생할 수 있으며, 타임 슬라이스가 너무 작으면 잦은 문맥 교환으로 인한 오버헤드가 발생하여 CPU 성능이 떨어질 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img129.png&quot; alt=&quot;img129&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도착시간이 0초로 모두 동일하고 타임 슬라이스는 5초라고 가정하면, P&lt;sub&gt;1&lt;/sub&gt;과 P&lt;sub&gt;3&lt;/sub&gt;은 타임슬라이스를 초과하여 문맥 교환이 발생합니다. 그러므로 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;P&lt;sub&gt;1&lt;/sub&gt; → (문맥교환) → P&lt;sub&gt;2&lt;/sub&gt; → P&lt;sub&gt;3&lt;/sub&gt; → (문맥교환) → P&lt;sub&gt;4&lt;/sub&gt; → P&lt;sub&gt;1&lt;/sub&gt; → (문맥교환) → P&lt;sub&gt;3&lt;/sub&gt; → P&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; 순서로 실행됩니다.&lt;/p&gt;

&lt;h3 id=&quot;최소-잔여-시간-우선sortest-remaining-time-srt-알고리즘&quot;&gt;최소 잔여 시간 우선(Sortest Remaining Time, SRT) 알고리즘&lt;/h3&gt;

&lt;p&gt;SRT 알고리즘은 SJF 알고리즘을 선점형으로 변형한 알고리즘입니다. 프로세스는 정해진 시간만큼 CPU를 사용하며, 남은 실행시간이 짧다고 추정되는 프로세스에게 먼저 자원을 할당하는 CPU 스케줄링 알고리즘 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img130.png&quot; alt=&quot;img130&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도착시간이 0초로 모두 동일하고 타임 슬라이스는 5초라고 가정하면 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;P&lt;sub&gt;2&lt;/sub&gt; → P&lt;sub&gt;4&lt;/sub&gt; → P&lt;sub&gt;3&lt;/sub&gt; → (문맥교환) → P&lt;sub&gt;1&lt;/sub&gt; → (문맥교환) → P&lt;sub&gt;3&lt;/sub&gt; → P&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; 순서로 실행됩니다.&lt;/p&gt;

&lt;h3 id=&quot;다단계-큐multi-level-queue-mq-알고리즘&quot;&gt;다단계 큐(Multi-level Queue, MQ) 알고리즘&lt;/h3&gt;

&lt;p&gt;MQ 알고리즘은 프로세스의 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위의 큐에 있는 프로세스들에게 먼저 자원을 할당하는 CPU 스케줄링 알고리즘 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img131.png&quot; alt=&quot;img131&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 알고리즘은 큐 별로 서로 다른 CPU 스케줄링 알고리즘을 적용할 수 있지만, 프로세스가 큐 간의 이동을 할 수 없기 때문에 우선순위가 낮은 큐에 있는 프로세스들은 기아 현상이 발생할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;다단계-피드백-큐multi-level-feedback-queue-mfq-알고리즘&quot;&gt;다단계 피드백 큐(Multi-level Feedback Queue, MFQ) 알고리즘&lt;/h3&gt;

&lt;p&gt;MFQ 알고리즘은 MQ 알고리즘이 발전된 형태로, 프로세스가 큐 간의 이동이 가능한 CPU 스케줄링 알고리즘 입니다. MQ 알고리즘은 정해진 시간동안 작업을 처리하지 못하면 동일한 우선순위의 준비 큐에 들어가지만, MFQ 알고리즘의 경우 우선순위가 낮은 큐에 들어감으로써 프로세스의 기아 현상을 해결할 수 있습니다. 이 기법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에이징(aging)&lt;/code&gt;이라고 합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">CPU 스케줄링(CPU Scheduling)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스</title>
      <link href="https://huimang2.github.io/etc/computer-process" rel="alternate" type="text/html" title="프로세스" />
      <published>2023-06-18T01:00:00+09:00</published>
      <updated>2023-06-18T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-process</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-process">&lt;h1 id=&quot;프로세스process&quot;&gt;프로세스(Process)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스(Process)&lt;/code&gt;란 현재 실행되고 있는 프로그램의 인스턴스를 말합니다. 프로그램은 데이터 상태로 보조기억장치에 저장되어 있으며, 프로그램이 실행되면 메모리에 적재되어 프로세스가 됩니다. 윈도우에서 작업 관리자를 열면 현재 실행중인 프로세스를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img112.png&quot; alt=&quot;img112&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포그라운드 프로세스(Foreground Process)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백그라운드 프로세스(Background Process)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포그라운드 프로세스(Foreground Process)&lt;/code&gt;는 사용자와 상호작용하면서 실행되는 프로세스입니다. 이 프로세스는 주로 사용자 인터페이스를 통해 입력을 받거나 출력을 제공하며, 사용자의 명령을 처리하거나 작업을 수행합니다. 포그라운드 프로세스는 사용자가 직접 볼 수 있고 제어할 수 있으며, 사용자와의 상호작용을 위해 우선순위를 가지고 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백그라운드 프로세스(Background Process)&lt;/code&gt;는 사용자와 상호작용하지 않고 실행되는 프로세스입니다. 이러한 프로세스는 주로 시스템 작업이나 보조 작업을 처리하는 데 사용됩니다. 백그라운드 프로세스는 사용자의 입력이나 제어를 기다리지 않고 실행되므로 보다 높은 우선순위를 가질 수 있습니다. 일반적으로 백그라운드 프로세스는 시간이 오래 걸리는 작업이나 자동화된 작업을 처리하는 데 사용됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 웹 브라우저를 실행한다고 가정해 봅시다. 웹 브라우저 자체는 포그라운드 프로세스로 실행되며, 사용자가 웹 페이지를 찾아보거나 입력을 하면 이를 처리합니다. 그러나 웹 브라우저에서 파일을 다운로드하는 경우, 다운로드 작업은 백그라운드 프로세스로 실행됩니다. 사용자는 다운로드 작업이 백그라운드에서 진행되는 동안에도 브라우저를 계속 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;백그라운드 프로세스는 다운로드와 같이 사용자와 상호작용이 가능한 백그라운드 프로세스와 사용자와 상호작용하지 않고 정해진 작업만 수행하는 백그라운드 프로세스로 나눌 수 있습니다. 후자의 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데몬(Daemon)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스(Service)&lt;/code&gt; 라고 합니다.&lt;/p&gt;

&lt;h6 id=&quot;윈도우-서비스&quot;&gt;윈도우 서비스&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img119.png&quot; alt=&quot;img119&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;프로세스-제어-블록process-control-block-pcb&quot;&gt;프로세스 제어 블록(Process Control Block, PCB)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스 제어 블록(Process Control Block, PCB)&lt;/code&gt;은 운영체제에서 프로세스를 관리하기 위해 사용되는 데이터 구조입니다.&lt;/p&gt;

&lt;p&gt;CPU는 한정된 자원을 가지기 때문에 프로세스는 돌아가면서 한정된 시간만큼 CPU를 사용합니다. 자신의 차례에 정해진 시간만큼 CPU를 사용하고 타이머 인터럽트가 발생하면 다음 프로세스에게 차례를 양보합니다. 운영 체제는 빠르게 번갈아 수행되는 프로세스를 관리할 필요가 있는데, 이를 위해 PCB를 사용합니다.&lt;/p&gt;

&lt;p&gt;운영체제는 각 프로세스에 대해 PCB를 커널 영역에 생성하고 프로세스의 상태 및 관련 정보를 추적합니다. 이러한 정보는 운영 체제가 프로세스를 스케줄링하고 제어하는 데 필요한 기반이 됩니다.&lt;/p&gt;

&lt;p&gt;PCB는 프로세스의 상태, 우선 순위, 레지스터 값, 메모리 할당 정보, 입출력 상태 등 다양한 정보를 포함합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;1. 프로세스 식별자(Process ID, PID)&lt;/font&gt;:&lt;/strong&gt; 각 프로세스를 고유하게 식별하는 번호 또는 이름입니다. PID는 운영 체제에서 프로세스를 식별하는 데 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;2. 프로세스 상태(Process State)&lt;/font&gt;:&lt;/strong&gt; 프로세스의 현재 상태를 나타냅니다. 프로세스 상태는 &lt;strong&gt;실행(Running)&lt;/strong&gt;, &lt;strong&gt;대기(Waiting)&lt;/strong&gt;, &lt;strong&gt;준비(Ready)&lt;/strong&gt; 등이 있습니다. 운영 체제는 이 정보를 기반으로 프로세스를 스케줄링하고 상태 전이를 관리합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;3. 프로그램 카운터(Program Counter, PC)&lt;/font&gt;:&lt;/strong&gt; 현재 실행 중인 명령어의 주소를 가리키는 레지스터 값입니다. 프로세스는 다음에 실행할 명령어를 PC의 값에 따라 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;4. 레지스터(Register) 값&lt;/font&gt;:&lt;/strong&gt; 프로세스가 현재 사용 중인 레지스터의 값을 저장합니다. 이는 프로세스가 실행되는 동안 레지스터 값이 유지되도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;5. 스케줄링 정보(Scheduling Information)&lt;/font&gt;:&lt;/strong&gt; 프로세스의 우선 순위, CPU 점유 시간, 대기 시간 등 스케줄링과 관련된 정보를 포함합니다. 운영 체제는 이 정보를 기반으로 프로세스 스케줄링 알고리즘을 실행하여 어떤 프로세스를 실행시킬지 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;6. 메모리 관리 정보(Memory Management Information)&lt;/font&gt;:&lt;/strong&gt; 프로세스가 사용하는 메모리 주소 범위, 페이지 테이블 정보 등과 같은 메모리 관리에 필요한 정보를 포함합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;7. 입출력 상태(I/O Status)&lt;/font&gt;:&lt;/strong&gt; 프로세스가 사용 중인 입출력 장치와 관련된 정보를 저장합니다. 이 정보는 프로세스가 입출력 작업을 수행하는 데 필요합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스-상태&quot;&gt;프로세스 상태&lt;/h1&gt;

&lt;p&gt;프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생성(New)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준비(Ready)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행(Run)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대기(Wait)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종료(Exit)&lt;/code&gt; 5가지 상태를 가집니다. 프로세스 상태는 운영 체제가 프로세스의 상태 전이를 관리하고 스케줄링을 수행하기 위해 사용됩니다. 스케줄러는 준비 상태에 있는 프로세스를 실행 상태로 전환하고, 대기 상태에 있는 프로세스를 준비 상태로 전환하여 CPU 할당을 조정합니다. 이를 통해 CPU 자원을 효율적으로 활용하고 다중 프로세스가 동시에 실행될 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img123.png&quot; alt=&quot;img123&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;생성 상태(create status)&lt;/code&gt;는 프로세스가 생성되었지만 아직 실행되기 전인 상태입니다. 이 단계에서는 프로세스가 초기화되고 필요한 자원이 할당됩니다. PCB는 이때 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;준비 상태(ready status)&lt;/code&gt;는 프로세스가 실행을 기다리는 상태입니다. 필요한 자원을 모두 할당받았으며, CPU를 할당받기를 기다리는 상태입니다. 스케줄러에 의해 다음에 실행될 프로세스로 선택될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;실행 상태(runnig status)&lt;/code&gt;는 준비 상태에 있는 프로세스가 CPU를 할당받아 실행되고 있는 상태입니다. 준비 상태에 있는 프로세스가 실행 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디스패치(Dispatch)&lt;/code&gt;라고 합니다. 이때 프로세스는 CPU를 사용하여 명령어를 실행하고 작업을 수행합니다. 실행 상태에서는 시간이 지남에 따라 프로세스는 완료되거나 대기 상태로 전환될 수 있습니다. 실행 상태의 프로세스가 대기 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Block&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;대기 상태(blocking status)&lt;/code&gt;는 프로세스가 어떤 이벤트를 기다리는 상태입니다. 이벤트는 입출력 완료, 사용자 입력, 시간 지연 등 다양한 상황일 수 있습니다. 대기 상태에 있는 프로세스는 CPU를 사용할 수 없으며, 해당 이벤트가 발생할 때까지 기다리게 됩니다. CPU에 비해 느린 입출력 작업의 경우 대기상태로 있다가 입출력 완료 인터럽트 신호를 받으면 준비 상태로 전환됩니다. 대기 상태의 프로세스가 준비 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wake up&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;종료 상태(terminate status)&lt;/code&gt;는 프로세스가 완료되거나 종료된 상태입니다. 프로세스의 실행이 끝났거나, 강제로 종료되었을 때 이 상태로 전환됩니다. 종료된 프로세스는 시스템에서 제거됩니다.&lt;/p&gt;

&lt;h1 id=&quot;문맥-교환context-switch&quot;&gt;문맥 교환(Context Switch)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문맥 교환(Context Switching)&lt;/code&gt;은 운영 체제에서 한 프로세스의 실행 상태를 저장하고 다른 프로세스의 실행 상태로 전환하는 과정을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문맥(Context)&lt;/code&gt;이란 프로그램 카운터 등 프로세스가 다음 차례가 왔을 때 실행을 재개하기 위한 PCB 정보를 말합니다. 문맥을 백업해두면 언제든지 프로세스의 실행을 재개할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img120.png&quot; alt=&quot;img120&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문맥 교환은 멀티태스킹 환경에서 여러 프로세스가 동시에 실행되는 상황에서 CPU의 할당을 조정하기 위해 필요합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스의-구조&quot;&gt;프로세스의 구조&lt;/h1&gt;

&lt;p&gt;메모리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 영역&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 영역&lt;/code&gt;으로 나눌 수 있습니다. 사용자 영역에서 프로세스는 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;코드(Code) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터(Data) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙(Heap) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스택(Stack) 영역&lt;/code&gt; 등으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img121.png&quot; alt=&quot;img121&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;커널 영역&lt;/code&gt;에는 위에서 설명했듯이 PCB가 저장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;코드 영역&lt;/code&gt;에는 실행하는 프로그램의 코드가 기계어로 저장되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;텍스트(Text) 영역&lt;/code&gt;이라고도 합니다. 데이터가 아닌 CPU가 실행할 명령어가 저장되어 있어서 쓰기가 금지된 read-only 영역입니다. CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;데이터 영역&lt;/code&gt;에는 프로그램이 실행되는 동안 유지할 데이터가 저장됩니다. 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전역 변수(global variable)&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 변수(static variable)&lt;/code&gt;가 저장되며, 프로그램이 실행될 때 할당되고 프로그램이 종료되면 소멸합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;힙 영역&lt;/code&gt;은 사용자가 직접 관리할 수 있는 메모리 영역으로, 런 타임에 할당받을 메모리 크기가 결정됩니다. 예를 들어 C언어에서 동적 크기의 배열을 선언하거나 자바에서 new 명령어를 통해 인스턴스를 생성하면 동적으로 힙 영역을 할당받아 데이터가 저장됩니다.&lt;/p&gt;

&lt;p&gt;힙 영역은 사용자가 직접 메모리를 반환해야 하며, 메모리를 반환하지 않으면 지속적으로 메모리 공간을 차지하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 누수(Memory Leak)&lt;/code&gt; 현상이 발생합니다. C언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free&lt;/code&gt; 함수를 통해 메모리를 반환하며, 자바의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가비지 콜렉션(Garbage Collection)&lt;/code&gt;에 의해 자동으로 메모리가 반환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;스택 영역&lt;/code&gt;은 함수 호출 시 생성되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지역 변수(local variable)&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매개 변수(parameter)&lt;/code&gt; 등의 데이터가 일시적으로 저장되는 영역으로, 컴파일 타임에 할당받을 메모리 크기가 결정됩니다. 함수를 호출하면 동적으로 스택 영역을 할당받아 데이터가 저장되고, 함수의 호출이 완료되면 할당받은 메모리를 반환합니다.&lt;/p&gt;

&lt;p&gt;스택 영역은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;푸시(push)&lt;/code&gt; 동작으로 데이터를 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팝(pop)&lt;/code&gt; 동작으로 데이터를 인출합니다. 데이터 인출시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후입선출(Last-In First-Out, LIFO)&lt;/code&gt; 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;코드 영역과 데이터 영역은 프로그램 시작시 고정적으로 메모리를 할당받기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 할당 영역&lt;/code&gt; 이라고 하며, 힙 영역과 스택 영역은 메모리를 동적으로 할당받기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적 할당 영역&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;동적 할당 영역에서 힙 영역은 낮은 주소에서 높은 주소 방향으로 메모리가 할당되고, 스택 영역은 높은 주소에서 낮은 주소 방향으로 메모리가 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img122.png&quot; alt=&quot;img122&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 두 영역이 겹쳐 할당받을 메모리가 없게 된다면 서로의 영역을 침범할 수 있습니다. 이때 스택이 힙 영역을 침범하는 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스택 오버플로우(Stack Overflow)&lt;/code&gt;, 힙이 스택 영역을 침범하는 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙 오버플로우(Heap Overflow)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스의-생성&quot;&gt;프로세스의 생성&lt;/h1&gt;

&lt;p&gt;프로세스는 프로그램을 실행할 때 생성됩니다. 이때 운영체제가 프로그램 코드를 메모리 코드영역에 할당하고 PCB를 생성한 후 메모리에 데이터 영역과 스택 영역을 확보하여 프로세스를 실행합니다.&lt;/p&gt;

&lt;p&gt;유닉스 계열의 운영체제의 경우 새로운 프로세스를 생성할 때 위 과정을 모두 거치지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt; 시스템 호출을 통해 기존 프로세스 복사하여 새로운 프로세스를 생성합니다. 이때 fork 시스템 호출을 하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 되어 계층 구조를 형성합니다.&lt;/p&gt;

&lt;p&gt;fork를 호출하면 PCB를 포함한 부모 프로세스 대부분이 자식 프로세스에 복사되어 동일한 프로세스가 생성됩니다. 다만 PID, PPID, CPID 등 일부 데이터가 수정됩니다. PPID는 부모 프로세스의 PID, CPID는 자식 프로세스의 PID 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img124.png&quot; alt=&quot;img124&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;fork-예제-코드&quot;&gt;fork 예제 코드&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;first_PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;first_PPID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;---------------------&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Child Process!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent Process!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PPID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;saved PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;---------------------&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img125.png&quot; alt=&quot;img125&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 살펴보면 first_PID와 first_PPID가 부모 프로세스의 PID, PPID와 동일하다는 것을 볼 수 있습니다. 부모 프로세스와 자식 프로세스가 동기화되어 실행되는 것 처럼 보이지만 실제로는 독립적으로 실행되고 있습니다.&lt;/p&gt;

&lt;p&gt;fork 시스템 호출을 요청하면 부모 프로세스에는 자식 프로세스의 PID를 리턴하고, 자식 프로세스에는 0을 리턴합니다. 또한 자식 프로세스는 부모 프로세스의 PCB를 상속받았기 때문에 프로그램 카운터가 동일하여 fork 시스템 호출을 요청한 이후의 코드가 실행됩니다. 그렇기 때문에 자식 프로세스에서는 firt_PID와 first_PPID를 출력하지 않습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자식 프로세스에서 새로운 프로그램을 실행하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 시스템 호출을 요청하면 됩니다. exec 시스템 호출을 요청하면 자식 프로세스의 코드 영역을 새로운 코드로 교체하고 PCB에서 프로그램 카운터나 각종 레지스터, 파일 정보 등이 리셋됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img126.png&quot; alt=&quot;img126&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;exec-예제-코드-parent&quot;&gt;exec 예제 코드: parent&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent process!!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;execl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./child&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;./child&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;child process failed to exec&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;exec-예제-코드-child&quot;&gt;exec 예제 코드: child&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;child process!!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과-1&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p style=&quot;margin-top: 0&quot;&gt;&lt;img src=&quot;/assets/images/computer/img127.png&quot; alt=&quot;img127&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부모 프로세스가 먼저 종료되면 자식 프로세스도 종료되기 때문에 parent 코드에서 wait 함수를 통해 자식 프로세스와 동기화 시킵니다.&lt;/p&gt;

&lt;p&gt;parent를 실행하면 fork 시스템 호출에 의해 자식 프로세스가 생성되고, exec 시스템 호출에 의해 자식 프로세스는 child를 실행합니다. 코드 영역이 child 코드로 변경되었기 때문에 “child process failed to exec” 라는 메시지는 출력되지 않습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;fork와 exec를 통해 프로세스를 생성하는 방식은 프로세스 생성 과정 전체를 거치지 않기 때문에 프로세스 생성 속도가 빠르고 추가 작업 없이 자원의 상속이 가능하여 시스템 관리에 효율적입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">프로세스(Process)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">운영체제</title>
      <link href="https://huimang2.github.io/etc/computer-operating-system" rel="alternate" type="text/html" title="운영체제" />
      <published>2023-06-17T01:00:00+09:00</published>
      <updated>2023-06-17T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-operating-system</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-operating-system">&lt;h1 id=&quot;운영체제operating-system란&quot;&gt;운영체제(Operating System)란?&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제(Operating System)&lt;/code&gt;는 컴퓨터의 자원을 효율적으로 운영하기위해 필요한 소프트웨어입니다. 대표적으로 윈도우(Windows), 맥 OS(Mac OS), 안드로이드(Android), 우분투(Ubuntu) 등이 운영체제입니다.&lt;/p&gt;

&lt;p&gt;모든 프로그램은 실행을 위해 자원을 필요로 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자원(Resource)&lt;/code&gt;이란 컴퓨터 시스템에서 작업을 수행하는 데 사용되는 모든 하드웨어 및 소프트웨어를 말하며, 앞서 설명했던 CPU, 메모리, 보조기억장치, 입출력장치 또한 자원입니다.&lt;/p&gt;

&lt;p&gt;명령어를 통해 이러한 자원을 효율적으로 관리하는 것은 여간 힘든 일이 아닙니다. 이를 돕는 것이 운영체제 입니다. 운영체제는 실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;컴퓨터가 켜지면 CPU는 ROM에 저장된 명령어를 읽습니다. ROM에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST(Power-On Self-Test)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부트로더(Boot loader)&lt;/code&gt;가 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 실행되는 POST는 컴퓨터의 상태를 검사합니다. 요즘은 UEFI의 Fast boot 옵션으로 인해 생략되어 보기 힘들지만 예전에는 컴퓨터를 켜면 가장 먼저 보이는 화면이 POST를 실행하는 화면이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img113.png&quot; alt=&quot;img113&quot; /&gt;&lt;/p&gt;

&lt;p&gt;POST 작업이 끝나면 부트로더가 실행됩니다. 부트로더는 하드디스크에 있는 운영체제를 찾아 실행시키는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;실행되는 모든 프로그램은 메모리에 적재됩니다. 프로그램이 적재되는 공간은 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 영역&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 영역&lt;/code&gt;으로 나눌 수 있는데, 운영체제 역시 특별한 프로그램이기 때문에 메모리의 커널 영역에 적재됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img110.png&quot; alt=&quot;img110&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;운영체제의-기능&quot;&gt;운영체제의 기능&lt;/h1&gt;

&lt;h2 id=&quot;프로세스-관리&quot;&gt;프로세스 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스(process)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세서(procesor)&lt;/code&gt;를 관리합니다. 실행중인 프로그램을 프로세스라고 하며, 프로세스 작업을 하는 CPU를 프로세서라고 합니다. 프로세스는 메모리에 적재되어 실행되며, 수많은 프로세스들이 동시에 실행되고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img112.png&quot; alt=&quot;img112&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세서는 한정된 자원을 가지기 때문에 여러 프로세스가 동시에 프로세서에 접근한다면 충돌이 발생할 수 있습니다. 그러므로 프로세스가 직접 프로세서에 접근하는 것이 아니라 운영체제가 프로세스를 관리하여 충돌 없이 프로세스가 실행될 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img111.png&quot; alt=&quot;img111&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 여러 프로세스를 빠르게 번갈아 실행시킴으로써 멀티테스킹을 하는 것처럼 보이도록 합니다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-관리&quot;&gt;메모리 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 비어있는 메모리에 프로그램을 할당하고, 프로그램이 종료되면 메모리를 비워주는 등 메모리를 관리합니다.&lt;/p&gt;

&lt;p&gt;프로그램을 실행하기 위해서는 데이터를 보조기억장치의 특정 주소에서 가져오고 이를 메모리의 특정 주소에 할당하는 등의 복잡한 과정이 필요합니다. 하지만 운영체제가 자원을 관리하여 이러한 복잡한 절차없이 프로그램을 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;파일-시스템-관리&quot;&gt;파일 시스템 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 보조기억장치의 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파일(file)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디렉토리(directory)&lt;/code&gt; 형태로 관리합니다. 윈도우에서는 디렉토리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴더(folder)&lt;/code&gt;라고 합니다. 디렉토리를 통해 사용자는 보조기억장치의 데이터에 쉽게 접근할 수 있으며, 파일을 통해 프로그램을 쉽게 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;사용자-인터페이스-제공&quot;&gt;사용자 인터페이스 제공&lt;/h2&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 인터페이스(User Interface)&lt;/code&gt;를 제공합니다. CLI를 통해 단순히 운영체제 명령어를 입력하는 것 만으로도 프로그램을 실행시킬 수 있습니다. 최근에는 GUI를 통해 아이콘을 클릭하거나 NUI를 통해 음성명령을 하는 것 만으로도 프로그램을 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;커널kernel과-쉘shell&quot;&gt;커널(Kernel)과 쉘(Shell)&lt;/h1&gt;

&lt;p&gt;운영체제는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kernel)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img114.png&quot; alt=&quot;img114&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kernel)&lt;/code&gt;은 운영체제의 핵심 서비스를 담당하는 한 부분입니다. 운영체제는 종류에 따라 다른 기능을 제공하지만 운영체제의 핵심 서비스는 자원을 관리하는 것입니다.&lt;/p&gt;

&lt;p&gt;위에서 설명한 운영체제의 기능은 대부분 커널의 기능에 속하며, 사용자를 위한 프로그램이 아닌 시스템을 위한 프로그램 입니다. 즉, 커널은 하드웨어와 소프트웨어를 연결하는 인터페이스 입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리눅스 커널(Linux Kernel)&lt;/code&gt;이 있습니다. 안드로이드(Android)나 우분투(Ubuntu) 등은 오픈소스인 리눅스 커널을 기반으로 하는 운영체제 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt;은 사용자와 커널을 연결하는 인터페이스 입니다. 커널은 시스템을 위한 프로그램이기 때문에 커널을 통해 직접 자원을 관리하는 것은 어렵습니다. 쉘은 커널의 복잡한 동작 방식을 알 필요 없이 간단한 명령어를 통해 사용자가 자원을 관리할 수 있도록 돕는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 윈도우의 &lt;strong&gt;명령어 프롬프트(Command Prompt)&lt;/strong&gt;, 우분투의 &lt;strong&gt;배쉬 쉘(Bash Sehll)&lt;/strong&gt; 등이 쉘입니다.&lt;/p&gt;

&lt;h1 id=&quot;이중-모드dual-mode&quot;&gt;이중 모드(Dual Mode)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이중 모드(Dual Mode)&lt;/code&gt;는 다중 프로그래밍 환경에서 자원에 대한 접근을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 모드(User Mode)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 모드(Kernel Mode)&lt;/code&gt;로 분리하여 운영체제를 보호하는 기법입니다.&lt;/p&gt;

&lt;p&gt;사용자와 운영체제는 시스템 자원을 공유합니다. 만약 사용자가 시스템 자원에 직접적으로 접근할 수 있다면 운영체제와 충돌하여 컴퓨터 시스템에 악영향을 미칠 수 있습니다. 그러므로 커널은 자신을 통해서만 자원에 접근할 수 있도록 제한합니다. 이때 CPU는 상태 레지스터의 슈퍼바이저 플래그를 통해 응용 프로그램의 명령어는 사용자 모드로, 커널의 명령어는 커널 모드로 구분하여 실행합니다.&lt;/p&gt;

&lt;p&gt;사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행 모드입니다. 즉, 커널 영역에 있는 운영체제 코드를 실행시킬 수 없습니다. 일반적으로 응용 프로그램은 사용자 모드로 실행되어 입출력 명령어 같은 자원에 접근하는 명령어를 실행 할 수 없습니다.&lt;/p&gt;

&lt;p&gt;커널 모드는 운영체제 서비스를 제공받을 수 있는 실행 모드입니다. 즉, 커널 영역에 있는 운영체제 코드를 실행시킬 수 있습니다. 운영체제는 커널 모드로 실행되기 때문에 자원에 접근할 수 있게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;시스템-호출system-call&quot;&gt;시스템 호출(System Call)&lt;/h1&gt;

&lt;p&gt;사용자 모드로 실행되는 응용 프로그램이 자원에 접근하기 위해서는 운영체제에 요청을 보내어 커널 모드로 전환되어야 하는데, 이 요청을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 호출(System Call)&lt;/code&gt;이라고 합니다. 즉, 응용 프로그램은 시스템 호출을 통해 운영체제 서비스를 제공받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img115.png&quot; alt=&quot;img115&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시스템 호출은 일종의 인터럽트로, 소프트웨어 인터럽트 입니다. 하드웨어 인터럽트와 같이 시스템 호출을 하면 CPU는 기존 작업을 백업하고 인터럽트 서비스 루틴을 수행한 후 기존 작업을 이어서 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img116.png&quot; alt=&quot;img116&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오픈소스인 리눅스 커널의 시스템 콜은 다음 사이트에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md&quot; target=&quot;_blank&quot;&gt;Linux System Call Table&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;우분투에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt; 라는 도구를 통해 시스템 호출을 추적할 수 있습니다. 다음과 같이 간단한 코드를 작성해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img117.png&quot; alt=&quot;img117&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gcc로 컴파일 후 strace를 통해 해당 코드의 시스템 콜을 추적할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img118.png&quot; alt=&quot;img118&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">운영체제(Operating System)란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">입출력장치</title>
      <link href="https://huimang2.github.io/etc/computer-input-output-unit" rel="alternate" type="text/html" title="입출력장치" />
      <published>2023-06-11T01:00:00+09:00</published>
      <updated>2023-06-11T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-input-output-unit</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-input-output-unit">&lt;h1 id=&quot;장치-컨트롤러device-controller&quot;&gt;장치 컨트롤러(Device Controller)&lt;/h1&gt;

&lt;p&gt;입출력장치는 하드디스크, 마우스, 모니터 등과 같이 컴퓨터 외부에 연결되어 CPU와 정보를 교환할 수 있는 장치입니다.&lt;/p&gt;

&lt;p&gt;입출력 장치는 종류가 다양하기 때문에 CPU와 정보를 주고 받는 방식을 규격화하기 어렵습니다. 또한 CPU에 비하여 데이터 전송률이 낮기 때문에 CPU와 직접적으로 통신하게 되면 CPU의 성능이 좋더라도 이를 활용할 수 없게 됩니다. 이러한 문제를 해결하기 위한 하드웨어를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 컨트롤러(Device Controller)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크의-장치-컨트롤러&quot;&gt;하드디스크의 장치 컨트롤러&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img098.png&quot; alt=&quot;img098&quot; /&gt;&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 CPU와 입출력장치 간의 통신을 중개하여 각 장치들을 규격화 해주며, 오류를 검출하고 버퍼링을 통해 CPU와 데이터 전송률을 맞추는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 레지스터&lt;/code&gt;로 구성되며, CPU는 버스를 통해 장치 컨트롤러에 데이터를 전송합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img099.png&quot; alt=&quot;img099&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 레지스터는 CPU와 입출력장치 사이에 주고 받을 데이터를 저장하는 레지스터로, 버퍼 역할을 합니다. 최근에는 입출력 장치와 주고 받을 데이터가 많아졌기 때문에 데이터 레지스터 대신에 RAM을 사용하기도 합니다.&lt;/p&gt;

&lt;p&gt;상태 레지스터는 입출력장치가 입출력 작업할 준비가 되었는지, 입출력 작업 완료가 되었는지, 입출력장치에 오류가 없는지 등의 상태 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;제어 레지스터는 입출력장치가 수행할 내용에 대한 제어 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;h1 id=&quot;장치-드라이버device-driver&quot;&gt;장치 드라이버(Device Driver)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 드라이버(Device Driver)&lt;/code&gt;는 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램 입니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러가 입출력장치를 연결하는 하드웨어라면, 장치 드라이버는 입출력장치를 연결하는 소프트웨어 입니다. 장치 드라이버를 통해 CPU가 입출력장치를 제어할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;usb-장치-드라이버&quot;&gt;USB 장치 드라이버&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img100.png&quot; alt=&quot;img100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요즘은 OS가 장치 드라이버를 자동으로 설치해주는 경우가 많은데, 이전에는 프린터를 컴퓨터에 연결하여 사용하려면 해당 프린터에 대한 프린트 드라이버를 설치해야 했습니다. 장치 드라이버가 설치되지 않는다면 CPU가 프린터를 동작시키는 방식을 모르기 때문에 해당 프린터를 사용할 수 없게 됩니다. 즉, 장치 드라이버를 인식하고 실행하는 주체는 운영체제(OS) 입니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력-방식&quot;&gt;입출력 방식&lt;/h1&gt;

&lt;p&gt;입출력장치가 CPU와 정보를 교환하는 방식에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로그램-입출력programmed-inputoutput-pio&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/code&gt;은 프로그램 명령어를 통해 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송한 후 입출력장치의 상태를 주기적으로 확인하여 데이터 송수신을 제어합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 메모리에 저장된 정보를 하드디스크에 저장한다고 한다면 CPU는 쓰기 명령어를 전송하고 상태 레지스터의 확인하고 입출력 장치가 사용가능하다면 데이터를 전송합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크-쓰기-제어&quot;&gt;하드디스크 쓰기 제어&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img101.png&quot; alt=&quot;img101&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 주기적으로 상태 레지스터를 확인하는 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴링(Polling)&lt;/code&gt;이라고 하며, 그러므로 프로그램 입출력 방식을 폴링 방식이라고도 합니다.&lt;/p&gt;

&lt;h6 id=&quot;폴링-순환&quot;&gt;폴링 순환&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img102.png&quot; alt=&quot;img102&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 입출력 방식은 가장 간단하고 최소의 하드웨어를 필요로 하지만, 반복적으로 입출력장치의 상태를 점검하여 CPU의 효율을 저하시키키며 입출력이 완료될 때까지 CPU가 동작하지 못한다는 단점이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램 입출력 방식은 CPU가 입출력장치에 접근하는 방식에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-맵-입출력memmory-mapped-io&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소공간으로 취급하여 접근하는 방식입니다.&lt;/p&gt;

&lt;p&gt;메모리의 일부 공간을 입출력 포트에 할당하여 메모리 주소 공간이 축소되지만, 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 동일하기 때문에 CPU 로직이 단순해집니다. 주로 ARM 계열의 RISC에서 사용하며, LOAD나 STORE 명령을 통해 접근할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;고립형-입출력isolated-io&quot;&gt;고립형 입출력(Isolated I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력(Isolated I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 분리하는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;입출력장치에 접근하기 위한 별도의 명령어가 필요하고 CPU 로직이 복잡해지지만, 메모리 주소 공간 전체를 활용할 수 있습니다. 주로 x86 계열의 CISC에서 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-기반-입출력interrupt-driven-io&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/code&gt;은 인터럽트를 기반으로 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송하면 장치 컨트롤러에서 명령어를 수행한 후 CPU에 인터럽트 요청 신호를 보냅니다. 인터럽트 요청신호를 받은 CPU는 하던 일을 멈추고 인터럽트 서비스 루틴을 실행합니다.&lt;/p&gt;

&lt;p&gt;여러 입출력장치에서 인터럽트가 동시에 발생한 경우 우선순위를 고려하여 우선순위가 높은 인터럽트를 먼저 처리합니다. 우선순위를 반영한 인터럽트를 처리하는 방식에는 여러 방식이 존재하지만 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그래머블 인터럽트 컨트롤러(Programmable Interrupt Controller, PIC)&lt;/code&gt;라는 하드웨어를 사용하여 처리합니다.&lt;/p&gt;

&lt;h6 id=&quot;pic&quot;&gt;PIC&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img103.png&quot; alt=&quot;img103&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 장치 컨트롤러와 CPU 사이에서 어떤 인터럽트를 먼저 처리할 것인지를 판단하여 CPU에게 인터럽트 신호를 전송합니타.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img104.png&quot; alt=&quot;img104&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 보통 여러 개를 계층적으로 사용하여 사용하는 경우가 많습니다.&lt;/p&gt;

&lt;h2 id=&quot;dma-입출력direct-memory-access-io&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/code&gt;은 입출력장치와 메모리가 CPU를 거치지 않고 상호작용할 수 있는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;프로그램 입출력과 인터럽트 기반 입출력은 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거치게 되어 하드디스크 백업과 같은 대용량 데이터의 전송이 필요하다면 CPU의 부담이 커지게 됩니다. 이를 해결하기 위한 입출력 방식이 DMA 입출력 방식이며, DMA 입출력 방식은 입출력장치가 CPU를 거치지 않고 직접 메모리에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;DMA 입출력을 위해서는 시스템 버스에 연결된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 컨트롤러&lt;/code&gt;라는 하드웨어가 필요합니다. CPU가 DMA 컨트롤러에 명령어를 보내면 DMA 컨트롤러는 CPU를 대신하여 입출력 작업을 수행하고, 입출력 작업이 끝나면 인터럽트 신호를 통해 CPU에게 입출력 작업이 끝났음을 알립니다. 그동안 CPU는 다른 작업을 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img105.png&quot; alt=&quot;img105&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img106.png&quot; alt=&quot;img106&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img107.png&quot; alt=&quot;img107&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 시스템 버스는 공용 자원이기 때문에 CPU와 DMA 컨트롤러는 동시에 시스템 버스를 사용할 수 없습니다. 그러므로 DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을때 조금씩 시스템 버스를 사용하거나 CPU가 일시적으로 시스템 버스를 사용하지 않도록 요청을 보내고 시스템 버스를 사용합니다.&lt;/p&gt;

&lt;p&gt;DMA 컨트롤러는 메모리에서 데이터를 가져오기 위해 시스템 버스를 한 번, 장치컨트롤러에 데이터를 전송하기 위해 시스템 버스를 또 한 번 사용하여 총 2번 사용하게 됩니다. 그만큼 CPU가 시스템 버스를 사용하지 못하는 문제가 발생하는데, 이를 해결하기 위해 입출력장치를 입출력 버스(I/O Bus)라는 별도의 버스에 연결하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img108.png&quot; alt=&quot;img108&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 그래픽 카드나 SSD를 연결하는 PCIe 슬롯은 입출력 버스와 연결됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img109.png&quot; alt=&quot;img109&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">장치 컨트롤러(Device Controller)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 파이프라인</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-pipeline" rel="alternate" type="text/html" title="명령어 파이프라인" />
      <published>2023-06-06T01:00:00+09:00</published>
      <updated>2023-06-06T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-pipeline</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-pipeline">&lt;h1 id=&quot;명령어-파이프라인instruction-pipeline&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/code&gt;은 CPU의 성능을 향상시키기 위해 명령어 처리를 여러 단계로 나누어 동시에 실행하는 명령어 병렬 처리 기법입니다.&lt;/p&gt;

&lt;p&gt;CPU의 명령어가 처리되는 과정은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출(fetch)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행(execution)&lt;/code&gt; 2단계로 나눌 수 있다고 했는데, 이를 비슷한 시간 간격으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 인출(Instruction Fetch)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 해석(Instruction Decode)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 실행(Execute Instruction)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결과 저장(Write Back)&lt;/code&gt; 4단계로 나눌 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 명령어 인출(Instruction Fetch)&lt;/strong&gt; : 명령어를 기억장치로 부터 인출&lt;br /&gt;
&lt;strong&gt;2. 명령어 해석(Instruction Decode)&lt;/strong&gt; : 디코더를 사용하여 명령어 해석&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행(Execute Instruction)&lt;/strong&gt; : 해석된 명령어에 따라 데이터 연산을 수행&lt;br /&gt;
&lt;strong&gt;4. 결과 저장(Write Back)&lt;/strong&gt; : 명령어대로 처리된 데이터를 메모리에 기록&lt;/p&gt;

&lt;p&gt;만약 명령어 파이프라인을 사용하지 않는다면 다음과 같이 명령어가 순차적으로 실행 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img088.png&quot; alt=&quot;img088&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어 파이프라인을 사용한다면 각 명령어를 겹쳐 동시에 실행함으로써 명령어 처리 시간을 줄여 CPU의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img089.png&quot; alt=&quot;img089&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;파이프라인-위험pipeline-hazard&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/code&gt;은 파이프라인 기법을 사용하는데 있어서 발생할 수 있는 문제점을 말합니다.&lt;/p&gt;

&lt;p&gt;파이프라인 위험에는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt; 3가지로 나눌 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-위험data-hazard&quot;&gt;데이터 위험(Data Hazard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;은 명령어 간의 의존성으로 인해 아직 수행되지 않은 명령어의 결과값을 참조함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같이 명령어1, 명령어2가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;명령어1 : R&lt;sub&gt;1&lt;/sub&gt; ← R&lt;sub&gt;2&lt;/sub&gt; + R&lt;sub&gt;3&lt;/sub&gt;&lt;br /&gt;
명령어2 : R&lt;sub&gt;4&lt;/sub&gt; ← R&lt;sub&gt;1&lt;/sub&gt; * R&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어1은 R&lt;sub&gt;2&lt;/sub&gt;와 R&lt;sub&gt;3&lt;/sub&gt; 레지스터값을 더하여 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 저장하고, 명령어2는 R&lt;sub&gt;1&lt;/sub&gt;과 R&lt;sub&gt;2&lt;/sub&gt; 레지스터값을 곱하여 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장합니다.&lt;/p&gt;

&lt;p&gt;이 경우 아래와 같이 명령어 파이프라인을 사용한다면 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 명령어1의 저장단계가 수행되기 전에 명령어2의 인출 및 해석이 발생하기 때문에 잘못된 결과값이 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img090.png&quot; alt=&quot;img090&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 데이터 위험이라고 합니다. 데이터 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img091.png&quot; alt=&quot;img091&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;제어-위험control-harzard&quot;&gt;제어 위험(Control Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;은 Jump나 Call, Interupt 같은 분기 명령어에 의해 프로그램 카운터(PC)가 갑작스럽게 변함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;기본적으로 명령어는 프로그램 카운터가 순차적으로 증가하여 실행됩니다. 하지만 분기(branch) 명령어를 싱행하게 된다면 프로그램 카운터가 비순차적으로 변하기 때문에 동시에 실행되는 명령어가 필요없어지게 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img092.png&quot; alt=&quot;img092&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 제어 위험이라고 합니다. 제어 위험의 경우 인출 단계 이후에 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img093.png&quot; alt=&quot;img093&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;구조적-위험structural-harzard&quot;&gt;구조적 위험(Structural Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt;은 서로 다른 명령어가 같은 자원에 접근함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Load 명령어의 경우 데이터를 인출하기 위해 메모리에 접근하는 단계가 있어는데, 다음과 같이 동일한 레지스터에 쓰기 접근을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img094.png&quot; alt=&quot;img094&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 구조적 위험이라고 합니다. 구조적 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img095.png&quot; alt=&quot;img095&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;슈퍼스칼라supserscalar&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/code&gt;는 CPU 내에 파이프라인을 여러 개 두어 명령어를 동시에 실행하는 기술로서, 멀티 스레드 프로세서를 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img096.png&quot; alt=&quot;img096&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이론적으로는 파이프라인 개수에 비례하여 CPU의 처리 속도가 증가하지만, 그만큼 파이프라인 위험도 증가하므로 실제로 파이프라인 개수에 비례하여 처리 속도가 증가하지는 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;명령어-집합-구조instruction-set-architecture-isa&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/code&gt;는 CPU가 이해할 수 있는 기계어 명령어들의 집합을 의미합니다. 하드웨어와 시스템 소프트웨어 사이의 인터페이스를 정의하며, 최하위 레벨의 프로그래밍 인터페이스로서 CPU가 실행할 수 있는 모든 명령어를 포함합니다.&lt;/p&gt;

&lt;p&gt;ISA를 물리적으로 구현한 CPU 내부의 하드웨어 구조를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마이크로 아키텍쳐(Micro Architecture)&lt;/code&gt;라고 합니다. CPU 제조사마다 마이크로 아키텍쳐가 다르므로 ISA 역시 서로 다릅니다. 대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;cisccomplex-instruction-set-computer&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;는 복잡한 명령어 집합을 가지는 CPU로서, 인텔이나 AMD의 x86, x86-64는 CISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;CISC는 복잡하고 다양한 가변 길이 명령어를 사용하며, 상대적으로 적은 수의 명령어만으로도 프로그램을 실행할 수 있습니다. 그렇기 때문에 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높은 아키텍쳐였으나, 가변 길이 명령어를 사용하므로 명령어 파이프라이닝이 불리하며 속도가 느리고 가격이 비싸다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 하드웨어 스택(Stack)이 내장되어 있으며, 서브루틴의 return 주소나 파라미터, 지역변수 등을 저장하는데 사용됩니다. 따라서 call, ret, push, pop 같은 명령어를 통해 스택 데이터를 관리할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;riscreduced-instruction-set-computer&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;는 명령어 집합의 수를 줄여 하드웨어 구조를 간단하게 만든 CPU로서, ARM 계열의 CPU는 RISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;RISC는 짧고 규격화된 명령어를 사용하여 명령어 파이프라이닝에 유리합니다. 또한 메모리 접근을 최소화 하고 많은 범용 레지스터를 사용하므로 속도가 빠르며, 전력소모가 적고 가격이 저렴합니다.&lt;/p&gt;

&lt;p&gt;CISC와 달리 스택 관련 명령어가 존재하지 않기 때문에 서브루틴의 return 주소나 파라미터, 지역변수 등은 소프트웨어적으로 처리해야 합니다.&lt;/p&gt;

&lt;h6 id=&quot;cisc--risc-비교&quot;&gt;CISC / RISC 비교&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img097.png&quot; alt=&quot;img097&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 파이프라인(Instruction Pipeline)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 사이클과 인터럽트</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-cycle" rel="alternate" type="text/html" title="명령어 사이클과 인터럽트" />
      <published>2023-05-29T01:00:00+09:00</published>
      <updated>2023-05-29T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-cycle</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-cycle">&lt;h1 id=&quot;명령어-사이클instruction-cycle&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/h1&gt;

&lt;p&gt;CPU는 프로그램 명령어를 클럭에 따라 일정한 주기를 반복하여 실행하는데, 이 주기를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 CPU가 하나의 명령어를 실행하는 데 필요한 전체 처리 과정으로서, CPU가 프로그램을 실행한 순간부터 전원을 끄거나 오류가 발생하여 프로그램이 중단될 때까지 반복됩니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 주 기억 장치로부터 명령어를 읽어오는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출 사이클(Fetch Cycle)&lt;/code&gt;과 명령어를 실행하는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행 사이클(Execution Cycle)&lt;/code&gt;로 분리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img079.png&quot; alt=&quot;img079&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인출-사이클fetch-cycle&quot;&gt;인출 사이클(Fetch Cycle)&lt;/h2&gt;

&lt;p&gt;인출 사이클의 진행은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img080.png&quot; alt=&quot;img080&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- PC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR], PC &amp;lt;- PC + 1&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : IR &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 프로그램 카운터(PC)에 저장된 명령어 주소를 CPU 내부 버스를 통해 메모리 주소 레지스터(MAR)로 보냅니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 명령어를 읽어서 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)에 저장합니다. 동시에 프로그램 카운터가 1 증가합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 명령어를 명령어 레지스터(IR)에 저장합니다.&lt;/p&gt;

&lt;h2 id=&quot;실행-사이클execution-cycle&quot;&gt;실행 사이클(Execution Cycle)&lt;/h2&gt;

&lt;p&gt;실행 사이클 동안에는 CPU가 명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산들을 수행합니다. CPU가 수행하는 연산에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 이동&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 처리&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 저장&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 제어&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;명령어는 연산 코드(Operation Code)와 오퍼랜드(operand)로 구성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img081.png&quot; alt=&quot;img081&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 사이클에서 수행되는 마이크로 연산들은 명령어의 연산 코드에 의해 결정되며, 명령어 실행에 필요한 데이터가 저장된 주소는 오퍼랜드에 의해 결정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-이동-load-addr-명령어&quot;&gt;데이터 이동: Load addr 명령어&lt;/h3&gt;

&lt;p&gt;Load ddr 명령어은 기억장치에 저장되어 있는 데이터를 CPU 내부 누산기(AC)에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 데이터를 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-저장-sta-addr-명령어&quot;&gt;데이터 저장: STA addr 명령어&lt;/h3&gt;

&lt;p&gt;STA addr 명령어은 누산기(AC)에 저장된 데이터를 기억장치에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- AC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : M[MAR] &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 누산기(AC)에 저장된 데이터를 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 MAR가 지정하는 기억장치 주소에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-처리-add-addr-명령어&quot;&gt;데이터 처리: ADD addr 명령어&lt;/h3&gt;

&lt;p&gt;ADD addr 명령어은 기억장치에 저장된 데이터를 누산기(AC)에 저장된 값에 더하여 그 결과를 다시 누산기에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img082.png&quot; alt=&quot;img082&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- AC + MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 저장할 데이터를 MAR가 지정하는 기억장치 주소로부터 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 산술논리연산장치(ALU)에서 연산하여 그 결과값을 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로그램-제어-jump-addr-명령어&quot;&gt;프로그램 제어: JUMP addr 명령어&lt;/h3&gt;

&lt;p&gt;JUMP addr 명령어은 오퍼랜드가 가리키는 주소의 명령어로 실행 순서를 변경하는 분기(branch) 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : PC &amp;lt;- IR(addr)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어 레지스터(IR)에 저장된 오퍼랜드를 PC에 저장하여 명령어 순서를 변경합니다.&lt;/p&gt;

&lt;h1 id=&quot;인터럽트interrupt&quot;&gt;인터럽트(Interrupt)&lt;/h1&gt;

&lt;p&gt;인터럽트는 컴퓨터 내부나 외부에서 발생하는 갑작스러운 사건에 대응하는 기능입니다. 인터럽트 요청이 발생하면 CPU는 현재 처리 순서를 중단하고 요구된 인터럽트 서비스 프로그램을 먼저 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img083.png&quot; alt=&quot;img083&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 그림처럼 명령어 사이클은 인출(fetch)과 실행(execution) 사이클이 반복되는데, 실행 사이클이 끝날때마다 CPU는 반복적으로 인터럽트 요청이 발생했는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img084.png&quot; alt=&quot;img084&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 요청이 발생했다면 프로그램 실행을 중단하고 인터럽트 처리를 합니다. 인터럽트 요청을 처리한 이후에는 다시 프로그램을 재실행합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h2&gt;

&lt;p&gt;인터럽트는 크게 내부 인터럽트와 외부 인터럽트로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;내부 인터럽트&lt;/code&gt;는 다음과 같은 상황에서 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 하드웨어 고장&lt;/strong&gt; : 정전, 패리티 비터 오류 등&lt;br /&gt;
&lt;strong&gt;2. 실행할 수 없는 명령어&lt;/strong&gt; : 정의되지 않은 명령어&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행 오류&lt;/strong&gt; : 0으로 나눈 경우&lt;br /&gt;
&lt;strong&gt;4. 사용 권한 위배&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주로 긴급한 상황에 발생하기 때문에 상태 레지스터의 인터럽트 플래그를 통한 제어가 불가능합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외부 인터럽트&lt;/code&gt;는 주로 입출력 장치에 의해 발생하며, 여기에는 타이머 인터럽트와 입출력 인터럽트가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 타이머 인터럽트&lt;/strong&gt; : 일정한 시간 간격으로 CPU에게 인터럽트를 요청합니다.&lt;br /&gt;
&lt;strong&gt;2. 입출력 인터럽트&lt;/strong&gt; : 속도가 비교적 느린 입출력장치의 사용 준비가 완료되었음을 알리기 위해 인터럽트를 요청합니다.&lt;/p&gt;

&lt;p&gt;외부 인터럽트는 인터럽트 플래그를 통해 제어할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-처리-순서&quot;&gt;인터럽트 처리 순서&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img087.png&quot; alt=&quot;img087&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 입출력장치에서 CPU에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 요청 신호(Interrupt Request, INTR)&lt;/code&gt;를 보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img085.png&quot; alt=&quot;img085&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; CPU는 실행 사이클을 끝내고 인터럽트 요청신호를 확인합니다. 인터럽트 요청을 확인 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 가능 플래그(Interrupt Enable Flag, IE)&lt;/code&gt;를 통해 현재 인터럽트를 받아들일 수 있는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img086.png&quot; alt=&quot;img086&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 인터럽트를 받아들일 수 있다면 현재 실행하던 프로그램을 중단하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC(Program Counter)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SR(Status Register)&lt;/code&gt;를 스택에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 벡터(Interrupt Vector)&lt;/code&gt;를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 서비스 루틴(Interrupt Service Routine, ISR)&lt;/code&gt;을 실행합니다.&lt;/p&gt;

&lt;p&gt;ISR는 인터럽트가 발생한 경우 인터럽트를 처리하기 위한 프로그램으로, 일반적으로 메모리에 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; ISR 실행이 끝나면 스택에 저장한 PC와 SR값을 복구하여 프래그램 실행을 재개합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 사이클(Instruction Cycle)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">레지스터와 카운터</title>
      <link href="https://huimang2.github.io/etc/computer-register-and-counter" rel="alternate" type="text/html" title="레지스터와 카운터" />
      <published>2023-05-19T01:00:00+09:00</published>
      <updated>2023-05-19T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-register-and-counter</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-register-and-counter">&lt;h1 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h1&gt;

&lt;p&gt;레지스터는 여러 비트를 저장하는 기억 소자입니다. 일반적으로 D 플립플롭으로 구성되어 있으며, 하나의 플립플롭은 1비트를 구성합니다. 즉, 8개의 플립플롭은 8비트, 16개의 플립플롭은 16비트 레지스터가 됩니다.&lt;/p&gt;

&lt;p&gt;레지스터는 주로 CPU 내부에서 연산결과를 중간저장하거나 데이터를 선택할 때 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;로드load-신호&quot;&gt;로드(Load) 신호&lt;/h2&gt;

&lt;p&gt;로드 신호는 레지스터를 동작시키는 신호입니다. 레지스터에 저장된 데이터를 입력값으로 변경시키는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img067.png&quot; alt=&quot;img067&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ClrN 신호는 비동기 카운터로 우선은 무시하시면 됩니다.&lt;/p&gt;

&lt;p&gt;로드(Load)는 클럭(Clk)과 AND 게이트로 연결하여 로드가 1일때 클럭 신호에 따라 레지스터 값을 변경할 수 있습니다. 그러나 클럭 신호가 다른 신호와 묶이는 경우 타이밍 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위해서 다음과 같이 레지스터의 CE(Clock Enable)에 로드를 연결하여 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img068.png&quot; alt=&quot;img068&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로드가 0인 경우 클럭 신호와 상관없이 레지스터에 저장된 데이터는 이전 상태를 유지하게 되며, 로드가 1인 경우 클럭 신호에 따라 레지스터의 데이터가 입력값으로 변경됩니다.&lt;/p&gt;

&lt;h2 id=&quot;쉬프트-레지스터shift-register&quot;&gt;쉬프트 레지스터(Shift Register)&lt;/h2&gt;

&lt;p&gt;쉬프트 레지스터는 플립플롭에 출력과 입력을 연결하는 방법에 따라 데이터를 왼쪽 또는 오른쪽으로 자리이동하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;쉬프트 레지스터의 종류는 직렬 쉬프트 레지스터와 병렬 쉬프트 레지스터가 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;직렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 입력(Serial in, SI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 출력(Serial out, SO)&lt;/code&gt;을 가지는 레지스터로, 데이터가 한 번에 한 비트씩 쉬프트 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img069.png&quot; alt=&quot;img069&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Shift 신호는 CE와 연결되며, 신호가 1인 경우 쉬프트 레지스터가 동작하며, 신호가 0인 경우 데이터가 쉬프트 되지 않고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 초기 레지스터 값이 0101이고 직렬 입력(SI)이 1101인 경우 타이밍도는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img070.png&quot; alt=&quot;img070&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 번의 클럭 주기마다 데이터가 쉬프트 됨을 확인 할 수 있습니다. 또한 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되는데, 4번의 클럭 주기동안 SO는 초기 레지스터 값인 0101이 출력됨을 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;병렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 입력(Parallel in, PI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 출력(Parallel out, PO)&lt;/code&gt;을 가지는 레지스터 이며, 다음과 같이 플립플롭과 멀티플렉서(MUX)를 통해 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img071.png&quot; alt=&quot;img071&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직렬 쉬프트 레지스터와 달리 한 클럭에 모든 데이터가 동시에 로드되고 동시에 출력됩니다. 이때 쉬프트 신호와 로드 신호가 멀티플렉서의 제어신호가 됩니다.&lt;/p&gt;

&lt;p&gt;쉬프트 신호가 1인 경우 로드 신호에 상관없이 데이터가 쉬프트되며, 쉬프트 신호가 0, 로드 신호가 1이면 레지스터에 데이터가 저장됩니다. 두 신호가 모두 0인 경우에는 레지스터 상태가 유지됩니다.&lt;/p&gt;

&lt;p&gt;위에 그림과 같이 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되므로 병렬 데이터를 직렬 데이터로 변환하기 위해 해당 레지스터를 사용할 수도 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h1&gt;

&lt;p&gt;카운터는 고정된 순환 회로를 통해 클럭 펄스의 갯수를 처리하기 위한 논리회로입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 2진수 값이 1씩 증가하는 2진 카운터가 있으며, n비트의 레지스터를 통해 2&lt;sup&gt;n&lt;/sup&gt;-1 까지 카운트할 수 있습니다. 예를 들어 3비트의 레지스터를 통해서는 0 ~ 7까지 카운트 할 수 있으며 다음과 같이 순환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img072.png&quot; alt=&quot;img072&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카운터에는 동기식 카운터와 비동기식 카운터가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비동기식-카운터&quot;&gt;비동기식 카운터&lt;/h2&gt;

&lt;p&gt;리플 카운터라고도 불리는 비동기식 카운터는 이전 플립플롭의 출력이 다음 플립플롭의 클럭으로 사용되는 카운터 입니다.&lt;/p&gt;

&lt;p&gt;보통 J-K 플립플롭 또는 T 플립플롭으로 설계되며, 숫자가 증가하는 상향 카운터(Up Counter)와 숫자가 감소하는 하향 카운터(Down Counter)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img074.png&quot; alt=&quot;img074&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 카운터는 카운트가 1씩 증가하는 상향 카운터이며, 다음과 같은 타이밍도로 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img073.png&quot; alt=&quot;img073&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Enable이 1인 경우 진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Clock 주기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10진수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;하향 카운터의 경우 Q’ 출력을 클럭으로 사용하며, 카운트가 1씩 감소합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img075.png&quot; alt=&quot;img075&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티플렉서를 통해 상하향 카운터를 만들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img076.png&quot; alt=&quot;img076&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비동기식 카운터는 동기식 카운터에 비해 회로는 간단하지만 전달지연이 커진다는 단점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;동기식-카운터&quot;&gt;동기식 카운터&lt;/h2&gt;

&lt;p&gt;동기식 카운터는 비동기식 카운터의 전달지연을 보완하기 위해 플립플롭에 공통의 클럭신호를 사용하는 카운터입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img077.png&quot; alt=&quot;img077&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 플립플롭은 동일한 클럭신호를 받으며, 이전 플립플롭의 출력이 1인 경우에만 다음 플립플롭이 토글됩니다.&lt;/p&gt;

&lt;h2 id=&quot;링-카운터&quot;&gt;링 카운터&lt;/h2&gt;

&lt;p&gt;링 카운터는 마지막 플립플롭의 출력이 첫 번째 플립플롭의 입력으로 피드백되는 링 형태로 구성된 카운터를 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img078.png&quot; alt=&quot;img078&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링카운터는 모든 플립플롭이 0이라면 000만 출력되기 때문에 최소한 1비트는 1로 프리셋할 필요가 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">레지스터(Register)</summary>
      

      
      
    </entry>
  
</feed>
