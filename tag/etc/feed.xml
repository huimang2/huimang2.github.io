<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://huimang2.github.io/tag/etc/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://huimang2.github.io/" rel="alternate" type="text/html" />
  <updated>2023-04-25T04:12:11+09:00</updated>
  <id>https://huimang2.github.io/tag/etc/feed.xml</id>

  
  
  

  
    <title type="html">Rubisco’s Programming Note | </title>
  

  
    <subtitle>프로그래밍 노트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">데이터의 표현</title>
      <link href="https://huimang2.github.io/etc/computer-logical" rel="alternate" type="text/html" title="데이터의 표현" />
      <published>2023-04-23T01:00:00+09:00</published>
      <updated>2023-04-23T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-logical</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-logical">&lt;p&gt;지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;정보의-단위&quot;&gt;정보의 단위&lt;/h1&gt;

&lt;p&gt;컴퓨터는 MOSFET을 통해 전류가 흐르거나 흐르지 않는 상태를 인식할 수 있습니다. 전류가 흐르면 1, 전류가 흐르지 않는다면 0으로 나타낼 수 있는데, 이렇게 0과 1을 표현하는 가장 작은 정보 단위를 비트(bit)라고 합니다.&lt;/p&gt;

&lt;p&gt;1비트를 통해서는 2가지 정보를 알 수 있으며, 2비트로는 (0, 0), (0, 1), (1, 0), (1, 1) 이렇게 4가지 정보를 알 수 있습니다. n비트를 통해서는 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/strong&gt;가지 정보를 표현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로그램은 수많은 비트로 이루어져 있어서 비트 단위로 데이터를 나타내기 힘들기 때문에, 데이터는 8개의 비트를 묶어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바이트(byte)&lt;/code&gt;를 정보의 기본단위로 사용합니다. 즉, 1byte는 8bit에 해당하며, 2&lt;sup&gt;8&lt;/sup&gt; = 256가지의 정보를 나타낼 수 있습니다. 보통 1byte로는 하나의 문자를 나타낼 수 있지만, 한글이나 한자 등 동양권 문자의 경우 1byte로 나타낼 수 없어서 하나의 문자당 2byte를 사용합니다.&lt;/p&gt;

&lt;p&gt;8bit가 모여 1byte가 된 것처럼, byte는 1000개씩 묶어 더 큰 단위를 나타낼 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;데이터-단위&quot;&gt;데이터 단위&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단위&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트(bit)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0, 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;바이트(Byte)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8 bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;킬로바이트(KB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메가바이트(MB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 KB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기가바이트(GB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;테라바이트(TB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페타바이트(PB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 TB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 외에도 CPU가 한 번에 처리할 수 있는 정보의 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;워드(word)&lt;/code&gt;로 나타냅니다.&lt;/p&gt;

&lt;h1 id=&quot;이진법&quot;&gt;이진법&lt;/h1&gt;

&lt;p&gt;컴퓨터는 0과 1을 사용하는 2진법(binary)을 통해 데이터를 이해합니다. 2진법은 자릿값이 올라감에 따라 그 크기가 2배씩 커지게 되므로 2진법을 십진법으로 바꾸기 위해서는 자릿수마다 2&lt;sup&gt;n&lt;/sup&gt;을 곱한 값을 모두 더하면 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어 이진수 0b1101을 십진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b1101 = 1 * 2&lt;sup&gt;3&lt;/sup&gt; + 1 * 2&lt;sup&gt;2&lt;/sup&gt; + 0 * 2&lt;sup&gt;1&lt;/sup&gt; + 1 * 2&lt;sup&gt;0&lt;/sup&gt; = 8 + 4 + 1 = 13&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴퓨터가 이진수로 음수를 표현하는 방법은 3가지가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;부호-비트와-절댓값-방법&quot;&gt;부호 비트와 절댓값 방법&lt;/h2&gt;

&lt;p&gt;2진법으로 수를 표현할 때, 가장 왼쪽에 있는 비트의 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위 비트(Most Significant Bit, MSB)&lt;/code&gt;라고 합니다. 부호 비트와 절댓값 방법은 최상위 비트를 이용하여 음수를 표현합니다.&lt;/p&gt;

&lt;p&gt;예를 정수 13의 경우 다음과 같이 2진법으로 나타낼 수 있습니다.(보통 정수 자료형은 4byte의 크기를 가집니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 -13으로 나타내기 위해서는 최상위 비트를 1로 바꾸면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 1비트가 부호를 표현하기 위해 사용되어 표현할 수 있는 절대값의 범위는 절반으로 줄어들게 됩니다. (0 ~ 2&lt;sup&gt;16&lt;/sup&gt; - 1)&lt;/p&gt;

&lt;p&gt;또한 +0과 -0이 따로 존재하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;1의-보수법&quot;&gt;1의 보수법&lt;/h2&gt;

&lt;p&gt;1의 보수법은 비트를 반전시켜 음수를 표현하는 방법입니다. 이 방법을 사용하면 비트의 NOT 연산만으로도 음수를 표현할 수 있어서 연산이 간단해집니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법을 통해 연산을 하는 데 있어서 캐리(carry)가 중요합니다. 캐리는 상태 레지스터의 플래그를 설명할 때 언급한 적이 있는데, 올림수나 빌림수 여부를 나타냅니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;캐리를 최하위 비트에 더해주면 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b0111 + 0b0001 = 0b1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 2진수는 10진수로 나타내면 8이 되며, 이는 13 - 5와 동일한 결과입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 1의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법은 부호 비트와 절댓값 방법과 마찬가지로 +0과 -0이 따로 존재한다는 문제점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2의-보수법&quot;&gt;2의 보수법&lt;/h2&gt;

&lt;p&gt;2의 보수법은 1의 보수법을 통해 표현한 값에 1을 더하여 음수를 표현하는 방법입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2의 보수법을 통해 연산을 하는 데 있어서 1의 보수법과 달리 캐리가 발생하면 캐리를 버립니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법과 달리 캐리를 버린 값이 최종 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 2의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 -0은 2의 보수를 구하는 과정에서 최상위 비트를 초과한 오버플로우가 발생하여 +0이 됩니다. 그러므로 2의 보수법에서는 하나의 0만 존재하게 됩니다. 때문에 현재 대부분의 시스템에서는 2의 보수법을 사용하여 음수를 표현합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CPU의 작동 원리</title>
      <link href="https://huimang2.github.io/etc/computer-cpu" rel="alternate" type="text/html" title="CPU의 작동 원리" />
      <published>2023-04-22T01:00:00+09:00</published>
      <updated>2023-04-22T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-cpu</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-cpu">&lt;p&gt;CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img003.png&quot; alt=&quot;img003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원자는 최외각 전자가 8개일 때 가장 안정적인 구조를 가지게 되므로 순수한 실리콘의 경우 전자가 이동하지 않으므로 전류가 흐를 수 없습니다. 그러므로 최외각 전자가 3개이거나 5개인 원소를 첨가하여 전류가 흐를 수 있는 상태로 만들게 되는데, 이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도핑(Doping)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;붕소(B)와 같이 최외각 전자가 3개인 원소를 첨가하게 되면 빈 자리가 생기게 되는데, 이를 양공이라고 합니다. 공유결합하고 있는 최외각 전자가 양공으로 이동하면서 전류가 흐를 수 있으며, 해당 반도체를 P형 반도체라고 합니다.&lt;/p&gt;

&lt;p&gt;인(P)과 같이 최외각 전자가 5개인 원소를 첨가하게 되면 자유전자가 1개 늘어 전류가 흐를 수 있으며, 해당 반도체는 N형 반도체라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img004.png&quot; alt=&quot;img004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 반도체는 전기적으로 중성상태에 있습니다. 두 반도체를 서로 연결한다면 N형 반도체의 자유전자가 P형 반도체의 양공으로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;N형 반도체는 상대적으로 자유전자를 빼앗겨 (+)전하를 가지게 되고, P형 반도체는 상대적으로 자유전자를 얻으면서 (-)전하를 가지게 되면서 전기장이 형성됩니다.&lt;/p&gt;

&lt;p&gt;어느정도 이동하다가 P형 반도체의 전자 반발력으로 인해 자유전자가 양공으로 이동하지 못하게 되는데, 이때 양공이 채워져 더이상 전자가 이동할 수 없는 영역을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공핍영역&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img005.png&quot; alt=&quot;img005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 건전지의 (+)극을 N형 반도체에 연결하고 (-)극을 P형 반도체에 연결한다면 공핍영역이 넓어져 전자가 이동할 수
없습니다. 이것을 역방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img006.png&quot; alt=&quot;img006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 반대로 연결한다면 공핍영역의 전기장을 극복하고 전자가 P형 반도체에서 N형 반도체로 이동하면서 전류가 흐를 수 있게 됩니다. 이것은 순방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img007.png&quot; alt=&quot;img007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 순방향으로 연결할 때만 전류가 흐를 수 있으며, 이때 전류의 방향은 P형 반도체에서 N형 반도체로 흐릅니다. 즉, 전류를 한방향으로 흐를 수 있게 하는데, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다이오드(Diode)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img008.png&quot; alt=&quot;img008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여담으로 전자가 공핍영역을 지날 때 빛으로 에너지를 발산하기도 하는데, 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;발광 다이오드(Light Emitting Diode)&lt;/code&gt; 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LED&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img009.png&quot; alt=&quot;img009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 2개의 P형 반도체 사이에 N형 반도체를 연결하여 건전지를 각각 순방향과 역방향으로 연결해 보겠습니다. 이 경우 순방향으로 연결된 회로에만 전류가 흐릅니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img010.png&quot; alt=&quot;img010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 순방향 회로의 전압을 높여준다면 공핍영역에 의한 전자 반발력보다 건전지에 의한 양전하의 반발력이 더 커지면서 역방향 회로를 통해서도 전류가 흐를 수 있게 됩니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img011.png&quot; alt=&quot;img011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역방향 회로에 전압을 더 높여준다면 더 많은 전자가 공핍영역을 통과할 수 있으므로 더 많은 전류가 흐르도록 할 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img012.png&quot; alt=&quot;img012&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 전압을 높이거나 낮추어 전류의 흐름을 제어하는 장치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜지스터(Transistor)&lt;/code&gt;라고 합니다. 트랜지스터는 위와 같은 PNP 트랜지스터와 NPN 트랜지스터가 있습니다.&lt;/p&gt;

&lt;p&gt;CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOSFET&lt;/code&gt;이라는 0.1nm 크기의 트랜지스터로 구성되어 있습니다. MOSFET은 금속(Metal)과 반도체(Semiconductor) 사이에 부도체인 산화막(Oxide)이 들어있는 적층 구조로 되어 있습니다. 이 구조를 MOS 구조라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img019.png&quot; alt=&quot;img019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반도체 기판이 N형이면 NMOS, P형이면 PMOS라고 부르며, 산화물인 SiO2로는 전류가 흐르지 않습니다. 아래와 같이 건전지를 연결해보겠습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img020.png&quot; alt=&quot;img020&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 오른쪽 회로가 역방향으로 연결되었기 때문에 전류가 흐르지 않습니다. 이번에는 가운데 금속에 전압을 걸어봅시다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img021.png&quot; alt=&quot;img021&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 산화물에 의하여 전류는 흐르지 않지만 위에서 아래로 전기장이 걸리면서 전자가 산화물 아래에 모이게 됩니다. 이 전자들이 N형 반도체를 이어주는 통로가 되어 전류가 흐르게 됩니다.&lt;/p&gt;

&lt;p&gt;즉, MOSFET이란 MOS의 전계 효과(Field Efect)를 활용한 트랜지스터(Transistor)입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컴퓨터의 구조</title>
      <link href="https://huimang2.github.io/etc/computer-architecture" rel="alternate" type="text/html" title="컴퓨터의 구조" />
      <published>2023-04-21T01:00:00+09:00</published>
      <updated>2023-04-21T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-architecture</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-architecture">&lt;h1 id=&quot;중앙처리장치cpu&quot;&gt;중앙처리장치(CPU)&lt;/h1&gt;

&lt;p&gt;CPU는 컴퓨터에서 기억, 해석, 연산, 제어라는 4가지의 주요 기능을 담당하는 장치입니다.&lt;/p&gt;

&lt;p&gt;컴퓨터의 대뇌에 해당하며, 프로그램의 명령어를 해석하여 데이터를 연산 및 처리함으로써 컴퓨터의 각 장치들을 제어합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img001.png&quot; alt=&quot;img001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터&lt;/code&gt; 3가지로 구성되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;산술논리장치&quot;&gt;산술논리장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치(Arithmetic and Logical Unit, ALU)&lt;/code&gt;는 덧셈과 뺄셈 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술연산&lt;/code&gt;과 논리합, 논리곱, 배타적 논리합과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리연산&lt;/code&gt;을 계산하는 디지털 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img013.png&quot; alt=&quot;img013&quot; /&gt;&lt;/p&gt;

&lt;p&gt;산술논리장치는 논리합을 계산하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가산기(adder)&lt;/code&gt;, 보수값을 출력하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보수기(complementer)&lt;/code&gt;, 산술 및 논리 연산의 결과를 일시적으로 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;누산기(accumulator)&lt;/code&gt;, 명령어를 수행하기 위해 필요한 데이터를 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터(data register)&lt;/code&gt; 등으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;산술논리장치가 수행하는 마이크로 연산은 다음과 같이 분류할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;산술-연산&quot;&gt;산술 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ADD&lt;/td&gt;
      &lt;td&gt;X ← A + B&lt;/td&gt;
      &lt;td&gt;A와 B를 더합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUB&lt;/td&gt;
      &lt;td&gt;X ← A + (~B + 1)&lt;/td&gt;
      &lt;td&gt;A에 B를 뺍니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MUL&lt;/td&gt;
      &lt;td&gt;X ← A × B&lt;/td&gt;
      &lt;td&gt;A와 B를 곱합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIV&lt;/td&gt;
      &lt;td&gt;X ← A ÷ B&lt;/td&gt;
      &lt;td&gt;A를 B로 나눕니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INC&lt;/td&gt;
      &lt;td&gt;X ← A + 1&lt;/td&gt;
      &lt;td&gt;A를 1 증가 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DEC&lt;/td&gt;
      &lt;td&gt;X ← A - 1&lt;/td&gt;
      &lt;td&gt;A를 1 감소 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NEG&lt;/td&gt;
      &lt;td&gt;X ← ~A + 1&lt;/td&gt;
      &lt;td&gt;A의 음수값을 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h6 id=&quot;논리-연산&quot;&gt;논리 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AND&lt;/td&gt;
      &lt;td&gt;X ← A &amp;amp; B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 AND 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;X ← A | B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 OR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NOT&lt;/td&gt;
      &lt;td&gt;X ← ~A&lt;/td&gt;
      &lt;td&gt;A의 보수를 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XOR&lt;/td&gt;
      &lt;td&gt;X ← A ^ B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 XOR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASR&lt;/td&gt;
      &lt;td&gt;X ← A » n, A[7] ← A[7]&lt;/td&gt;
      &lt;td&gt;부호를 유지시킨 채 A를 오른쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSR&lt;/td&gt;
      &lt;td&gt;X ← A » n&lt;/td&gt;
      &lt;td&gt;A를 오른쪽으로쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROL&lt;/td&gt;
      &lt;td&gt;X ← A « 1, A[0] ← A[7]&lt;/td&gt;
      &lt;td&gt;첫 번째 비트를 마지막 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROR&lt;/td&gt;
      &lt;td&gt;X ← A » 1, A[7] ← A[0]&lt;/td&gt;
      &lt;td&gt;마지막 비트를 첫 번째 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;산술논리장치는 제어장치로부터 전달받은 제어신호를 통해 두 데이터 레지스터의 값을 연산하여 결과값을 누산기에 저장합니다. 이때 연산 결과에 대한 부가정보를 상태 레지스터에 저장합니다. 상태 레지스터의 구조는 CPU마다 다를 수 있으며, 상태 레지스터에 저장되는 플래그의 종류는 다음과 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;상태-레지스터-플래그&quot;&gt;상태 레지스터 플래그&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;플래그 종류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;부호&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부호 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td&gt;연산 결과의 부호를 나타냅니다. 1이면 음수, 0이면 양수임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제로 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td&gt;연산 결과가 0인지 여부를 나타냅니다. 1이면 0, 0이면 0이 아님을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;캐리 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td&gt;연산 결과에서 올림수나 빌림수가 발생했는지를 나타냅니다. 1이면 올림수나 빌림수가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;오버플로우 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;연산 과정에서 오버플로우가 발생했는지를 나타냅니다. 1이면 오버플로우가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터럽트 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td&gt;인터럽트가 가능한지를 나타냅니다. 1이면 인터럽트가 가능함을, 0이면 불가능함을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;슈퍼바이저 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P&lt;/td&gt;
      &lt;td&gt;커널모드로 실행중인지 사용자모드로 실행중인지를 나타냅니다. 1이면 커널모드, 0이면 사용자모드임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;제어장치&quot;&gt;제어장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치(Control Unit, CU)&lt;/code&gt;는 입출력장치 간 통신 및 조율을 제어하는 제어 신호를 보내고, 명령어를 읽고 해석하여 데이터 처리의 순서를 결정하는 장치입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img014.png&quot; alt=&quot;img014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어장치는 클럭(Clock), 명령어, 상태 플래그, 제어신호를 받아들이고, CPU 내부의 ALU나 레지스터 또는 CPU 외부의 제어버스로 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클럭(clock)&lt;/code&gt;이란 컴퓨터 부품을 움직이게 할 수 있는 시간 단위입니다. 클럭은 1과 0이 반복되어 나타나는데, 이 반복의 기본 단위를 클럭의 주기(period)라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img015.png&quot; alt=&quot;img015&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1초동안 반복되는 주기의 횟수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주파수(frequency)&lt;/code&gt;라고 하며, 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;헤르츠(Hz)&lt;/code&gt;를 사용합니다. 인텔 코어 i5를 기준으로 기본 클럭이 2.4GHz 이며, 이것은 1초에 2.4 × 10^9번의 주기가 반복됨을 의미합니다. 그러므로 오버클럭을 하게 되면 주기가 증가하여 CPU의 처리속도를 증가시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;정리하면, 제어장치는 클럭에 맞추어 명령어 레지스터로부터 해석할 명령어를 가져와서 적절한 제어신호를 내보냅니다.&lt;/p&gt;

&lt;h2 id=&quot;레지스터&quot;&gt;레지스터&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터(register)&lt;/code&gt;는 CPU 내부의 작은 임시 저장장치 입니다. 프로그램 속의 명령어와 데이터는 프로그램 실행 전/후로 레지스터에 저장됩니다. CPU 내부에는 다양한 레지스터가 존재하며, 각기 다른 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. 프로그램 카운터(Program Counter, PC)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램 카운터는 메모리에서 읽어들일 명령어의 주소를 저장합니다. 프로그램을 순차적으로 처리하기 위해 프로그램의 순서를 카운트하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 포인터(Instruction Pointer, IP)&lt;/code&gt;라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 명령어 레지스터(Instruction Register, IR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어 레지스터는 메모리에서 읽어들인 명령어를 저장하는 레지스터 입니다. 제어장치는 IR에 있는 명령어를 해석하여 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. 메모리 주소 레지스터(Memory Address Register, MAR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터 입니다. CPU가 읽고자 하는 주소 값을 주소 버스로 보내기 위해서는 MAR를 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 버퍼 레지스터는 메모리와 주고 받을 값을 저장하는 레지스터 입니다. 메모리에 값을 쓰기 위해서는 MBR을 거쳐야 하며, 메모리의 데이터 버스를 통해 값을 전달받을 때도 MBR을 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;5. 상태 레지스터(Status Register, SR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산 결과 또는 CPU의 상태에 대한 부가적인 정보를 저장하고 있는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;6. 작업 레지스터(Working Resister, WR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ALU와 직접 연결되어 있는 레지스터로, 연산 과정의 중간값이나 결과를 저장하는 누산기 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;7. 범용 레지스터(General Resister, GR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일반적인 상황에서 자유롭게 사용할 수 있는 레지스터로, 데이터와 주소를 모두 저장할 수 있습니다. ALU와는 연결되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;8. 스택 포인터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스택 포인터는 스택 주소 지정 방식에 사용되는 레지스터 입니다. 메모리 스택 영역의 꼭대기 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img016.png&quot; alt=&quot;img016&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;9. 베이스 레지스터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;베이스 레지스터는 프로그램 카운터와 함께 변위 주소 지정 방식에 사용되는 레지스터 입니다. 주소를 지정하기 위한 기준이 되는 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p&gt;변위 주소 지정 방식은 오퍼랜드의 필드값과 특정 레지스터 값을 더하여 유효 주소를 얻게 되는데, 오퍼랜더 값과 프로그램 카운터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대 주소 지정 방식&lt;/code&gt;, 오퍼랜더 값과 베이스 레지스터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변위 주소 지정 방식&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;메모리&quot;&gt;메모리&lt;/h1&gt;

&lt;p&gt;메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 장치입니다.&lt;/p&gt;

&lt;p&gt;메모리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 주소 레지스터(MAR)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 버퍼 레지스터(MBR)&lt;/code&gt;로 구성되며, CPU와 데이터를 주고 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 버스(system bus)&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;시스템 버스는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 버스(address bus)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 버스(data bus)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 버스(control bus)&lt;/code&gt;로 구성됩니다.&lt;/p&gt;

&lt;p&gt;메모리는 크게 읽기 전용 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM(Read Only Memory)&lt;/code&gt;과 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAM(Random Access Memory)&lt;/code&gt;, 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;플래시 메모리(Flash Memory)&lt;/code&gt;로 나눌 수 있으며, 통상적으로 메모리는 RAM을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;

&lt;p&gt;RAM의 종류는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDR SDRAM&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. DRAM(Dynamic RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRAM은 전원이 연결되어 있더라도 저장된 데이터가 동적으로 사라지는 RAM 입니다. 그렇기 때문에 데이터의 소멸을 막기 위해서는 주기적으로 저장된 데이터를 재활성화(refresh) 해야 합니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 낮고 저렴하며 집적도가 높아 대용량으로 설계하기 용이하기 때문에 일반적으로 메모리에 사용되는 RAM은 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. SRAM(Static RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SRAM은 전원이 연결되어 있다면 저장된 데이터가 사라지지 않는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 높고 가격이 비싸며 집적도가 낮기 때문에 일반적으로 대용량으로 설계할 필요가 없고 빨라야 하는 캐시 메모리에서 사용되는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. SDRAM(Synchronous RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SDRAM은 클럭 신호와 동기화되는 발전된 형태의 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. DDR SDRAM(Double Data Rate SDRAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 데이터를 주고 받는 대역폭을 넓혀 속도를 빠르게 만든 SDRAM 입니다. 최근 대중적으로 사용하는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 SDRAM 보다 대역폭이 두 배 넓다면, DDR2 SDRAM은 DDR SDRAM 보다 대역폭이 두 배 넓습니다. 즉, DDR2 SDRAM은 SDRAM 보다 대역폭이 네 배 넓습니다.&lt;/p&gt;

&lt;p&gt;동일하게 DDR3 SDRAM은 DDR2 SDRAM 보다 대역폭이 두 배 넓으며, DDR4 SDRAM은 DDR3 SDRAM 보다 대역폭이 두 배 넓습니다. 그러므로 DDR4 SDRAM 4G는 DDR3 SDRAM 8G와 속도가 동일합니다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-메모리&quot;&gt;캐시 메모리&lt;/h2&gt;

&lt;p&gt;캐시 메모리는 CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치 입니다. CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 사용합니다.&lt;/p&gt;

&lt;p&gt;캐시 메모리는 계층적으로 L1, L2, L3 캐시 메모리로 구성할 수 있으며, 일반적으로 L1 캐시와 L2 캐시는 CPU 내부에, L3 캐시는 CPU 외부에 위치합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img017.png&quot; alt=&quot;img017&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 프로세서의 경우 코어마다 L1, L2 캐시가 있기 때문에 데이터의 일관성을 유지하기 위해 캐시 메모리를 동기화 시키는 것이 중요합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img018.png&quot; alt=&quot;img018&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캐시 메모리는 메모리보다 용량이 작기 때문에 메모리의 일부 내용을 저장합니다. 그렇기 때문에 CPU가 자주 사용할 법한 내용을 예측하여 캐시 메모리에 저장합니다.&lt;/p&gt;

&lt;p&gt;CPU는 최근에 접근했던 메모리 공간에 다시 접근하려고 하며, 접근한 메모리 공간 근처를 접근하려는 경향이 있는데, 이러한 경향을 바탕으로 만들어진 원리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조 지역성의 원리&lt;/code&gt;라고 합니다. 이 원리를 바탕으로 캐시 메모리를 사용한다면 캐시 메모리의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;보조기억장치&quot;&gt;보조기억장치&lt;/h1&gt;

&lt;p&gt;보조기억장치는 현재 실행되지 않는 프로그램이나 데이터를 저장하고 있다가 필요한 경우 RAM으로 데이터를 전달하는 장치 입니다.&lt;/p&gt;

&lt;p&gt;메모리는 보조기억장치에 비하여 비쌀 뿐만 아니라 전원이 꺼지면 저장된 내용을 잃어버린다는 단점이 존재합니다. 그러므로 데이터를 영구적으로 저장하기 위해서는 보조 기억장치에 데이터를 저장해야 합니다.&lt;/p&gt;

&lt;p&gt;보조기억장치에는 하드디스크와 플래시 메모리가 있습니다. 하드디스크는 자기적인 방식으로 데이터를 저장하는 장치이며, 플래시 메모리는 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치입니다. 대표적으로 SSD가 플래시 메모리에 속합니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력장치&quot;&gt;입출력장치&lt;/h1&gt;

&lt;p&gt;입출력장치는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 장치입니다. 대표적인 입출력 장치로 키보드, 모니터, 마우스 등이 있습니다.&lt;/p&gt;

&lt;p&gt;컴퓨터로 데이터를 처리하기 위해서는 입력장치를 통해 컴퓨터로 데이터를 입력해야 하며, 컴퓨터가 처리한 결과의 데이터는 출력장치를 통해 사용자가 읽을 수 있는 형태로 돌려주어야 합니다.&lt;/p&gt;

&lt;p&gt;입력장치는 컴퓨터가 인식할 수 있는 형태로 변환시켜 메모리로 읽어 들이는 장치이고, 출력장치는 컴퓨터에서 처리된 내용을 사용자가 인식할 수 있는 형태로 바꾸어 표시하는 장치입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">중앙처리장치(CPU)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Oh My Zsh</title>
      <link href="https://huimang2.github.io/etc/oh-my-zsh" rel="alternate" type="text/html" title="Oh My Zsh" />
      <published>2023-01-07T18:00:00+09:00</published>
      <updated>2023-01-07T18:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/oh-my-zsh</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/oh-my-zsh">&lt;p&gt;이번 글에서는 우분투에 zsh Configuration 프레임워크인 Oh My Zsh를 설치해보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;커널kenel과-쉘shell&quot;&gt;커널(Kenel)과 쉘(Shell)&lt;/h1&gt;

&lt;p&gt;oh my zsh를 설치하기 전에 커널(Kernel)과 쉘(Shell)이 무엇인지 알 필요가 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/zsh/img001.png&quot; alt=&quot;img001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터는 크게 물리적인 형태를 가지고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하드웨어(HardWare)&lt;/code&gt;와 형태는 없지만 하드웨어를 동작시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소프트웨어(Software)&lt;/code&gt;로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;소프트웨어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제(Operating System, OS)&lt;/code&gt;와 운영체제 위에서 동작하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;응용 소프웨어(Application Software)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;운영체제는 하드웨어를 효율적으로 사용하기 위해 메모리나 CPU의 자원을 관리하고 여러 프로그램이 필요로 하는 공통적인 서비스를 제공하는 소프트웨어입니다. 리눅스(Linux), 윈도우(Windows), 맥OS(Mac OS)등이 운영체제에 해당합니다.&lt;/p&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kenel)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 소프트웨어(System Software)&lt;/code&gt;로 구분됩니다.&lt;/p&gt;

&lt;p&gt;커널은 운영체제의 핵심부로써, 하드웨어의 자원을 관리하는 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;커널의 경우 컴퓨터 자원만을 바라보고 있기 때문에 사용자 또는 응용 소프트웨어와 상호작용 않습니다. 그러므로 커널과 상호작용하기 위한 인터페이스가 필요한데, 이때 사용하는 시스템 소프트웨어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/zsh/img002.png&quot; alt=&quot;img002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 운영체제에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령 프롬프트(Command Prompt)&lt;/code&gt;가 쉘에 해당합니다.&lt;/p&gt;

&lt;h1 id=&quot;zsh와-oh-my-zsh&quot;&gt;zsh와 Oh My Zsh&lt;/h1&gt;

&lt;p&gt;리눅스는 표준 쉘로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bash&lt;/code&gt;를 사용합니다. BASH는 &lt;code class=&quot;language-plaintext bgcolor orange highlighter-rouge&quot; style=&quot;color:orangered&quot;&gt;Bourne-again shell&lt;/code&gt;의 약자로, 유닉스의 오리지날 쉘인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sh(Bourne Shell)&lt;/code&gt;을 기반으로 만들어졌습니다. 대표적인 리눅스 기반 GNU 운영체제인 우분투(Ubuntu) 역시 bash를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh&lt;/code&gt;는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 확장형 sh입니다. Mac OS 10.15 버전인 카탈리나부터는 기본 쉘로 zsh를 사용합니다.&lt;/p&gt;

&lt;p&gt;zsh는 커스텀이 비교적 자유로우며, 각종 테마나 플러그인의 추가/삭제가 가능합니다. 또한 경로를 자동으로 추론하거나 타이핑 교정, 명령어 추천 등 많은 기능을 포함합니다.&lt;/p&gt;

&lt;h6 id=&quot;경로-자동추론&quot;&gt;경로 자동추론&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img003.gif&quot; alt=&quot;img003&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/h/u/ws&lt;/code&gt;를 입력후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TAB&lt;/code&gt;키를 누르면 가장 비슷한 경로를 추론하여 자동완성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;타이핑-교정&quot;&gt;타이핑 교정&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img004.gif&quot; alt=&quot;img004&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;commit를 cmmit로 잘못입력했다면 이를 교정하여 commit를 입력할 것을 추천합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;명령어-추천&quot;&gt;명령어 추천&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img005.gif&quot; alt=&quot;img005&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git c&lt;/code&gt;를 입력후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TAB&lt;/code&gt;키를 누르면 c로 시작하는 명령어 옵션을 추천해줍니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Oh My Zsh&lt;/code&gt;는 zsh의 이러한 환경설정을 다루기위한 프레임워크입니다. 프레임워크 없는 zsh는 빈 껍데기에 불과하다고 보면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ohmyz.sh/&quot; target=&quot;_blank&quot;&gt;공식 홈페이지&lt;/a&gt;에 적힌 설명에 따르면 oh-my-zsh를 사용하면 카페에서 낮선 사람들이 다가와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;대단해! 너 천재야?&quot;&lt;/code&gt;라고 묻는다고 합니다 :)&lt;/p&gt;

&lt;p&gt;본격적으로 맥의 감성을 우분투에 반영해보겟습니다.&lt;/p&gt;

&lt;h1 id=&quot;oh-my-zsh-설치&quot;&gt;Oh My Zsh 설치&lt;/h1&gt;

&lt;h2 id=&quot;zsh-설치&quot;&gt;zsh 설치&lt;/h2&gt;

&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh&lt;/code&gt;를 설치해야합니다. apt를 통해 zsh를 설치해주도록 합시다.&lt;/p&gt;

&lt;h6 id=&quot;zsh-설치-1&quot;&gt;zsh 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img006.png&quot; alt=&quot;img006&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;oh-my-zsh-설치-1&quot;&gt;oh my zsh 설치&lt;/h2&gt;

&lt;p&gt;다음으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oh-my-zsh&lt;/code&gt;를 설치해주도록 합시다. curl이나 wget을 통해 sh 스크립트 파일을 다운받고 실행시키면 됩니다.&lt;/p&gt;

&lt;h6 id=&quot;curl을-통한-설치&quot;&gt;curl을 통한 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;wget을-통한-설치&quot;&gt;wget을 통한 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; -&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료되면 zsh를 기본 쉘로 변경할 것인지 묻는데, y를 입력하면 터미널이 실행될 때 기본쉘로 zsh를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img007.png&quot; alt=&quot;img007&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;테마-설정&quot;&gt;테마 설정&lt;/h2&gt;

&lt;p&gt;이제 테마를 설정하겠습니다. 테마는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.zshrc&lt;/code&gt; 파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZSH_THEME&lt;/code&gt;를 설정하여 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 해당 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;nano ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ZSH_THEME가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;robbyrussell&lt;/code&gt;로 입력되어 있습니다. 이 부분에 사용하고 싶은 테마를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;저는 국룰(?)인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;agnoster&lt;/code&gt; 테마를 사용하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img008.png&quot; alt=&quot;img008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + O&lt;/code&gt;를 눌러 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + X&lt;/code&gt;를 눌러 nano 에디터를 빠져나옵니다.&lt;/p&gt;

&lt;p&gt;설정된 테마를 적용하기 위해 .zshrc를 소싱합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img009.png&quot; alt=&quot;img009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 테마를 사용할 경우 폰트가 깨지는 문제가 발생할 수 있으므로, 이를 해결하기 위해 powerline 폰트를 설치합니다.&lt;/p&gt;

&lt;h6 id=&quot;powerline-폰트-설치&quot;&gt;powerline 폰트 설치&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;fonts-powerline
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img010.png&quot; alt=&quot;img010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다른 테마는 아래 페이지에서 확인이 가능합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&quot; target=&quot;_blank&quot;&gt;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;플러그인-설치&quot;&gt;플러그인 설치&lt;/h1&gt;

&lt;h2 id=&quot;syntax-hightlight&quot;&gt;syntax hightlight&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax hightlight&lt;/code&gt;는 말그대로 구문을 강조하는 플러그인 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GITHUB: &lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot; target=&quot;_blank&quot;&gt;https://github.com/zsh-users/zsh-syntax-highlighting&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bash의 경우 명령어와 옵션을 구분하지 않고 모두 흰색으로 입력됩니다.&lt;/p&gt;

&lt;h6 id=&quot;bash의-경우&quot;&gt;bash의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img017.png&quot; alt=&quot;img017&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zsh에 해당 플러그인을 설치한다면 구문이 강조되어 사용할 수 있는 명령어는 녹색으로, 사용할 수 없는 명령어는 빨간색으로, 옵션은 흰색으로 입력됩니다.&lt;/p&gt;

&lt;h6 id=&quot;사용할-수-있는-명령어의-경우&quot;&gt;사용할 수 있는 명령어의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img018.png&quot; alt=&quot;img018&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;사용할-수-없는-명령어의-경우&quot;&gt;사용할 수 없는 명령어의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img019.png&quot; alt=&quot;img019&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;oh-my-zsh에서 플러그인을 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.oh-my-zsh/custom/plugins&lt;/code&gt; 폴더에 플러그인을 다운받고 .zshrc 파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plugins&lt;/code&gt;를 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;우선 git를 통해 플러그인을 다운로드 받겠습니다. (git가 설치되어 있음을 전제로 합니다.)&lt;/p&gt;

&lt;h6 id=&quot;syntax-hightlight-플러그인-다운로드&quot;&gt;syntax hightlight 플러그인 다운로드&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/zsh-users/zsh-syntax-hightlighting.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img011.png&quot; alt=&quot;img011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집-1&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;nano ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처음에 plgins에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(git)&lt;/code&gt;가 설정되어 있습니다. 여기에 구분자를 스페이스로 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zsh-syntax-hightlight&lt;/code&gt;를 추가해주도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img012.png&quot; alt=&quot;img012&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + O&lt;/code&gt;를 눌러 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CTRL + X&lt;/code&gt;를 눌러 nano 에디터를 빠져나옵니다.&lt;/p&gt;

&lt;p&gt;.zshrc를 소싱하면 플러그인이 바로 적용됩니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱-1&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img013.png&quot; alt=&quot;img013&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;autosuggestions&quot;&gt;autosuggestions&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autosuggestions&lt;/code&gt;는 히스토리 기반으로 최근에 입력한 명령어를 미리보기 형태로 보여주는 플러그인 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GITHUB: &lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions&quot; target=&quot;_blank&quot;&gt;https://github.com/zsh-users/zsh-autosuggestions&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;autosuggestions-플러그인-적용&quot;&gt;autosuggestions 플러그인 적용&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img016.png&quot; alt=&quot;img016&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플러그인을 적용하기 위해서는 syntax highlighte 플러그인을 적용한 방식 그대로 설정하면 됩니다.&lt;/p&gt;

&lt;h6 id=&quot;autosuggestions-플러그인-다운로드&quot;&gt;autosuggestions 플러그인 다운로드&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/zsh-users/zsh-autosuggestions.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img014.png&quot; alt=&quot;img014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-파일-편집-2&quot;&gt;.zshrc 파일 편집&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img015.png&quot; alt=&quot;img015&quot; style=&quot;margin-top:-1.5em&quot; /&gt;&lt;/p&gt;

&lt;p&gt;.zshrc를 소싱하면 플러그인이 바로 적용됩니다.&lt;/p&gt;

&lt;h6 id=&quot;zshrc-소싱-2&quot;&gt;.zshrc 소싱&lt;/h6&gt;
&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zsh/img016.png&quot; alt=&quot;img016&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">이번 글에서는 우분투에 zsh Configuration 프레임워크인 Oh My Zsh를 설치해보도록 하겠습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">향상된 SSH 프로토콜 : Mosh</title>
      <link href="https://huimang2.github.io/etc/mosh" rel="alternate" type="text/html" title="향상된 SSH 프로토콜 : Mosh" />
      <published>2022-09-03T05:00:00+09:00</published>
      <updated>2022-09-03T05:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/mosh</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/mosh">&lt;h1 id=&quot;mosh란&quot;&gt;Mosh란?&lt;/h1&gt;

&lt;p&gt;Mosh는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mobile Shell&lt;/code&gt;의 약자로, 모바일 환경에서 원격 터미널을 원활하게 사용할 수 있도록 해주는 프로토콜입니다. 기존 SSH의 상위 호환 프로토콜이라고 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;SSH의 경우 TCP 프로토콜을 사용하기 때문에 세션으로 연결되어야만 통신이 가능합니다. 그렇기 때문에 모바일 환경과 같이 세션의 연결이 불안정한 네트워크의 경우 세션의 연결이 끊어지면 다시 세션을 연결하기 때문에 입출력의 지연이 발생하고, 시간내에 세션에 연결하지 못하면 기존에 구성해둔 작업환경을 다시 구성해야 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;반면에 Mosh는 UDP 프로토콜을 사용하여 세션의 연결상태를 지속할 필요가 없으며, 입출력을 따로 연결하고 세션의 상태를 보존하기때문에 명령에 대한 연결지연이 없습니다.&lt;/p&gt;

&lt;p&gt;하지만 UDP를 통해서 Mosh 서버에 직접적인 연결이 불가하여 SSH를 통해 간접적으로 접속해야 하며, 하나의 접속에 대하여 하나의 포트를 필요로 하기때문에 방화벽의 유지관리에 많은 비용이 들 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;mosh-설치&quot;&gt;Mosh 설치&lt;/h1&gt;

&lt;p&gt;Ubuntu 20.04 LTS 환경인 원격 서버에 Mosh를 설치하여 윈도우 환경에서 접속해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;우선 원격서버에 접속하고 apt를 업데이트 하세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;apt를 통해 mosh를 설치하세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mosh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mosh는 60000 ~ 61000번의 UDP 포트를 사용합니다. 우선 os 방화벽에서 해당포트를 열어주세요.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ufw allow 60000:61000/udp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원격서버에서도 포트를 열어야합니다. 이전에 작성한 &lt;a href=&quot;/etc/docker#방화벽-오픈open&quot; target=&quot;_blank&quot;&gt;도커(Docker) 설치하기&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;p&gt;윈도우에서 Mosh 프로토콜을 통해 통신하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cygwin&lt;/code&gt;을 설치하거나 크롬 브라우저에 extention을 설치하여 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;저는 크롬 브라우저에 &lt;a href=&quot;https://chrome.google.com/webstore/detail/mosh/ooiklbnjmhbcgemelgfhaeaocllobloj&quot; target=&quot;_blank&quot;&gt;extension&lt;/a&gt;을 설치하겠습니다.&lt;/p&gt;

&lt;p&gt;extionstion을 설치하면 Mosh app이 설치됩니다. 실행시키면 다음과 같은 화면이 뜹니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-01.png&quot; alt=&quot;img01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;os 유저이름과 ip주소, ssh 포트를 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Connect&lt;/code&gt;를 클릭하면 됩니다. 그전에 ssh key를 통해 접속하므로 비밀키를 입력해야합니다. 오른쪽에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add ssh key&lt;/code&gt;를 클릭하고, 비밀키를 메모장으로 열어서 키값을 복사하여 입력하세요.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-02.png&quot; alt=&quot;img02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Passphrase를 입력하라고 뜹니다.. 다음 명령어를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Passphrase&lt;/code&gt;를 설정합니다. 그냥 엔터를 입력하면 Passphrase 없이 비밀키만으로 접속가능합니다.&lt;/p&gt;

&lt;div data-lang=&quot;CMD&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;비밀키 경로] &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 비밀키를 복사하여 입력한후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Connect&lt;/code&gt;를 누르면 ssh를 통해 원격 서버에 접속되고 mosh 통신이 시작됩니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mosh/mosh-img-03.png&quot; alt=&quot;img03&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">Mosh란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">VSCode로 UML 그리기</title>
      <link href="https://huimang2.github.io/etc/plantuml" rel="alternate" type="text/html" title="VSCode로 UML 그리기" />
      <published>2022-08-10T06:00:00+09:00</published>
      <updated>2022-08-10T06:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/plantuml</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/plantuml">&lt;h1 id=&quot;plantuml&quot;&gt;PlantUML&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/plantUML.webp&quot; alt=&quot;logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클래스를 설계할 때 클래스 다이어그램(Class Diagram)을 그리게 됩니다. 클래스 다이어그램 뿐만 아니라 프로젝트의 문서를 작성한다면 시퀀스 다이어그램(Sequence Diagram), 유스케이스 다이어그램(Usecase Diagram) 등 다이어그램을 작성이 필요합니다.&lt;/p&gt;

&lt;p&gt;사용해 보지는 않았지만 UML을 그리는 대표적인 도구로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StarUML&lt;/code&gt;이 있습니다. 또한 인텔리제이(IntelliJ) 얼티메이트 에디션에는 자동으로 다이어그램을 그리는 플러그인이 포함되어 있습니다. 그러나 StarUML은 GUI를 통해 직접 UML을 그려야 하며, 인텔리제이의 경우 UML 기능이 유료입니다.&lt;/p&gt;

&lt;p&gt;인텔리제이의 기능만큼은 아니지만 자동으로 UML을 그려주는 도구가 있는데, 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PlantUML&lt;/code&gt;입니다. 간단한게 객체간의 관계를 정의해준다면 자동으로 UML을 생성해줍니다.&lt;/p&gt;

&lt;h1 id=&quot;설치&quot;&gt;설치&lt;/h1&gt;

&lt;p&gt;PlantUML은 &lt;a href=&quot;http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000&quot; target=&quot;_blank&quot;&gt;PlantUML Online Server&lt;/a&gt;를 제공하여 웹에서 UML을 만들 수 있지만 로컬에 설치하여 사용할 수도 있습니다. 간단하게는 apt를 통해 설치할 수 있습니다.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;plantuml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VSCode의 확장팩을 통해 설치할 수도 있습니다. VScode Extension에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plantuml&lt;/code&gt;을 검색하여 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/plantuml/plantuml-img01.png&quot; alt=&quot;logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작동을 위해서는 DOT 스크립트로 그래프를 그려주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;graphviz&lt;/code&gt;라는 도구가 필요합니다. apt를 통해 설치해주도록 합시다.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;graphviz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;준비는 되었습니다. 이제 관계를 정의해주면 자동으로 UML을 그릴 수 있습니다. 지원하는 파일 확장자는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;*.wsd, *.pu, *.puml, *.plantuml, *.iuml&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;uml-그리기&quot;&gt;UML 그리기&lt;/h1&gt;

&lt;p&gt;먼저 관계를 정의하기 위한 파일을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;testuml.wsd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 클래스의 관계를 정의해보겠습니다.&lt;/p&gt;

&lt;h6 id=&quot;testumlwsd&quot;&gt;testuml.wsd&lt;/h6&gt;
&lt;div data-lang=&quot;WSD&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@startuml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Subject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteSubject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Subject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Subject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;|..&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteSubject&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;|..&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverA&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;|..&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverB&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;|..&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverC&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ConcreteSubject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverA&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ConcreteSubject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverB&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ConcreteSubject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcreteObserverC&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@enduml&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 vscode에서 ctrl + shift + p를 눌러 팔레트를 열고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PlantUML: Export Current Diagram&lt;/code&gt;을 선택하고 이미지 포멧을 선택하면 자동으로 UML 이미지가 만들어집니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/plantuml/plantuml-img02.png&quot; alt=&quot;img02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래프 도구인 graphviz를 통해 그려서 depth가 구분됩니다. Observer와 Subject의 depth를 같도록 그려주고 싶은데 잘 찾아보면 방법이 있을듯 합니다.&lt;/p&gt;

&lt;p&gt;다르게 표현할 수 있을듯 한데 일단은 이런 형식으로 사용이 가능합니다.&lt;/p&gt;

&lt;p&gt;자세한 작성법은 &lt;a href=&quot;https://plantuml.com/ko/&quot; target=&quot;_blank&quot;&gt;PlantUML 문서(한글)&lt;/a&gt;를 참조하세요.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">PlantUML</summary>
      

      
      
    </entry>
  
</feed>
