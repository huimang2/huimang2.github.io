<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://huimang2.github.io/tag/design-pattern/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://huimang2.github.io/" rel="alternate" type="text/html" />
  <updated>2022-08-23T08:38:27+09:00</updated>
  <id>https://huimang2.github.io/tag/design-pattern/feed.xml</id>

  
  
  

  
    <title type="html">Rubisco’s Programming Note | </title>
  

  
    <subtitle>프로그래밍 노트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">MVC 패턴</title>
      <link href="https://huimang2.github.io/design-pattern/mvc-pattern" rel="alternate" type="text/html" title="MVC 패턴" />
      <published>2022-08-03T19:00:00+09:00</published>
      <updated>2022-08-03T19:00:00+09:00</updated>
      <id>https://huimang2.github.io/design-pattern/mvc-pattern</id>
      <content type="html" xml:base="https://huimang2.github.io/design-pattern/mvc-pattern">&lt;h1 id=&quot;mvc-패턴이란&quot;&gt;MVC 패턴이란?&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVC 패턴(Model-View-Controller Pattern)&lt;/code&gt;은 어플리케이션을 개발함에 있어서 컴포넌트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모델(Model)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;뷰(View)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨트롤러(Controller)&lt;/code&gt;로 역할을 나누어 개발하는 디자인 패턴 즉, 설계 방식을 말합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-01.png&quot; alt=&quot;img01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클라이언트(Client)가 뷰를 통해 컨트롤러에게 요청(Request)를 보내면 해당 요청을 컨트롤러가 받고, 컨트롤러는 모델을 통해 데이터를 가져와서 뷰를 제어합니다.&lt;/p&gt;

&lt;h2 id=&quot;모델model&quot;&gt;모델(Model)&lt;/h2&gt;

&lt;p&gt;모델은 애플리케이션의 데이터를 책임지는 컴포넌트 입니다. 내부 비즈니스 로직을 처리하는 역할을 하며, 다음과 같은 규칙을 가집니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;사용자(Client)가 편집하길 원하는 모든 데이터를 가지고 있어야한다.&lt;/h3&gt;

&lt;p&gt;사용자가 게시판의 글을 수정하길 원한다면 모델은 제목, 내용, 작성자 등을 포함한 게시글에 대한 모든 데이터를 가지고 있어야 합니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;뷰나 컨트롤러에 대한 어떤 정보도 알지 못한다.&lt;/h3&gt;

&lt;p&gt;모델은 자기 자신이 수행하는 일에 대한 정보만 알고 있어야 하며, 이를 넘어서는 작업을 해서는 안됩니다. 예를 들어 게시글 내용을 변경하는 역할을 하는 모델이 뷰의 정보를 가지고 게시글 색상을 변경하는 등의 작업을 해서는 안됩니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;변경이 일어나면 통지에 대한 처리방법을 구현해야 한다.&lt;/h3&gt;

&lt;p&gt;모델의 데이터가 변경된다면 이를 컨트롤러에게 알리기 위한 처리 방법을 구현해야 하며, 재사용이 가능해야 합니다. 그렇기 때문에 MCV 패턴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;옵저버(Observer) 패턴&lt;/code&gt;과 많은 연관점이 있습니다. 하나의 모델에 대하여 다수의 뷰가 모델을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구독(Subscribe)&lt;/code&gt;하는 형태입니다.&lt;/p&gt;

&lt;h2 id=&quot;뷰view&quot;&gt;뷰(View)&lt;/h2&gt;

&lt;p&gt;뷰는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 인터페이스(User Interface, UI)&lt;/code&gt;를 책임지는 컴포넌트 입니다. 모델이 가지고 있는 데이터를 기반으로 사용자에게 화면을 출력해주는 역할을 하며, 다음과 같은 규칙을 가집니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;모델이 가지고 있는 정보를 저장해서는 안된다.&lt;/h3&gt;

&lt;p&gt;데이터 출력을 위해서는 필연적으로 모델의 정보를 전달받게 되는데, 이때 알게 된 모델의 정보를 따로 저장해서는 안됩니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;모델이나 컨트롤러에 대한 어떤 정보도 알지 못한다.&lt;/h3&gt;

&lt;p&gt;모델과 마찬가지로 뷰 역시 자기 자신이 수행하는 일에 대한 정보만 알고 있어야 하며, 이를 넘어서는 작업을 해서는 안됩니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;변경이 일어나면 통지에 대한 처리방법을 구현해야 한다.&lt;/h3&gt;

&lt;p&gt;모델과 같이 뷰에 변경이 있으면 통지할 수단이 필요합니다. 모델에서 설명했듯이 이는 보통 옵저버 패턴을 통해 구현됩니다.&lt;/p&gt;

&lt;h2 id=&quot;컨트롤러controller&quot;&gt;컨트롤러(Controller)&lt;/h2&gt;

&lt;p&gt;컨트롤러는 뷰와 모델을 연결하여 실질적으로 사용자의 요청을 처리하는 컴포넌트 입니다. 사용자의 요청에 대하여 모델에게 데이터를 처리할 방법을 알려주며, 모델이 작업을 완료하면 그 결과를 뷰에 전달합니다. 컨트롤러는 다음과 같은 규칙을 가집니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;모델이나 뷰의 정보를 알고 있어야 한다.&lt;/h3&gt;

&lt;p&gt;모델과 뷰는 서로 알지 못하기 때문에 컨트롤러를 통해 변경을 중재받습니다. 컨트롤러가 모델과 뷰를 중재하려면 모델과 뷰에 대한 정보를 가지고 있어야만 합니다.&lt;/p&gt;

&lt;h3 class=&quot;no-toc&quot;&gt;모델이나 뷰의 변경을 모니터링 해야 한다.&lt;/h3&gt;

&lt;p&gt;위의 규칙과 마찬가지로 모델과 뷰는 서로 알지 못하기에 컨트롤러가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중재자(Mediator)&lt;/code&gt;가 되어 서로의 변경을 통지해야 합니다.&lt;/p&gt;

&lt;h1 id=&quot;옵저버-패턴observer-pattern&quot;&gt;옵저버 패턴(Observer Pattern)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;옵저버 패턴(Observer Pattern)&lt;/code&gt;은 객체의 상태를 관찰하는 옵저버를 통해 객체의 상태가 변하면 종속된 객체들에게 통지를 보내는 패턴입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-02.png&quot; alt=&quot;img02&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;margin-top: 1.5em&quot;&gt;MVC 패턴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;옵저버 패턴(Observer Pattern)&lt;/code&gt;과 많은 연관점이 있습니다. 하나의 모델에 대하여 다수의 뷰가 옵저버를 통해 모델을 구독하는 형태를 가지고 있으며, 이는 컨트롤러의 중재를 받습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-03.png&quot; alt=&quot;img03&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;p&gt;모델의 상태를 관찰하기 위한 옵저버 인터페이스 입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update&lt;/code&gt; 메소드를 통해 뷰가 변경됩니다.&lt;/p&gt;

&lt;h6 id=&quot;observerjava&quot;&gt;Observer.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;옵저버 인터페이스를 구현한 뷰 클래스 입니다. 아래 코드에서는 콘솔창을 통해 새로운 글의 등록을 알리도록 인터페이스를 구현했습니다.&lt;/p&gt;

&lt;h6 id=&quot;viewjava&quot;&gt;View.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &amp;gt; 새로운 글이 등록되었습니다 : &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;모델에 대한 인터페이스 입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyObservers&lt;/code&gt; 메소드를 통해 알림을 발행하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registerObserver&lt;/code&gt; 메소드를 통해 뷰가 모델을 구독할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;observablejava&quot;&gt;Observable.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registerObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifyObservers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;모델 클래스 입니다. Observable 인터페이스를 구현했으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyObservers&lt;/code&gt; 메소드를 통해 모델을 구독하고 있는 뷰의 update 메소드를 호출합니다.&lt;/p&gt;

&lt;h6 id=&quot;modeljava&quot;&gt;Model.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Model&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;observers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifyObservers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;registerObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;컨트롤러 클래스 입니다. 뷰와 모델은 컨트롤러에 의하여 통제됩니다. 아래 코드에서는 하드코딩을 통해 모델과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;게시판1&lt;/code&gt; 이라는 뷰 객체를 생성하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1번째 글&lt;/code&gt;이라는 클라이언트의 요청을 모델에 전달했습니다.&lt;/p&gt;

&lt;h6 id=&quot;controllerjava&quot;&gt;Controller.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Controller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;nc&quot;&gt;Observable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;게시판1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;registerObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notifyObservers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1번째 글&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;디버깅해보면 아래와 같은 로그를 볼 수 있습니다.&lt;/p&gt;

&lt;div data-lang=&quot;BASH&quot; class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;게시판1 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 새로운 글이 등록되었습니다 : 1번째 글
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;java-mvc-모델&quot;&gt;JAVA MVC 모델&lt;/h1&gt;

&lt;p&gt;자바의 MVC 패턴에는 MVC1과 MVC2가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;mvc1-모델&quot;&gt;MVC1 모델&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-04.png&quot; alt=&quot;img04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC1 모델은 JSP 페이지가 뷰(View)와 컨트롤러(Controller) 부분을 담당하고 Java Bean이 모델(Model)과 컨트롤러(Controller)를 담당하는 구조입니다.&lt;/p&gt;

&lt;p&gt;페이지의 흐름이 단순하기 때문에 개발이 간편하고 개발 속도가 빠릅니다.&lt;/p&gt;

&lt;p&gt;반면 모델(비즈니스 로직)과 뷰(프레젠테이션 로직) 사이의 구분이 모호하여 디자이너와의 협업이 힘들며, 어플리케이션이 복잡해질수록 유지보수가 힘듭니다.&lt;/p&gt;

&lt;h2 id=&quot;mvc2-모델&quot;&gt;MVC2 모델&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-05.png&quot; alt=&quot;img05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC2 모델은 JSP 페이지가 뷰를 담당하고 Servlet은 컨트롤러, Java Bean은 모델을 담당하는 구조입니다.&lt;/p&gt;

&lt;p&gt;뷰와 모델의 구분이 명확하고, JSP 페이지의 코드가 간결해져 유지보수가 용이하고 디자이너와이 협업이 쉬워집니다.&lt;/p&gt;

&lt;p&gt;반면 로직이 복잡해져 구조 설계를 위한 시간이 많이 소모되어 개발 기간이 증가합니다.&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc&quot;&gt;Spring MVC&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/mvc/mvc-img-06.png&quot; alt=&quot;img06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Spring MVC는 MVC2 모델의 발전된 형태의 구조입니다.&lt;/p&gt;

&lt;p&gt;FrontController인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatcherServlet&lt;/code&gt;이 클라이언트의 요청을 받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HandlerMapping&lt;/code&gt;을 통해 Controller와 매핑되어 해당 컨트롤러를 실행합니다.&lt;/p&gt;

&lt;p&gt;컨트롤러는 Model과 View가 Wrapping된 객체를 반환하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewResolver&lt;/code&gt;를 통해 View 객체를 처리한 후 클라이언트에게 해당 객체를 반환합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="design-pattern" />
      

      
        <summary type="html">MVC 패턴이란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">싱글톤 패턴(Singleton Pattern)</title>
      <link href="https://huimang2.github.io/design-pattern/creational/singleton-pattern" rel="alternate" type="text/html" title="싱글톤 패턴(Singleton Pattern)" />
      <published>2022-07-12T18:18:00+09:00</published>
      <updated>2022-07-12T18:18:00+09:00</updated>
      <id>https://huimang2.github.io/design-pattern/creational/singleton-pattern</id>
      <content type="html" xml:base="https://huimang2.github.io/design-pattern/creational/singleton-pattern">&lt;div class=&quot;table-of-contents-list&quot;&gt;GOF 디자인 패턴&lt;/div&gt;
&lt;ul class=&quot;table-of-contents-list design_pattern&quot;&gt;
    
    &lt;li&gt;
        &lt;span&gt;생성 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li class=&quot;active&quot;&gt;
                
                    &lt;span&gt;싱글톤 패턴(Singleton Pattern)&lt;/span&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;팩토리 메서드 패턴(Factory Method Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;추상 팩토리 패턴(Abstract Factory Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;빌더 패턴(Builder Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;프로토타입 패턴(Prototype Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
        &lt;span&gt;구조 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;어댑터 패턴(Adapter Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;브리지 패턴(Bridge Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;컴포지트 패턴(Composit Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;데코레이터 패턴(Decorator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;퍼사드 패턴(Facade Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;플라이웨이트 패턴(Flyweight Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;프록시 패턴(Proxy Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
        &lt;span&gt;행위 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;책임 연쇄 패턴(Chain of Responsibility Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;커맨드 패턴(Command Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;이터레이터 패턴(Iterator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;메디에이터 패턴(Mediator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;메멘토 패턴(Memento Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;옵저버 패턴(Observer Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;상태 패턴(State Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;전략 패턴(Strategy Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;템플릿 메소드 패턴(Template Method Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;비지터 패턴(Visitor Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
&lt;/ul&gt;

&lt;h1 id=&quot;싱글톤-패턴singleton-pattern&quot;&gt;싱글톤 패턴(Singleton Pattern)&lt;/h1&gt;

&lt;p&gt;싱글톤 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 접근할 수 있는 방법을 제공합니다. 즉, 특정 클래스의 객체는 하나만 생성되도록 하여 동일 인스턴스를 재사용 하는 패턴입니다.&lt;/p&gt;

&lt;h2 id=&quot;구조&quot;&gt;구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/diagram/Singleton.png&quot; alt=&quot;singleton&quot; title=&quot;싱글톤 패턴 클래스 다이어그램&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참여-객체&quot;&gt;참여 객체&lt;/h2&gt;

&lt;h3 id=&quot;singleton&quot;&gt;Singleton&lt;/h3&gt;

&lt;p&gt;생성자의 접근자를 private로 설정하여 새로운 인스턴스를 생성하지 못하도록 하고, 인스턴스(Instance)의 접근을 위한 오퍼레이션(Operation)을 static으로 정의하여 해당 메소드에 의해서만 인스턴스의 접근이 가능하도록 합니다.&lt;/p&gt;

&lt;p&gt;인스턴스는 싱글턴 객체의 클래스 변수로 설정되어 클래스가 메모리의 데이터영역에 저장될 때 같이 저장됨으로써 오직 한번만 인스턴스를 생성할 수 있습니다. 이로써 싱글턴 객체는 유일한 인스턴스의 생성에 대한 책임을 지게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;h3 id=&quot;이른-초기화-방식-eager-initialization&quot;&gt;이른 초기화 방식 (Eager Initialization)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이른 초기화 방식&lt;/code&gt;은 싱글톤 패턴의 가장 기본적인 유형입니다.&lt;/p&gt;

&lt;p&gt;전역변수로 인스턴스를 생성하고 접근자를 private로 설정함으로써 싱글톤 객체의 오퍼레이션 메소드에 의해서만 접근이 가능하도록 합니다. 또한 생성자의 접근자를 private로 절정함으로써 외부에서 인스턴스를 생성할 수 없도록 만듭니다.&lt;/p&gt;

&lt;h6 id=&quot;eagersingletonjava&quot;&gt;EagerSingleton.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;design_pattern.creational.singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSingleton&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EagerSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EagerSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서는 static으로 선언한 클래스 변수가 곧 전역변수입니다. 클래스가 메모리의 데이터 영역에 저장될 때 클래스 변수인 INSTANCE는 싱글톤 인스턴스를 한번만 생성하여 참조함으로써 동일한 인스턴스를 재사용하는 싱글톤 원칙을 지킬 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이른 초기화 방식의 &lt;strong&gt;&lt;span style=&quot;color:green&quot;&gt;장점&lt;/span&gt;&lt;/strong&gt;은 전역변수로 싱글톤 인스턴스를 만들었기때문에 클래스 로더에 의하여 클래스가 로딩될 때 오직 한번만 인스턴스가 생성되므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread-safe&lt;/code&gt;하게 싱글톤 객체를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:orangered&quot;&gt;단점&lt;/span&gt;&lt;/strong&gt;은 객체의 사용여부와 상관없이 클래스 로딩 시점에 인스턴스가 생성되어 프로그램이 종료될때까지 메모리를 점유하기때문에 자주 사용하지 않는 객체라면 비효율적일 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;늦은-초기화-방식-lazy-initialization&quot;&gt;늦은 초기화 방식 (Lazy Initialization)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;늦은 초기화 방식&lt;/code&gt;은 이른 초기화 방식과 반대로 클래스의 오퍼레이션 메소드가 호출될 때 인스턴스를 생성합니다. 즉, 클래스 메소드가 호출될 때까지 메모리를 점유하지 않습니다.&lt;/p&gt;

&lt;h6 id=&quot;lazysingletonjava&quot;&gt;LazySingleton.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;design_pattern.creational.singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazySingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazySingleton&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LazySingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazySingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LazySingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;늦은 초기화 방식의 &lt;strong&gt;&lt;span style=&quot;color:green&quot;&gt;장점&lt;/span&gt;&lt;/strong&gt;은 필요할때 객체를 생성할 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:orangered&quot;&gt;단점&lt;/span&gt;&lt;/strong&gt;은 멀티 쓰레드(Thread) 환경에서 동시에 호출되어 싱글톤 원칙을 보장할 수 없다는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;쓰레드-안전-이른-초기화-방식-thread-safe-lazy-initialization&quot;&gt;쓰레드 안전 이른 초기화 방식 (Thread safe Lazy Initialization)&lt;/h3&gt;

&lt;p&gt;늦은 초기화 방식을 보완하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드를 메소드에 선언하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쓰레드 안전(Thread safe)&lt;/code&gt; 상태로 싱글톤을 생성할 수 있는 방식입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;로 선언된 메소드는 하나의 쓰레드가 메소드를 사용하면 lock을 걸어 다른 쓰레드를 대기상태로 만듭니다.&lt;/p&gt;

&lt;h6 id=&quot;threadsafelazysingletonjava&quot;&gt;ThreadSafeLazySingleton.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;design_pattern.creational.singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeLazySingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeLazySingleton&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadSafeLazySingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeLazySingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadSafeLazySingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방식의 &lt;strong&gt;&lt;span style=&quot;color:green&quot;&gt;장점&lt;/span&gt;&lt;/strong&gt;은 Thread-safe 환경이라는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:orangered&quot;&gt;단점&lt;/span&gt;&lt;/strong&gt;은 syncronized가 선언된 메소드가 호출이 많으면 성능이 나빠질 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;dcl-방식-double-checked-locking&quot;&gt;DCL 방식 (Double-Checked locking)&lt;/h3&gt;

&lt;p&gt;DCL 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syncronized&lt;/code&gt;를 메소드에 선언하는 것이 아니라 메소드 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syncronized&lt;/code&gt; 블락을 만드는 방식입니다.&lt;/p&gt;

&lt;h6 id=&quot;dclsingletonjava&quot;&gt;DCLSingleton.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;design_pattern.creational.singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DCLSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DCLSingleton&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DCLSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DCLSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DCLSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DCLSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 코드와 같이 인스턴스가 없을때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드를 통해 블락을 만들어 하나의 쓰레드만 작업할 수 있도록 하고 블락 내부에서 다시한번 인스턴스 존재 여부를 체크하게 됩니다. 2번 체크하기때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCL(Double Checking Locking)&lt;/code&gt; 방식이라 불립니다.&lt;/p&gt;

&lt;p&gt;private 접근자로 설정한 INSTANCE 클래스를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;이라는 키워드를 사용했습니다. 하나의 프로세서(CPU)는 최적화를 위해 변수를 메인 메모리에 바로 저장하지 않고 캐쉬메모리에 저장하여 성능을 향상시킵니다. 그러나 volatile로 선언된 변수는 변수를 캐쉬메모리에 저장하지 않고 곧바로 메인메모리에 반영하도록 합니다.&lt;/p&gt;

&lt;p&gt;volatile 키워드를 사용하지 않고 멀티코어 환경에서 작업한다면 인스턴스를 캐쉬메모리에 저장하여 메인메모리에 인스턴스를 생성하기전에 다른 코어의 쓰레드가 비어있는 메모리를 참조하기때문에 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;holder에-의한-초기화-방식-initialization-on-demand-holder-idiom&quot;&gt;Holder에 의한 초기화 방식 (Initialization on demand holder idiom)&lt;/h3&gt;

&lt;p&gt;이 방식은 클래스안에 클래스 홀더(Holder)를 두어 JVM 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방식입니다. 현재까지 가장 많이 이용되고 있는 방식입니다.&lt;/p&gt;

&lt;h6 id=&quot;staticholdersingletonjava&quot;&gt;StaticHolderSingleton.java&lt;/h6&gt;
&lt;div data-lang=&quot;JAVA&quot; class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;design_pattern.creational.singleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticHolderSingleton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StaticHolderSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingleTonHolder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticHolderSingleton&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticHolderSingleton&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StaticHolderSingleton&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingleTonHolder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 코드에서 보는 바와 같이 클래스 안에 private 접근자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중첩클래스&lt;/code&gt;를 선언하고 중첩클래스 내부에 private 접근자로 클래스 변수를 선언했습니다. 중첩 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오퍼레이션 메소드(Operation Method)&lt;/code&gt;에 의하여 호출되기 전까지 참조되지 않으며, 오퍼레이션 메소드에 의하여 호출될때 클래스 로더에 의하여 싱글톤 인스턴스를 생성하게 됩니다.&lt;/p&gt;

&lt;p&gt;중첩클래스 내부에 선언된 클래스 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;으로 선언되었기 때문에 중첩클래스가 로드되는 시점에 한번만 싱글톤 인스턴스를 생성할 수 있게 됩니다. 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 키워드를 통해 다시 값이 할당되지 않도록 하여 싱글톤 원칙을 지킬 수 있게 됩니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="java" />
      
        <category term="design-pattern" />
      

      
        <summary type="html">GOF 디자인 패턴 생성 패턴 싱글톤 패턴(Singleton Pattern) 팩토리 메서드 패턴(Factory Method Pattern) 추상 팩토리 패턴(Abstract Factory Pattern) 빌더 패턴(Builder Pattern) 프로토타입 패턴(Prototype Pattern) 구조 패턴 어댑터 패턴(Adapter Pattern) 브리지 패턴(Bridge Pattern) 컴포지트 패턴(Composit Pattern) 데코레이터 패턴(Decorator Pattern) 퍼사드 패턴(Facade Pattern) 플라이웨이트 패턴(Flyweight Pattern) 프록시 패턴(Proxy Pattern) 행위 패턴 책임 연쇄 패턴(Chain of Responsibility Pattern) 커맨드 패턴(Command Pattern) 이터레이터 패턴(Iterator Pattern) 메디에이터 패턴(Mediator Pattern) 메멘토 패턴(Memento Pattern) 옵저버 패턴(Observer Pattern) 상태 패턴(State Pattern) 전략 패턴(Strategy Pattern) 템플릿 메소드 패턴(Template Method Pattern) 비지터 패턴(Visitor Pattern)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">디자인 패턴(Design Pattern)</title>
      <link href="https://huimang2.github.io/design-pattern/intro" rel="alternate" type="text/html" title="디자인 패턴(Design Pattern)" />
      <published>2022-07-11T22:18:00+09:00</published>
      <updated>2022-07-11T22:18:00+09:00</updated>
      <id>https://huimang2.github.io/design-pattern/intro</id>
      <content type="html" xml:base="https://huimang2.github.io/design-pattern/intro">&lt;div class=&quot;table-of-contents-list&quot;&gt;GOF 디자인 패턴&lt;/div&gt;
&lt;ul class=&quot;table-of-contents-list design_pattern&quot;&gt;
    
    &lt;li&gt;
        &lt;span&gt;생성 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li&gt;
                
                    &lt;a href=&quot;/design-pattern/creational/singleton-pattern&quot;&gt;싱글톤 패턴(Singleton Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;팩토리 메서드 패턴(Factory Method Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;추상 팩토리 패턴(Abstract Factory Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;빌더 패턴(Builder Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;프로토타입 패턴(Prototype Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
        &lt;span&gt;구조 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;어댑터 패턴(Adapter Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;브리지 패턴(Bridge Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;컴포지트 패턴(Composit Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;데코레이터 패턴(Decorator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;퍼사드 패턴(Facade Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;플라이웨이트 패턴(Flyweight Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;프록시 패턴(Proxy Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
    &lt;li&gt;
        &lt;span&gt;행위 패턴&lt;/span&gt;
        &lt;ul class=&quot;table-of-contents-list&quot;&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;책임 연쇄 패턴(Chain of Responsibility Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;커맨드 패턴(Command Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;이터레이터 패턴(Iterator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;메디에이터 패턴(Mediator Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;메멘토 패턴(Memento Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;옵저버 패턴(Observer Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;상태 패턴(State Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;전략 패턴(Strategy Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;템플릿 메소드 패턴(Template Method Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
            &lt;li class=&quot;none&quot;&gt;
                
                    &lt;a href=&quot;#&quot;&gt;비지터 패턴(Visitor Pattern)&lt;/a&gt;
                
            &lt;/li&gt;
            
        &lt;/ul&gt;
    &lt;/li&gt;
    
&lt;/ul&gt;

&lt;h1 id=&quot;디자인-패턴&quot;&gt;디자인 패턴&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디자인 패턴(Design Pattern)&lt;/code&gt;은 객체지향 프로그래밍을 할때 자주 접할 수 있는 문제를 해결하고자 만든 일종의 코드 패턴에 대한 템플릿(template)입니다.&lt;br /&gt;
&lt;br /&gt;
1990년대 초반 에리히 감마(Erich Gamma)에 의해 첫 소개된 이후 1995년에 이분야의 GoF(Gang of Four)라 불리는 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)에 의해 집대성 되었고, 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoF의 디자인 패턴(Design Pattern)&lt;/code&gt;으로 널리 알려졌습니다.&lt;br /&gt;
&lt;br /&gt;
디자인 패턴은 객체지향 모델링의 장점인 재사용성과 모듈성을 극대화 시켜서 이를 적용하면 시스템 개발은 물론 유지보수에도 큰 효과를 얻을 수 있습니다. 반면 객체지향 모델에 사용되므로 초기 개발시간이 길어져 소규모 프로젝트에는 적합하지 않을 수도 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;디자인-패턴의-종류&quot;&gt;디자인 패턴의 종류&lt;/h1&gt;

&lt;p&gt;디자인 패턴은 크게 생성 패턴(Creational Pattern)과 구조 패턴(Structural Patterns), 행위 패턴(Behavioral Patterns)으로 나눠집니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생성 패턴(Creational Pattern)&lt;/code&gt;은 &lt;u&gt;객체(Object)의 인스턴스(Instance) 생성을 위한 패턴&lt;/u&gt;입니다. 클라이언트와 객체 인스턴스 사이의 연결을 끊어줍니다.&lt;/p&gt;

&lt;p&gt;생성 패턴에는 싱글톤 패턴(Singleton Pattern), 빌더 패턴(Builder Pattern), 팩토리 메서드 패턴(Factory Method Pattern), 추상 팩토리 패턴(Abstract Factory Pattern), 프로토타입 패턴(Prototype Pattern)이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조 패턴(Structural Patterns&lt;/code&gt;은 &lt;u&gt;객체(Object)의 합성에 관한 패턴&lt;/u&gt;입니다. 객체의 조직화에 대한 패턴을 제공합니다.&lt;/p&gt;

&lt;p&gt;구조 패턴에는 어댑터 패턴(Adapter Pattern), 브리지 패턴(Bridge Pattern), 컴포지트 패턴(Composit Pattern), 데코레이터 패턴(Decorator Pattern), 퍼사드 패턴(Facade Pattern), 플라이웨이트 패턴(Flyweight Pattern), 프록시 패턴(Proxy Pattern)이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;행위 패턴(Behavioral Patterns)&lt;/code&gt;은 &lt;u&gt;객체(Object)의 상호작용과 책임 분산에 대한 패턴&lt;/u&gt;을 제공합니다.&lt;/p&gt;

&lt;p&gt;행위 패턴에는 책임 연쇄 패턴(Chain of Responsibility Pattern), 커맨드 패턴(Command Pattern), 인터프리터 패턴(Interpreter Pattern), 이터레이터 패턴(Iterator Pattern), 메디에이터 패턴(Mediator Pattern), 메멘토 패턴(Memento Pattern), 옵저버 패턴(Observer Pattern), 상태 패턴(State Pattern), 전략 패턴(Strategy Pattern), 템플릿 메소드 패턴(Template Method Pattern), 비지터 패턴(Visitor Pattern)이 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="java" />
      
        <category term="design-pattern" />
      

      
        <summary type="html">GOF 디자인 패턴 생성 패턴 싱글톤 패턴(Singleton Pattern) 팩토리 메서드 패턴(Factory Method Pattern) 추상 팩토리 패턴(Abstract Factory Pattern) 빌더 패턴(Builder Pattern) 프로토타입 패턴(Prototype Pattern) 구조 패턴 어댑터 패턴(Adapter Pattern) 브리지 패턴(Bridge Pattern) 컴포지트 패턴(Composit Pattern) 데코레이터 패턴(Decorator Pattern) 퍼사드 패턴(Facade Pattern) 플라이웨이트 패턴(Flyweight Pattern) 프록시 패턴(Proxy Pattern) 행위 패턴 책임 연쇄 패턴(Chain of Responsibility Pattern) 커맨드 패턴(Command Pattern) 이터레이터 패턴(Iterator Pattern) 메디에이터 패턴(Mediator Pattern) 메멘토 패턴(Memento Pattern) 옵저버 패턴(Observer Pattern) 상태 패턴(State Pattern) 전략 패턴(Strategy Pattern) 템플릿 메소드 패턴(Template Method Pattern) 비지터 패턴(Visitor Pattern)</summary>
      

      
      
    </entry>
  
</feed>
