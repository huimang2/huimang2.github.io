<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://huimang2.github.io/author/rubisco/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://huimang2.github.io/" rel="alternate" type="text/html" />
  <updated>2023-06-19T00:35:05+09:00</updated>
  <id>https://huimang2.github.io/author/rubisco/feed.xml</id>

  
  
  

  
    <title type="html">Rubisco’s Programming Note | </title>
  

  
    <subtitle>프로그래밍 노트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">프로세스</title>
      <link href="https://huimang2.github.io/etc/computer-process" rel="alternate" type="text/html" title="프로세스" />
      <published>2023-06-18T01:00:00+09:00</published>
      <updated>2023-06-18T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-process</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-process">&lt;h1 id=&quot;프로세스process&quot;&gt;프로세스(Process)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스(Process)&lt;/code&gt;란 현재 실행되고 있는 프로그램의 인스턴스를 말합니다. 프로그램은 데이터 상태로 보조기억장치에 저장되어 있으며, 프로그램이 실행되면 메모리에 적재되어 프로세스가 됩니다. 윈도우에서 작업 관리자를 열면 현재 실행중인 프로세스를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img112.png&quot; alt=&quot;img112&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포그라운드 프로세스(Foreground Process)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백그라운드 프로세스(Background Process)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포그라운드 프로세스(Foreground Process)&lt;/code&gt;는 사용자와 상호작용하면서 실행되는 프로세스입니다. 이 프로세스는 주로 사용자 인터페이스를 통해 입력을 받거나 출력을 제공하며, 사용자의 명령을 처리하거나 작업을 수행합니다. 포그라운드 프로세스는 사용자가 직접 볼 수 있고 제어할 수 있으며, 사용자와의 상호작용을 위해 우선순위를 가지고 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;백그라운드 프로세스(Background Process)&lt;/code&gt;는 사용자와 상호작용하지 않고 실행되는 프로세스입니다. 이러한 프로세스는 주로 시스템 작업이나 보조 작업을 처리하는 데 사용됩니다. 백그라운드 프로세스는 사용자의 입력이나 제어를 기다리지 않고 실행되므로 보다 높은 우선순위를 가질 수 있습니다. 일반적으로 백그라운드 프로세스는 시간이 오래 걸리는 작업이나 자동화된 작업을 처리하는 데 사용됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 웹 브라우저를 실행한다고 가정해 봅시다. 웹 브라우저 자체는 포그라운드 프로세스로 실행되며, 사용자가 웹 페이지를 찾아보거나 입력을 하면 이를 처리합니다. 그러나 웹 브라우저에서 파일을 다운로드하는 경우, 다운로드 작업은 백그라운드 프로세스로 실행됩니다. 사용자는 다운로드 작업이 백그라운드에서 진행되는 동안에도 브라우저를 계속 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;백그라운드 프로세스는 다운로드와 같이 사용자와 상호작용이 가능한 백그라운드 프로세스와 사용자와 상호작용하지 않고 정해진 작업만 수행하는 백그라운드 프로세스로 나눌 수 있습니다. 후자의 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데몬(Daemon)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스(Service)&lt;/code&gt; 라고 합니다.&lt;/p&gt;

&lt;h6 id=&quot;윈도우-서비스&quot;&gt;윈도우 서비스&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img119.png&quot; alt=&quot;img119&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;프로세스-제어-블록process-control-block-pcb&quot;&gt;프로세스 제어 블록(Process Control Block, PCB)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스 제어 블록(Process Control Block, PCB)&lt;/code&gt;은 운영체제에서 프로세스를 관리하기 위해 사용되는 데이터 구조입니다.&lt;/p&gt;

&lt;p&gt;CPU는 한정된 자원을 가지기 때문에 프로세스는 돌아가면서 한정된 시간만큼 CPU를 사용합니다. 자신의 차례에 정해진 시간만큼 CPU를 사용하고 타이머 인터럽트가 발생하면 다음 프로세스에게 차례를 양보합니다. 운영 체제는 빠르게 번갈아 수행되는 프로세스를 관리할 필요가 있는데, 이를 위해 PCB를 사용합니다.&lt;/p&gt;

&lt;p&gt;운영체제는 각 프로세스에 대해 PCB를 커널 영역에 생성하고 프로세스의 상태 및 관련 정보를 추적합니다. 이러한 정보는 운영 체제가 프로세스를 스케줄링하고 제어하는 데 필요한 기반이 됩니다.&lt;/p&gt;

&lt;p&gt;PCB는 프로세스의 상태, 우선 순위, 레지스터 값, 메모리 할당 정보, 입출력 상태 등 다양한 정보를 포함합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;1. 프로세스 식별자(Process ID, PID)&lt;/font&gt;:&lt;/strong&gt; 각 프로세스를 고유하게 식별하는 번호 또는 이름입니다. PID는 운영 체제에서 프로세스를 식별하는 데 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;2. 프로세스 상태(Process State)&lt;/font&gt;:&lt;/strong&gt; 프로세스의 현재 상태를 나타냅니다. 프로세스 상태는 &lt;strong&gt;실행(Running)&lt;/strong&gt;, &lt;strong&gt;대기(Waiting)&lt;/strong&gt;, &lt;strong&gt;준비(Ready)&lt;/strong&gt; 등이 있습니다. 운영 체제는 이 정보를 기반으로 프로세스를 스케줄링하고 상태 전이를 관리합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;3. 프로그램 카운터(Program Counter, PC)&lt;/font&gt;:&lt;/strong&gt; 현재 실행 중인 명령어의 주소를 가리키는 레지스터 값입니다. 프로세스는 다음에 실행할 명령어를 PC의 값에 따라 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;4. 레지스터(Register) 값&lt;/font&gt;:&lt;/strong&gt; 프로세스가 현재 사용 중인 레지스터의 값을 저장합니다. 이는 프로세스가 실행되는 동안 레지스터 값이 유지되도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;5.스케줄링 정보(Scheduling Information)&lt;/font&gt;:&lt;/strong&gt; 프로세스의 우선 순위, CPU 점유 시간, 대기 시간 등 스케줄링과 관련된 정보를 포함합니다. 운영 체제는 이 정보를 기반으로 프로세스 스케줄링 알고리즘을 실행하여 어떤 프로세스를 실행시킬지 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;6.메모리 관리 정보(Memory Management Information)&lt;/font&gt;:&lt;/strong&gt; 프로세스가 사용하는 메모리 주소 범위, 페이지 테이블 정보 등과 같은 메모리 관리에 필요한 정보를 포함합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalBlue&quot;&gt;7.입출력 상태(I/O Status)&lt;/font&gt;:&lt;/strong&gt; 프로세스가 사용 중인 입출력 장치와 관련된 정보를 저장합니다. 이 정보는 프로세스가 입출력 작업을 수행하는 데 필요합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스-상태&quot;&gt;프로세스 상태&lt;/h1&gt;

&lt;p&gt;프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생성(New)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;준비(Ready)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행(Run)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대기(Wait)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종료(Exit)&lt;/code&gt; 5가지 상태를 가집니다. 프로세스 상태는 운영 체제가 프로세스의 상태 전이를 관리하고 스케줄링을 수행하기 위해 사용됩니다. 스케줄러는 준비 상태에 있는 프로세스를 실행 상태로 전환하고, 대기 상태에 있는 프로세스를 준비 상태로 전환하여 CPU 할당을 조정합니다. 이를 통해 CPU 자원을 효율적으로 활용하고 다중 프로세스가 동시에 실행될 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img123.png&quot; alt=&quot;img123&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;생성 상태(create status)&lt;/code&gt;는 프로세스가 생성되었지만 아직 실행되기 전인 상태입니다. 이 단계에서는 프로세스가 초기화되고 필요한 자원이 할당됩니다. PCB는 이때 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;준비 상태(ready status)&lt;/code&gt;는 프로세스가 실행을 기다리는 상태입니다. 필요한 자원을 모두 할당받았으며, CPU를 할당받기를 기다리는 상태입니다. 스케줄러에 의해 다음에 실행될 프로세스로 선택될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;실행 상태(runnig status)&lt;/code&gt;는 준비 상태에 있는 프로세스가 CPU를 할당받아 실행되고 있는 상태입니다. 준비 상태에 있는 프로세스가 실행 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디스패치(Dispatch)&lt;/code&gt;라고 합니다. 이때 프로세스는 CPU를 사용하여 명령어를 실행하고 작업을 수행합니다. 실행 상태에서는 시간이 지남에 따라 프로세스는 완료되거나 대기 상태로 전환될 수 있습니다. 실행 상태의 프로세스가 대기 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Block&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;대기 상태(blocking status)&lt;/code&gt;는 프로세스가 어떤 이벤트를 기다리는 상태입니다. 이벤트는 입출력 완료, 사용자 입력, 시간 지연 등 다양한 상황일 수 있습니다. 대기 상태에 있는 프로세스는 CPU를 사용할 수 없으며, 해당 이벤트가 발생할 때까지 기다리게 됩니다. CPU에 비해 느린 입출력 작업의 경우 대기상태로 있다가 입출력 완료 인터럽트 신호를 받으면 준비 상태로 전환됩니다. 대기 상태의 프로세스가 준비 상태가 되는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wake up&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;종료 상태(terminate status)&lt;/code&gt;는 프로세스가 완료되거나 종료된 상태입니다. 프로세스의 실행이 끝났거나, 강제로 종료되었을 때 이 상태로 전환됩니다. 종료된 프로세스는 시스템에서 제거됩니다.&lt;/p&gt;

&lt;h1 id=&quot;문맥-교환context-switch&quot;&gt;문맥 교환(Context Switch)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문맥 교환(Context Switching)&lt;/code&gt;은 운영 체제에서 한 프로세스의 실행 상태를 저장하고 다른 프로세스의 실행 상태로 전환하는 과정을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문맥(Context)&lt;/code&gt;이란 프로그램 카운터 등 프로세스가 다음 차례가 왔을 때 실행을 재개하기 위한 PCB 정보를 말합니다. 문맥을 백업해두면 언제든지 프로세스의 실행을 재개할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img120.png&quot; alt=&quot;img120&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문맥 교환은 멀티태스킹 환경에서 여러 프로세스가 동시에 실행되는 상황에서 CPU의 할당을 조정하기 위해 필요합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스의-구소&quot;&gt;프로세스의 구소&lt;/h1&gt;

&lt;p&gt;메모리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 영역&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 영역&lt;/code&gt;으로 나눌 수 있습니다. 사용자 영역에서 프로세스는 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;코드(Code) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터(Data) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙(Heap) 영역&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스택(Stack) 영역&lt;/code&gt; 등으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img121.png&quot; alt=&quot;img121&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;커널 영역&lt;/code&gt;에는 위에서 설명했듯이 PCB가 저장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;코드 영역&lt;/code&gt;에는 실행하는 프로그램의 코드가 기계어로 저장되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;텍스트(Text) 영역&lt;/code&gt;이라고도 합니다. 데이터가 아닌 CPU가 실행할 명령어가 저장되어 있어서 쓰기가 금지된 read-only 영역입니다. CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;데이터 영역&lt;/code&gt;에는 프로그램이 실행되는 동안 유지할 데이터가 저장됩니다. 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전역 변수(global variable)&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 변수(static variable)&lt;/code&gt;가 저장되며, 프로그램이 실행될 때 할당되고 프로그램이 종료되면 소멸합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;힙 영역&lt;/code&gt;은 사용자가 직접 관리할 수 있는 메모리 영역으로, 런 타임에 할당받을 메모리 크기가 결정됩니다. 예를 들어 C언어에서 동적 크기의 배열을 선언하거나 자바에서 new 명령어를 통해 인스턴스를 생성하면 동적으로 힙 영역을 할당받아 데이터가 저장됩니다.&lt;/p&gt;

&lt;p&gt;힙 영역은 사용자가 직접 메모리를 반환해야 하며, 메모리를 반환하지 않으면 지속적으로 메모리 공간을 차지하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 누수(Memory Leak)&lt;/code&gt; 현상이 발생합니다. C언어에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free&lt;/code&gt; 함수를 통해 메모리를 반환하며, 자바의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가비지 콜렉션(Garbage Collection)&lt;/code&gt;에 의해 자동으로 메모리가 반환됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;스택 영역&lt;/code&gt;은 함수 호출 시 생성되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지역 변수(local variable)&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매개 변수(parameter)&lt;/code&gt; 등의 데이터가 일시적으로 저장되는 영역으로, 컴파일 타임에 할당받을 메모리 크기가 결정됩니다. 함수를 호출하면 동적으로 스택 영역을 할당받아 데이터가 저장되고, 함수의 호출이 완료되면 할당받은 메모리를 반환합니다.&lt;/p&gt;

&lt;p&gt;스택 영역은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;푸시(push)&lt;/code&gt; 동작으로 데이터를 저장하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팝(pop)&lt;/code&gt; 동작으로 데이터를 인출합니다. 데이터 인출시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후입선출(Last-In First-Out, LIFO)&lt;/code&gt; 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;코드 영역과 데이터 영역은 프로그램 시작시 고정적으로 메모리를 할당받기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 할당 영역&lt;/code&gt; 이라고 하며, 힙 영역과 스택 영역은 메모리를 동적으로 할당받기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적 할당 영역&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;동적 할당 영역에서 힙 영역은 낮은 주소에서 높은 주소 방향으로 메모리가 할당되고, 스택 영역은 높은 주소에서 낮은 주소 방향으로 메모리가 할당됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img122.png&quot; alt=&quot;img122&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 두 영역이 겹쳐 할당받을 메모리가 없게 된다면 서로의 영역을 침범할 수 있습니다. 이때 스택이 힙 영역을 침범하는 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스택 오버플로우(Stack Overflow)&lt;/code&gt;, 힙이 스택 영역을 침범하는 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙 오버플로우(Heap Overflow)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;프로세스의-생성&quot;&gt;프로세스의 생성&lt;/h1&gt;

&lt;p&gt;프로세스는 프로그램을 실행할 때 생성됩니다. 이때 운영체제가 프로그램 코드를 메모리 코드영역에 할당하고 PCB를 생성한 후 메모리에 데이터 영역과 스택 영역을 확보하여 프로세스를 실행합니다.&lt;/p&gt;

&lt;p&gt;유닉스 계열의 운영체제의 경우 새로운 프로세스를 생성할 때 위 과정을 모두 거치지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt; 시스템 호출을 통해 기존 프로세스 복사하여 새로운 프로세스를 생성합니다. 이때 fork 시스템 호출을 하는 프로세스는 부모 프로세스, 새로 만들어진 프로세스는 자식 프로세스가 되어 계층 구조를 형성합니다.&lt;/p&gt;

&lt;p&gt;fork를 호출하면 PCB를 포함한 부모 프로세스 대부분이 자식 프로세스에 복사되어 동일한 프로세스가 생성됩니다. 다만 PID, PPID, CPID 등 일부 데이터가 수정됩니다. PPID는 부모 프로세스의 PID, CPID는 자식 프로세스의 PID 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img124.png&quot; alt=&quot;img124&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;fork-예제-코드&quot;&gt;fork 예제 코드&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;first_PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;first_PPID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;---------------------&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Child Process!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent Process!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PPID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getppid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;saved PID: %ld&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;---------------------&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img125.png&quot; alt=&quot;img125&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 살펴보면 first_PID와 first_PPID가 부모 프로세스의 PID, PPID와 동일하다는 것을 볼 수 있습니다. 부모 프로세스와 자식 프로세스가 동기화되어 실행되는 것 처럼 보이지만 실제로는 독립적으로 실행되고 있습니다.&lt;/p&gt;

&lt;p&gt;fork 시스템 호출을 요청하면 부모 프로세스에는 자식 프로세스의 PID를 리턴하고, 자식 프로세스에는 0을 리턴합니다. 또한 자식 프로세스는 부모 프로세스의 PCB를 상속받았기 때문에 프로그램 카운터가 동일하여 fork 시스템 호출을 요청한 이후의 코드가 실행됩니다. 그렇기 때문에 자식 프로세스에서는 firt_PID와 first_PPID를 출력하지 않습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자식 프로세스에서 새로운 프로그램을 실행하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 시스템 호출을 요청하면 됩니다. exec 시스템 호출을 요청하면 자식 프로세스의 코드 영역을 새로운 코드로 교체하고 PCB에서 프로그램 카운터나 각종 레지스터, 파일 정보 등이 리셋됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img126.png&quot; alt=&quot;img126&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;exec-예제-코드-parent&quot;&gt;exec 예제 코드: parent&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent process!!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./child&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;child process failed to exec&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;exec-예제-코드-child&quot;&gt;exec 예제 코드: child&lt;/h6&gt;
&lt;div data-lang=&quot;C&quot; class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;child process!!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;실행-결과-1&quot;&gt;실행 결과&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img127.png&quot; alt=&quot;img127&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부모 프로세스가 먼저 종료되면 자식 프로세스도 종료되기 때문에 parent 코드에서 wait 함수를 통해 자식 프로세스와 동기화 시킵니다.&lt;/p&gt;

&lt;p&gt;parent를 실행하면 fork 시스템 호출에 의해 자식 프로세스가 생성되고, exec 시스템 호출에 의해 자식 프로세스는 child를 실행합니다. 코드 영역이 child 코드로 변경되었기 때문에 “child process failed to exec” 라는 메시지는 출력되지 않습니다.&lt;/p&gt;

&lt;p&gt;fork와 exec를 통해 프로세스를 생성하는 방식은 프로세스 생성 과정 전체를 거치지 않기 때문에 프로세스 생성 속도가 빠르고 추가 작업 없이 자원의 상속이 가능하여 시스템 관리에 효율적입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">프로세스(Process)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">운영체제</title>
      <link href="https://huimang2.github.io/etc/computer-operating-system" rel="alternate" type="text/html" title="운영체제" />
      <published>2023-06-17T01:00:00+09:00</published>
      <updated>2023-06-17T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-operating-system</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-operating-system">&lt;h1 id=&quot;운영체제operating-system란&quot;&gt;운영체제(Operating System)란?&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제(Operating System)&lt;/code&gt;는 컴퓨터의 자원을 효율적으로 운영하기위해 필요한 소프트웨어입니다. 대표적으로 윈도우(Windows), 맥 OS(Mac OS), 안드로이드(Android), 우분투(Ubuntu) 등이 운영체제입니다.&lt;/p&gt;

&lt;p&gt;모든 프로그램은 실행을 위해 자원을 필요로 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자원(Resource)&lt;/code&gt;이란 컴퓨터 시스템에서 작업을 수행하는 데 사용되는 모든 하드웨어 및 소프트웨어를 말하며, 앞서 설명했던 CPU, 메모리, 보조기억장치, 입출력장치 또한 자원입니다.&lt;/p&gt;

&lt;p&gt;명령어를 통해 이러한 자원을 효율적으로 관리하는 것은 여간 힘든 일이 아닙니다. 이를 돕는 것이 운영체제 입니다. 운영체제는 실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;컴퓨터가 켜지면 CPU는 ROM에 저장된 명령어를 읽습니다. ROM에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST(Power-On Self-Test)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부트로더(Boot loader)&lt;/code&gt;가 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;가장 먼저 실행되는 POST는 컴퓨터의 상태를 검사합니다. 요즘은 UEFI의 Fast boot 옵션으로 인해 생략되어 보기 힘들지만 예전에는 컴퓨터를 켜면 가장 먼저 보이는 화면이 POST를 실행하는 화면이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img113.png&quot; alt=&quot;img113&quot; /&gt;&lt;/p&gt;

&lt;p&gt;POST 작업이 끝나면 부트로더가 실행됩니다. 부트로더는 하드디스크에 있는 운영체제를 찾아 실행시키는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;실행되는 모든 프로그램은 메모리에 적재됩니다. 프로그램이 적재되는 공간은 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 영역&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 영역&lt;/code&gt;으로 나눌 수 있는데, 운영체제 역시 특별한 프로그램이기 때문에 메모리의 커널 영역에 적재됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img110.png&quot; alt=&quot;img110&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;운영체제의-기능&quot;&gt;운영체제의 기능&lt;/h1&gt;

&lt;h2 id=&quot;프로세스-관리&quot;&gt;프로세스 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스(process)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세서(procesor)&lt;/code&gt;를 관리합니다. 실행중인 프로그램을 프로세스라고 하며, 프로세스 작업을 하는 CPU를 프로세서라고 합니다. 프로세스는 메모리에 적재되어 실행되며, 수많은 프로세스들이 동시에 실행되고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img112.png&quot; alt=&quot;img112&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로세서는 한정된 자원을 가지기 때문에 여러 프로세스가 동시에 프로세서에 접근한다면 충돌이 발생할 수 있습니다. 그러므로 프로세스가 직접 프로세서에 접근하는 것이 아니라 운영체제가 프로세스를 관리하여 충돌 없이 프로세스가 실행될 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img111.png&quot; alt=&quot;img111&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 여러 프로세스를 빠르게 번갈아 실행시킴으로써 멀티테스킹을 하는 것처럼 보이도록 합니다.&lt;/p&gt;

&lt;h2 id=&quot;메모리-관리&quot;&gt;메모리 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 비어있는 메모리에 프로그램을 할당하고, 프로그램이 종료되면 메모리를 비워주는 등 메모리를 관리합니다.&lt;/p&gt;

&lt;p&gt;프로그램을 실행하기 위해서는 데이터를 보조기억장치의 특정 주소에서 가져오고 이를 메모리의 특정 주소에 할당하는 등의 복잡한 과정이 필요합니다. 하지만 운영체제가 자원을 관리하여 이러한 복잡한 절차없이 프로그램을 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;파일-시스템-관리&quot;&gt;파일 시스템 관리&lt;/h2&gt;

&lt;p&gt;운영체제는 보조기억장치의 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파일(file)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디렉토리(directory)&lt;/code&gt; 형태로 관리합니다. 윈도우에서는 디렉토리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴더(folder)&lt;/code&gt;라고 합니다. 디렉토리를 통해 사용자는 보조기억장치의 데이터에 쉽게 접근할 수 있으며, 파일을 통해 프로그램을 쉽게 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;사용자-인터페이스-제공&quot;&gt;사용자 인터페이스 제공&lt;/h2&gt;

&lt;p&gt;운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 인터페이스(User Interface)&lt;/code&gt;를 제공합니다. CLI를 통해 단순히 운영체제 명령어를 입력하는 것 만으로도 프로그램을 실행시킬 수 있습니다. 최근에는 GUI를 통해 아이콘을 클릭하거나 NUI를 통해 음성명령을 하는 것 만으로도 프로그램을 실행시킬 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;커널kernel과-쉘shell&quot;&gt;커널(Kernel)과 쉘(Shell)&lt;/h1&gt;

&lt;p&gt;운영체제는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kernel)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt;로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img114.png&quot; alt=&quot;img114&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널(Kernel)&lt;/code&gt;은 운영체제의 핵심 서비스를 담당하는 한 부분입니다. 운영체제는 종류에 따라 다른 기능을 제공하지만 운영체제의 핵심 서비스는 자원을 관리하는 것입니다.&lt;/p&gt;

&lt;p&gt;위에서 설명한 운영체제의 기능은 대부분 커널의 기능에 속하며, 사용자를 위한 프로그램이 아닌 시스템을 위한 프로그램 입니다. 즉, 커널은 하드웨어와 소프트웨어를 연결하는 인터페이스 입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리눅스 커널(Linux Kernel)&lt;/code&gt;이 있습니다. 안드로이드(Android)나 우분투(Ubuntu) 등은 오픈소스인 리눅스 커널을 기반으로 하는 운영체제 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;쉘(Shell)&lt;/code&gt;은 사용자와 커널을 연결하는 인터페이스 입니다. 커널은 시스템을 위한 프로그램이기 때문에 커널을 통해 직접 자원을 관리하는 것은 어렵습니다. 쉘은 커널의 복잡한 동작 방식을 알 필요 없이 간단한 명령어를 통해 사용자가 자원을 관리할 수 있도록 돕는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 윈도우의 &lt;strong&gt;명령어 프롬프트(Command Prompt)&lt;/strong&gt;, 우분투의 &lt;strong&gt;배쉬 쉘(Bash Sehll)&lt;/strong&gt; 등이 쉘입니다.&lt;/p&gt;

&lt;h1 id=&quot;이중-모드dual-mode&quot;&gt;이중 모드(Dual Mode)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이중 모드(Dual Mode)&lt;/code&gt;는 다중 프로그래밍 환경에서 자원에 대한 접근을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 모드(User Mode)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 모드(Kernel Mode)&lt;/code&gt;로 분리하여 운영체제를 보호하는 기법입니다.&lt;/p&gt;

&lt;p&gt;사용자와 운영체제는 시스템 자원을 공유합니다. 만약 사용자가 시스템 자원에 직접적으로 접근할 수 있다면 운영체제와 충돌하여 컴퓨터 시스템에 악영향을 미칠 수 있습니다. 그러므로 커널은 자신을 통해서만 자원에 접근할 수 있도록 제한합니다. 이때 CPU는 상태 레지스터의 슈퍼바이저 플래그를 통해 응용 프로그램의 명령어는 사용자 모드로, 커널의 명령어는 커널 모드로 구분하여 실행합니다.&lt;/p&gt;

&lt;p&gt;사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행 모드입니다. 즉, 커널 영역에 있는 운영체제 코드를 실행시킬 수 없습니다. 일반적으로 응용 프로그램은 사용자 모드로 실행되어 입출력 명령어 같은 자원에 접근하는 명령어를 실행 할 수 없습니다.&lt;/p&gt;

&lt;p&gt;커널 모드는 운영체제 서비스를 제공받을 수 있는 실행 모드입니다. 즉, 커널 영역에 있는 운영체제 코드를 실행시킬 수 있습니다. 운영체제는 커널 모드로 실행되기 때문에 자원에 접근할 수 있게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;시스템-호출system-call&quot;&gt;시스템 호출(System Call)&lt;/h1&gt;

&lt;p&gt;사용자 모드로 실행되는 응용 프로그램이 자원에 접근하기 위해서는 운영체제에 요청을 보내어 커널 모드로 전환되어야 하는데, 이 요청을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 호출(System Call)&lt;/code&gt;이라고 합니다. 즉, 응용 프로그램은 시스템 호출을 통해 운영체제 서비스를 제공받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img115.png&quot; alt=&quot;img115&quot; /&gt;&lt;/p&gt;

&lt;p&gt;시스템 호출은 일종의 인터럽트로, 소프트웨어 인터럽트 입니다. 하드웨어 인터럽트와 같이 시스템 호출을 하면 CPU는 기존 작업을 백업하고 인터럽트 서비스 루틴을 수행한 후 기존 작업을 이어서 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img116.png&quot; alt=&quot;img116&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오픈소스인 리눅스 커널의 시스템 콜은 다음 사이트에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md&quot; target=&quot;_blank&quot;&gt;Linux System Call Table&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;우분투에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt; 라는 도구를 통해 시스템 호출을 추적할 수 있습니다. 다음과 같이 간단한 코드를 작성해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img117.png&quot; alt=&quot;img117&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gcc로 컴파일 후 strace를 통해 해당 코드의 시스템 콜을 추적할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img118.png&quot; alt=&quot;img118&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">운영체제(Operating System)란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">입출력장치</title>
      <link href="https://huimang2.github.io/etc/computer-input-output-unit" rel="alternate" type="text/html" title="입출력장치" />
      <published>2023-06-11T01:00:00+09:00</published>
      <updated>2023-06-11T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-input-output-unit</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-input-output-unit">&lt;h1 id=&quot;장치-컨트롤러device-controller&quot;&gt;장치 컨트롤러(Device Controller)&lt;/h1&gt;

&lt;p&gt;입출력장치는 하드디스크, 마우스, 모니터 등과 같이 컴퓨터 외부에 연결되어 CPU와 정보를 교환할 수 있는 장치입니다.&lt;/p&gt;

&lt;p&gt;입출력 장치는 종류가 다양하기 때문에 CPU와 정보를 주고 받는 방식을 규격화하기 어렵습니다. 또한 CPU에 비하여 데이터 전송률이 낮기 때문에 CPU와 직접적으로 통신하게 되면 CPU의 성능이 좋더라도 이를 활용할 수 없게 됩니다. 이러한 문제를 해결하기 위한 하드웨어를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 컨트롤러(Device Controller)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크의-장치-컨트롤러&quot;&gt;하드디스크의 장치 컨트롤러&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img098.png&quot; alt=&quot;img098&quot; /&gt;&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 CPU와 입출력장치 간의 통신을 중개하여 각 장치들을 규격화 해주며, 오류를 검출하고 버퍼링을 통해 CPU와 데이터 전송률을 맞추는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 레지스터&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 레지스터&lt;/code&gt;로 구성되며, CPU는 버스를 통해 장치 컨트롤러에 데이터를 전송합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img099.png&quot; alt=&quot;img099&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 레지스터는 CPU와 입출력장치 사이에 주고 받을 데이터를 저장하는 레지스터로, 버퍼 역할을 합니다. 최근에는 입출력 장치와 주고 받을 데이터가 많아졌기 때문에 데이터 레지스터 대신에 RAM을 사용하기도 합니다.&lt;/p&gt;

&lt;p&gt;상태 레지스터는 입출력장치가 입출력 작업할 준비가 되었는지, 입출력 작업 완료가 되었는지, 입출력장치에 오류가 없는지 등의 상태 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;제어 레지스터는 입출력장치가 수행할 내용에 대한 제어 정보를 저장하는 레지스터 입니다.&lt;/p&gt;

&lt;h1 id=&quot;장치-드라이버device-driver&quot;&gt;장치 드라이버(Device Driver)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장치 드라이버(Device Driver)&lt;/code&gt;는 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램 입니다.&lt;/p&gt;

&lt;p&gt;장치 컨트롤러가 입출력장치를 연결하는 하드웨어라면, 장치 드라이버는 입출력장치를 연결하는 소프트웨어 입니다. 장치 드라이버를 통해 CPU가 입출력장치를 제어할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;usb-장치-드라이버&quot;&gt;USB 장치 드라이버&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img100.png&quot; alt=&quot;img100&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요즘은 OS가 장치 드라이버를 자동으로 설치해주는 경우가 많은데, 이전에는 프린터를 컴퓨터에 연결하여 사용하려면 해당 프린터에 대한 프린트 드라이버를 설치해야 했습니다. 장치 드라이버가 설치되지 않는다면 CPU가 프린터를 동작시키는 방식을 모르기 때문에 해당 프린터를 사용할 수 없게 됩니다. 즉, 장치 드라이버를 인식하고 실행하는 주체는 운영체제(OS) 입니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력-방식&quot;&gt;입출력 방식&lt;/h1&gt;

&lt;p&gt;입출력장치가 CPU와 정보를 교환하는 방식에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력&lt;/code&gt;이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;프로그램-입출력programmed-inputoutput-pio&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 입출력(Programmed Input/Output, PIO)&lt;/code&gt;은 프로그램 명령어를 통해 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송한 후 입출력장치의 상태를 주기적으로 확인하여 데이터 송수신을 제어합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 메모리에 저장된 정보를 하드디스크에 저장한다고 한다면 CPU는 쓰기 명령어를 전송하고 상태 레지스터의 확인하고 입출력 장치가 사용가능하다면 데이터를 전송합니다.&lt;/p&gt;

&lt;h6 id=&quot;하드디스크-쓰기-제어&quot;&gt;하드디스크 쓰기 제어&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img101.png&quot; alt=&quot;img101&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 주기적으로 상태 레지스터를 확인하는 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴링(Polling)&lt;/code&gt;이라고 하며, 그러므로 프로그램 입출력 방식을 폴링 방식이라고도 합니다.&lt;/p&gt;

&lt;h6 id=&quot;폴링-순환&quot;&gt;폴링 순환&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img102.png&quot; alt=&quot;img102&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 입출력 방식은 가장 간단하고 최소의 하드웨어를 필요로 하지만, 반복적으로 입출력장치의 상태를 점검하여 CPU의 효율을 저하시키키며 입출력이 완료될 때까지 CPU가 동작하지 못한다는 단점이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램 입출력 방식은 CPU가 입출력장치에 접근하는 방식에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;메모리-맵-입출력memmory-mapped-io&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 맵 입출력(Memmory-mapped I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소공간으로 취급하여 접근하는 방식입니다.&lt;/p&gt;

&lt;p&gt;메모리의 일부 공간을 입출력 포트에 할당하여 메모리 주소 공간이 축소되지만, 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 동일하기 때문에 CPU 로직이 단순해집니다. 주로 ARM 계열의 RISC에서 사용하며, LOAD나 STORE 명령을 통해 접근할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;고립형-입출력isolated-io&quot;&gt;고립형 입출력(Isolated I/O)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고립형 입출력(Isolated I/O)&lt;/code&gt;은 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 분리하는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;입출력장치에 접근하기 위한 별도의 명령어가 필요하고 CPU 로직이 복잡해지지만, 메모리 주소 공간 전체를 활용할 수 있습니다. 주로 x86 계열의 CISC에서 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-기반-입출력interrupt-driven-io&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 기반 입출력(Interrupt-Driven I/O)&lt;/code&gt;은 인터럽트를 기반으로 장치 컨트롤러를 제어하는 방식입니다. CPU에서 명령어를 전송하면 장치 컨트롤러에서 명령어를 수행한 후 CPU에 인터럽트 요청 신호를 보냅니다. 인터럽트 요청신호를 받은 CPU는 하던 일을 멈추고 인터럽트 서비스 루틴을 실행합니다.&lt;/p&gt;

&lt;p&gt;여러 입출력장치에서 인터럽트가 동시에 발생한 경우 우선순위를 고려하여 우선순위가 높은 인터럽트를 먼저 처리합니다. 우선순위를 반영한 인터럽트를 처리하는 방식에는 여러 방식이 존재하지만 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그래머블 인터럽트 컨트롤러(Programmable Interrupt Controller, PIC)&lt;/code&gt;라는 하드웨어를 사용하여 처리합니다.&lt;/p&gt;

&lt;h6 id=&quot;pic&quot;&gt;PIC&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img103.png&quot; alt=&quot;img103&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 장치 컨트롤러와 CPU 사이에서 어떤 인터럽트를 먼저 처리할 것인지를 판단하여 CPU에게 인터럽트 신호를 전송합니타.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img104.png&quot; alt=&quot;img104&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PIC는 보통 여러 개를 계층적으로 사용하여 사용하는 경우가 많습니다.&lt;/p&gt;

&lt;h2 id=&quot;dma-입출력direct-memory-access-io&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 입출력(Direct Memory Access I/O)&lt;/code&gt;은 입출력장치와 메모리가 CPU를 거치지 않고 상호작용할 수 있는 입출력 방식입니다.&lt;/p&gt;

&lt;p&gt;프로그램 입출력과 인터럽트 기반 입출력은 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거치게 되어 하드디스크 백업과 같은 대용량 데이터의 전송이 필요하다면 CPU의 부담이 커지게 됩니다. 이를 해결하기 위한 입출력 방식이 DMA 입출력 방식이며, DMA 입출력 방식은 입출력장치가 CPU를 거치지 않고 직접 메모리에 접근할 수 있습니다.&lt;/p&gt;

&lt;p&gt;DMA 입출력을 위해서는 시스템 버스에 연결된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA 컨트롤러&lt;/code&gt;라는 하드웨어가 필요합니다. CPU가 DMA 컨트롤러에 명령어를 보내면 DMA 컨트롤러는 CPU를 대신하여 입출력 작업을 수행하고, 입출력 작업이 끝나면 인터럽트 신호를 통해 CPU에게 입출력 작업이 끝났음을 알립니다. 그동안 CPU는 다른 작업을 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img105.png&quot; alt=&quot;img105&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img106.png&quot; alt=&quot;img106&quot; /&gt;
&lt;img src=&quot;/assets/images/computer/img107.png&quot; alt=&quot;img107&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 시스템 버스는 공용 자원이기 때문에 CPU와 DMA 컨트롤러는 동시에 시스템 버스를 사용할 수 없습니다. 그러므로 DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을때 조금씩 시스템 버스를 사용하거나 CPU가 일시적으로 시스템 버스를 사용하지 않도록 요청을 보내고 시스템 버스를 사용합니다.&lt;/p&gt;

&lt;p&gt;DMA 컨트롤러는 메모리에서 데이터를 가져오기 위해 시스템 버스를 한 번, 장치컨트롤러에 데이터를 전송하기 위해 시스템 버스를 또 한 번 사용하여 총 2번 사용하게 됩니다. 그만큼 CPU가 시스템 버스를 사용하지 못하는 문제가 발생하는데, 이를 해결하기 위해 입출력장치를 입출력 버스(I/O Bus)라는 별도의 버스에 연결하여 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img108.png&quot; alt=&quot;img108&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 그래픽 카드나 SSD를 연결하는 PCIe 슬롯은 입출력 버스와 연결됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img109.png&quot; alt=&quot;img109&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">장치 컨트롤러(Device Controller)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 파이프라인</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-pipeline" rel="alternate" type="text/html" title="명령어 파이프라인" />
      <published>2023-06-06T01:00:00+09:00</published>
      <updated>2023-06-06T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-pipeline</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-pipeline">&lt;h1 id=&quot;명령어-파이프라인instruction-pipeline&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 파이프라인(Instruction Pipeline)&lt;/code&gt;은 CPU의 성능을 향상시키기 위해 명령어 처리를 여러 단계로 나누어 동시에 실행하는 명령어 병렬 처리 기법입니다.&lt;/p&gt;

&lt;p&gt;CPU의 명령어가 처리되는 과정은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출(fetch)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행(execution)&lt;/code&gt; 2단계로 나눌 수 있다고 했는데, 이를 비슷한 시간 간격으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 인출(Instruction Fetch)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 해석(Instruction Decode)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 실행(Execute Instruction)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결과 저장(Write Back)&lt;/code&gt; 4단계로 나눌 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 명령어 인출(Instruction Fetch)&lt;/strong&gt; : 명령어를 기억장치로 부터 인출&lt;br /&gt;
&lt;strong&gt;2. 명령어 해석(Instruction Decode)&lt;/strong&gt; : 디코더를 사용하여 명령어 해석&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행(Execute Instruction)&lt;/strong&gt; : 해석된 명령어에 따라 데이터 연산을 수행&lt;br /&gt;
&lt;strong&gt;4. 결과 저장(Write Back)&lt;/strong&gt; : 명령어대로 처리된 데이터를 메모리에 기록&lt;/p&gt;

&lt;p&gt;만약 명령어 파이프라인을 사용하지 않는다면 다음과 같이 명령어가 순차적으로 실행 될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img088.png&quot; alt=&quot;img088&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어 파이프라인을 사용한다면 각 명령어를 겹쳐 동시에 실행함으로써 명령어 처리 시간을 줄여 CPU의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img089.png&quot; alt=&quot;img089&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;파이프라인-위험pipeline-hazard&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파이프라인 위험(Pipeline Hazard)&lt;/code&gt;은 파이프라인 기법을 사용하는데 있어서 발생할 수 있는 문제점을 말합니다.&lt;/p&gt;

&lt;p&gt;파이프라인 위험에는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt; 3가지로 나눌 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-위험data-hazard&quot;&gt;데이터 위험(Data Hazard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 위험(Data Hazard)&lt;/code&gt;은 명령어 간의 의존성으로 인해 아직 수행되지 않은 명령어의 결과값을 참조함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같이 명령어1, 명령어2가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;명령어1 : R&lt;sub&gt;1&lt;/sub&gt; ← R&lt;sub&gt;2&lt;/sub&gt; + R&lt;sub&gt;3&lt;/sub&gt;&lt;br /&gt;
명령어2 : R&lt;sub&gt;4&lt;/sub&gt; ← R&lt;sub&gt;1&lt;/sub&gt; * R&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어1은 R&lt;sub&gt;2&lt;/sub&gt;와 R&lt;sub&gt;3&lt;/sub&gt; 레지스터값을 더하여 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 저장하고, 명령어2는 R&lt;sub&gt;1&lt;/sub&gt;과 R&lt;sub&gt;2&lt;/sub&gt; 레지스터값을 곱하여 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장합니다.&lt;/p&gt;

&lt;p&gt;이 경우 아래와 같이 명령어 파이프라인을 사용한다면 R&lt;sub&gt;1&lt;/sub&gt; 레지스터에 명령어1의 저장단계가 수행되기 전에 명령어2의 인출 및 해석이 발생하기 때문에 잘못된 결과값이 R&lt;sub&gt;4&lt;/sub&gt; 레지스터에 저장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img090.png&quot; alt=&quot;img090&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 데이터 위험이라고 합니다. 데이터 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img091.png&quot; alt=&quot;img091&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;제어-위험control-harzard&quot;&gt;제어 위험(Control Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 위험(Control Harzard)&lt;/code&gt;은 Jump나 Call, Interupt 같은 분기 명령어에 의해 프로그램 카운터(PC)가 갑작스럽게 변함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;기본적으로 명령어는 프로그램 카운터가 순차적으로 증가하여 실행됩니다. 하지만 분기(branch) 명령어를 싱행하게 된다면 프로그램 카운터가 비순차적으로 변하기 때문에 동시에 실행되는 명령어가 필요없어지게 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img092.png&quot; alt=&quot;img092&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 제어 위험이라고 합니다. 제어 위험의 경우 인출 단계 이후에 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img093.png&quot; alt=&quot;img093&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;구조적-위험structural-harzard&quot;&gt;구조적 위험(Structural Harzard)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조적 위험(Structural Harzard)&lt;/code&gt;은 서로 다른 명령어가 같은 자원에 접근함으로써 발생하는 위험입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Load 명령어의 경우 데이터를 인출하기 위해 메모리에 접근하는 단계가 있어는데, 다음과 같이 동일한 레지스터에 쓰기 접근을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img094.png&quot; alt=&quot;img094&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 위험을 구조적 위험이라고 합니다. 구조적 위험의 경우 다음과 같이 명령어 단계가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연(Stall)&lt;/code&gt;됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img095.png&quot; alt=&quot;img095&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;슈퍼스칼라supserscalar&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;슈퍼스칼라(Supserscalar)&lt;/code&gt;는 CPU 내에 파이프라인을 여러 개 두어 명령어를 동시에 실행하는 기술로서, 멀티 스레드 프로세서를 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img096.png&quot; alt=&quot;img096&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이론적으로는 파이프라인 개수에 비례하여 CPU의 처리 속도가 증가하지만, 그만큼 파이프라인 위험도 증가하므로 실제로 파이프라인 개수에 비례하여 처리 속도가 증가하지는 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;명령어-집합-구조instruction-set-architecture-isa&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 집합 구조(Instruction set architecture, ISA)&lt;/code&gt;는 CPU가 이해할 수 있는 기계어 명령어들의 집합을 의미합니다. 하드웨어와 시스템 소프트웨어 사이의 인터페이스를 정의하며, 최하위 레벨의 프로그래밍 인터페이스로서 CPU가 실행할 수 있는 모든 명령어를 포함합니다.&lt;/p&gt;

&lt;p&gt;ISA를 물리적으로 구현한 CPU 내부의 하드웨어 구조를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마이크로 아키텍쳐(Micro Architecture)&lt;/code&gt;라고 합니다. CPU 제조사마다 마이크로 아키텍쳐가 다르므로 ISA 역시 서로 다릅니다. 대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;cisccomplex-instruction-set-computer&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CISC(Complex Instruction Set Computer)&lt;/code&gt;는 복잡한 명령어 집합을 가지는 CPU로서, 인텔이나 AMD의 x86, x86-64는 CISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;CISC는 복잡하고 다양한 가변 길이 명령어를 사용하며, 상대적으로 적은 수의 명령어만으로도 프로그램을 실행할 수 있습니다. 그렇기 때문에 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높은 아키텍쳐였으나, 가변 길이 명령어를 사용하므로 명령어 파이프라이닝이 불리하며 속도가 느리고 가격이 비싸다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 하드웨어 스택(Stack)이 내장되어 있으며, 서브루틴의 return 주소나 파라미터, 지역변수 등을 저장하는데 사용됩니다. 따라서 call, ret, push, pop 같은 명령어를 통해 스택 데이터를 관리할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;riscreduced-instruction-set-computer&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC(Reduced Instruction Set Computer)&lt;/code&gt;는 명령어 집합의 수를 줄여 하드웨어 구조를 간단하게 만든 CPU로서, ARM 계열의 CPU는 RISC 기반의 ISA를 사용합니다.&lt;/p&gt;

&lt;p&gt;RISC는 짧고 규격화된 명령어를 사용하여 명령어 파이프라이닝에 유리합니다. 또한 메모리 접근을 최소화 하고 많은 범용 레지스터를 사용하므로 속도가 빠르며, 전력소모가 적고 가격이 저렴합니다.&lt;/p&gt;

&lt;p&gt;CISC와 달리 스택 관련 명령어가 존재하지 않기 때문에 서브루틴의 return 주소나 파라미터, 지역변수 등은 소프트웨어적으로 처리해야 합니다.&lt;/p&gt;

&lt;h6 id=&quot;cisc--risc-비교&quot;&gt;CISC / RISC 비교&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img097.png&quot; alt=&quot;img097&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 파이프라인(Instruction Pipeline)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">명령어 사이클과 인터럽트</title>
      <link href="https://huimang2.github.io/etc/computer-instruction-cycle" rel="alternate" type="text/html" title="명령어 사이클과 인터럽트" />
      <published>2023-05-29T01:00:00+09:00</published>
      <updated>2023-05-29T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-instruction-cycle</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-instruction-cycle">&lt;h1 id=&quot;명령어-사이클instruction-cycle&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/h1&gt;

&lt;p&gt;CPU는 프로그램 명령어를 클럭에 따라 일정한 주기를 반복하여 실행하는데, 이 주기를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 사이클(Instruction Cycle)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 CPU가 하나의 명령어를 실행하는 데 필요한 전체 처리 과정으로서, CPU가 프로그램을 실행한 순간부터 전원을 끄거나 오류가 발생하여 프로그램이 중단될 때까지 반복됩니다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 주 기억 장치로부터 명령어를 읽어오는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인출 사이클(Fetch Cycle)&lt;/code&gt;과 명령어를 실행하는 단계인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행 사이클(Execution Cycle)&lt;/code&gt;로 분리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img079.png&quot; alt=&quot;img079&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인출-사이클fetch-cycle&quot;&gt;인출 사이클(Fetch Cycle)&lt;/h2&gt;

&lt;p&gt;인출 사이클의 진행은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img080.png&quot; alt=&quot;img080&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- PC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR], PC &amp;lt;- PC + 1&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : IR &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 프로그램 카운터(PC)에 저장된 명령어 주소를 CPU 내부 버스를 통해 메모리 주소 레지스터(MAR)로 보냅니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 명령어를 읽어서 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)에 저장합니다. 동시에 프로그램 카운터가 1 증가합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 명령어를 명령어 레지스터(IR)에 저장합니다.&lt;/p&gt;

&lt;h2 id=&quot;실행-사이클execution-cycle&quot;&gt;실행 사이클(Execution Cycle)&lt;/h2&gt;

&lt;p&gt;실행 사이클 동안에는 CPU가 명령어 코드를 해독(decode)하고, 그 결과에 따라 필요한 연산들을 수행합니다. CPU가 수행하는 연산에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 이동&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 처리&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 저장&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램 제어&lt;/code&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;명령어는 연산 코드(Operation Code)와 오퍼랜드(operand)로 구성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img081.png&quot; alt=&quot;img081&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 사이클에서 수행되는 마이크로 연산들은 명령어의 연산 코드에 의해 결정되며, 명령어 실행에 필요한 데이터가 저장된 주소는 오퍼랜드에 의해 결정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-이동-load-addr-명령어&quot;&gt;데이터 이동: Load addr 명령어&lt;/h3&gt;

&lt;p&gt;Load ddr 명령어은 기억장치에 저장되어 있는 데이터를 CPU 내부 누산기(AC)에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 MAR가 지정하는 기억장치 주소로부터 데이터를 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-저장-sta-addr-명령어&quot;&gt;데이터 저장: STA addr 명령어&lt;/h3&gt;

&lt;p&gt;STA addr 명령어은 누산기(AC)에 저장된 데이터를 기억장치에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- AC&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : M[MAR] &amp;lt;- MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 누산기(AC)에 저장된 데이터를 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 MAR가 지정하는 기억장치 주소에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-처리-add-addr-명령어&quot;&gt;데이터 처리: ADD addr 명령어&lt;/h3&gt;

&lt;p&gt;ADD addr 명령어은 기억장치에 저장된 데이터를 누산기(AC)에 저장된 값에 더하여 그 결과를 다시 누산기에 저장하는 명령어 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img082.png&quot; alt=&quot;img082&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : MAR &amp;lt;- IR(addr)&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; : MBR &amp;lt;- M[MAR]&lt;br /&gt;
&lt;strong&gt;t&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; : AC &amp;lt;- AC + MBR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫 번째 주기 t&lt;sub&gt;0&lt;/sub&gt;에서는 명령어 레지스터(IR)에 있는 오퍼랜드를 메모리 주소 레지스터(MAR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;두 번째 주기 t&lt;sub&gt;1&lt;/sub&gt;에서는 저장할 데이터를 MAR가 지정하는 기억장치 주소로부터 읽어서 메모리 버퍼 레지스터(MBR)에 저장합니다.&lt;/p&gt;

&lt;p&gt;세 번째 주기 t&lt;sub&gt;2&lt;/sub&gt;에서는 MBR에 저장된 데이터를 산술논리연산장치(ALU)에서 연산하여 그 결과값을 누산기(AC)에 저장합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로그램-제어-jump-addr-명령어&quot;&gt;프로그램 제어: JUMP addr 명령어&lt;/h3&gt;

&lt;p&gt;JUMP addr 명령어은 오퍼랜드가 가리키는 주소의 명령어로 실행 순서를 변경하는 분기(branch) 명령어 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;t&lt;sub&gt;0&lt;/sub&gt;&lt;/strong&gt; : PC &amp;lt;- IR(addr)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;명령어 레지스터(IR)에 저장된 오퍼랜드를 PC에 저장하여 명령어 순서를 변경합니다.&lt;/p&gt;

&lt;h1 id=&quot;인터럽트interrupt&quot;&gt;인터럽트(Interrupt)&lt;/h1&gt;

&lt;p&gt;인터럽트는 컴퓨터 내부나 외부에서 발생하는 갑작스러운 사건에 대응하는 기능입니다. 인터럽트 요청이 발생하면 CPU는 현재 처리 순서를 중단하고 요구된 인터럽트 서비스 프로그램을 먼저 수행하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img083.png&quot; alt=&quot;img083&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 그림처럼 명령어 사이클은 인출(fetch)과 실행(execution) 사이클이 반복되는데, 실행 사이클이 끝날때마다 CPU는 반복적으로 인터럽트 요청이 발생했는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img084.png&quot; alt=&quot;img084&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 요청이 발생했다면 프로그램 실행을 중단하고 인터럽트 처리를 합니다. 인터럽트 요청을 처리한 이후에는 다시 프로그램을 재실행합니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h2&gt;

&lt;p&gt;인터럽트는 크게 내부 인터럽트와 외부 인터럽트로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;내부 인터럽트&lt;/code&gt;는 다음과 같은 상황에서 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 하드웨어 고장&lt;/strong&gt; : 정전, 패리티 비터 오류 등&lt;br /&gt;
&lt;strong&gt;2. 실행할 수 없는 명령어&lt;/strong&gt; : 정의되지 않은 명령어&lt;br /&gt;
&lt;strong&gt;3. 명령어 실행 오류&lt;/strong&gt; : 0으로 나눈 경우&lt;br /&gt;
&lt;strong&gt;4. 사용 권한 위배&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주로 긴급한 상황에 발생하기 때문에 상태 레지스터의 인터럽트 플래그를 통한 제어가 불가능합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외부 인터럽트&lt;/code&gt;는 주로 입출력 장치에 의해 발생하며, 여기에는 타이머 인터럽트와 입출력 인터럽트가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 타이머 인터럽트&lt;/strong&gt; : 일정한 시간 간격으로 CPU에게 인터럽트를 요청합니다.&lt;br /&gt;
&lt;strong&gt;2. 입출력 인터럽트&lt;/strong&gt; : 속도가 비교적 느린 입출력장치의 사용 준비가 완료되었음을 알리기 위해 인터럽트를 요청합니다.&lt;/p&gt;

&lt;p&gt;외부 인터럽트는 인터럽트 플래그를 통해 제어할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-처리-순서&quot;&gt;인터럽트 처리 순서&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img087.png&quot; alt=&quot;img087&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 입출력장치에서 CPU에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 요청 신호(Interrupt Request, INTR)&lt;/code&gt;를 보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img085.png&quot; alt=&quot;img085&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; CPU는 실행 사이클을 끝내고 인터럽트 요청신호를 확인합니다. 인터럽트 요청을 확인 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 가능 플래그(Interrupt Enable Flag, IE)&lt;/code&gt;를 통해 현재 인터럽트를 받아들일 수 있는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img086.png&quot; alt=&quot;img086&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 인터럽트를 받아들일 수 있다면 현재 실행하던 프로그램을 중단하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC(Program Counter)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SR(Status Register)&lt;/code&gt;를 스택에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 벡터(Interrupt Vector)&lt;/code&gt;를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터럽트 서비스 루틴(Interrupt Service Routine, ISR)&lt;/code&gt;을 실행합니다.&lt;/p&gt;

&lt;p&gt;ISR는 인터럽트가 발생한 경우 인터럽트를 처리하기 위한 프로그램으로, 일반적으로 메모리에 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; ISR 실행이 끝나면 스택에 저장한 PC와 SR값을 복구하여 프래그램 실행을 재개합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">명령어 사이클(Instruction Cycle)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">레지스터와 카운터</title>
      <link href="https://huimang2.github.io/etc/computer-register-and-counter" rel="alternate" type="text/html" title="레지스터와 카운터" />
      <published>2023-05-19T01:00:00+09:00</published>
      <updated>2023-05-19T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-register-and-counter</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-register-and-counter">&lt;h1 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h1&gt;

&lt;p&gt;레지스터는 여러 비트를 저장하는 기억 소자입니다. 일반적으로 D 플립플롭으로 구성되어 있으며, 하나의 플립플롭은 1비트를 구성합니다. 즉, 8개의 플립플롭은 8비트, 16개의 플립플롭은 16비트 레지스터가 됩니다.&lt;/p&gt;

&lt;p&gt;레지스터는 주로 CPU 내부에서 연산결과를 중간저장하거나 데이터를 선택할 때 사용합니다.&lt;/p&gt;

&lt;h2 id=&quot;로드load-신호&quot;&gt;로드(Load) 신호&lt;/h2&gt;

&lt;p&gt;로드 신호는 레지스터를 동작시키는 신호입니다. 레지스터에 저장된 데이터를 입력값으로 변경시키는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img067.png&quot; alt=&quot;img067&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ClrN 신호는 비동기 카운터로 우선은 무시하시면 됩니다.&lt;/p&gt;

&lt;p&gt;로드(Load)는 클럭(Clk)과 AND 게이트로 연결하여 로드가 1일때 클럭 신호에 따라 레지스터 값을 변경할 수 있습니다. 그러나 클럭 신호가 다른 신호와 묶이는 경우 타이밍 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위해서 다음과 같이 레지스터의 CE(Clock Enable)에 로드를 연결하여 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img068.png&quot; alt=&quot;img068&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로드가 0인 경우 클럭 신호와 상관없이 레지스터에 저장된 데이터는 이전 상태를 유지하게 되며, 로드가 1인 경우 클럭 신호에 따라 레지스터의 데이터가 입력값으로 변경됩니다.&lt;/p&gt;

&lt;h2 id=&quot;쉬프트-레지스터shift-register&quot;&gt;쉬프트 레지스터(Shift Register)&lt;/h2&gt;

&lt;p&gt;쉬프트 레지스터는 플립플롭에 출력과 입력을 연결하는 방법에 따라 데이터를 왼쪽 또는 오른쪽으로 자리이동하는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;쉬프트 레지스터의 종류는 직렬 쉬프트 레지스터와 병렬 쉬프트 레지스터가 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;직렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 입력(Serial in, SI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 출력(Serial out, SO)&lt;/code&gt;을 가지는 레지스터로, 데이터가 한 번에 한 비트씩 쉬프트 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img069.png&quot; alt=&quot;img069&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Shift 신호는 CE와 연결되며, 신호가 1인 경우 쉬프트 레지스터가 동작하며, 신호가 0인 경우 데이터가 쉬프트 되지 않고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 초기 레지스터 값이 0101이고 직렬 입력(SI)이 1101인 경우 타이밍도는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img070.png&quot; alt=&quot;img070&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 번의 클럭 주기마다 데이터가 쉬프트 됨을 확인 할 수 있습니다. 또한 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되는데, 4번의 클럭 주기동안 SO는 초기 레지스터 값인 0101이 출력됨을 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;병렬 쉬프트 레지스터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 입력(Parallel in, PI)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 출력(Parallel out, PO)&lt;/code&gt;을 가지는 레지스터 이며, 다음과 같이 플립플롭과 멀티플렉서(MUX)를 통해 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img071.png&quot; alt=&quot;img071&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직렬 쉬프트 레지스터와 달리 한 클럭에 모든 데이터가 동시에 로드되고 동시에 출력됩니다. 이때 쉬프트 신호와 로드 신호가 멀티플렉서의 제어신호가 됩니다.&lt;/p&gt;

&lt;p&gt;쉬프트 신호가 1인 경우 로드 신호에 상관없이 데이터가 쉬프트되며, 쉬프트 신호가 0, 로드 신호가 1이면 레지스터에 데이터가 저장됩니다. 두 신호가 모두 0인 경우에는 레지스터 상태가 유지됩니다.&lt;/p&gt;

&lt;p&gt;위에 그림과 같이 Q&lt;sub&gt;0&lt;/sub&gt;는 직렬 출력(SO)이 되므로 병렬 데이터를 직렬 데이터로 변환하기 위해 해당 레지스터를 사용할 수도 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h1&gt;

&lt;p&gt;카운터는 고정된 순환 회로를 통해 클럭 펄스의 갯수를 처리하기 위한 논리회로입니다.&lt;/p&gt;

&lt;p&gt;대표적으로 2진수 값이 1씩 증가하는 2진 카운터가 있으며, n비트의 레지스터를 통해 2&lt;sup&gt;n&lt;/sup&gt;-1 까지 카운트할 수 있습니다. 예를 들어 3비트의 레지스터를 통해서는 0 ~ 7까지 카운트 할 수 있으며 다음과 같이 순환합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img072.png&quot; alt=&quot;img072&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카운터에는 동기식 카운터와 비동기식 카운터가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비동기식-카운터&quot;&gt;비동기식 카운터&lt;/h2&gt;

&lt;p&gt;리플 카운터라고도 불리는 비동기식 카운터는 이전 플립플롭의 출력이 다음 플립플롭의 클럭으로 사용되는 카운터 입니다.&lt;/p&gt;

&lt;p&gt;보통 J-K 플립플롭 또는 T 플립플롭으로 설계되며, 숫자가 증가하는 상향 카운터(Up Counter)와 숫자가 감소하는 하향 카운터(Down Counter)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img074.png&quot; alt=&quot;img074&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 카운터는 카운트가 1씩 증가하는 상향 카운터이며, 다음과 같은 타이밍도로 나타낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img073.png&quot; alt=&quot;img073&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Enable이 1인 경우 진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Clock 주기&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;10진수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;하향 카운터의 경우 Q’ 출력을 클럭으로 사용하며, 카운트가 1씩 감소합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img075.png&quot; alt=&quot;img075&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티플렉서를 통해 상하향 카운터를 만들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img076.png&quot; alt=&quot;img076&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비동기식 카운터는 동기식 카운터에 비해 회로는 간단하지만 전달지연이 커진다는 단점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;동기식-카운터&quot;&gt;동기식 카운터&lt;/h2&gt;

&lt;p&gt;동기식 카운터는 비동기식 카운터의 전달지연을 보완하기 위해 플립플롭에 공통의 클럭신호를 사용하는 카운터입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img077.png&quot; alt=&quot;img077&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 플립플롭은 동일한 클럭신호를 받으며, 이전 플립플롭의 출력이 1인 경우에만 다음 플립플롭이 토글됩니다.&lt;/p&gt;

&lt;h2 id=&quot;링-카운터&quot;&gt;링 카운터&lt;/h2&gt;

&lt;p&gt;링 카운터는 마지막 플립플롭의 출력이 첫 번째 플립플롭의 입력으로 피드백되는 링 형태로 구성된 카운터를 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img078.png&quot; alt=&quot;img078&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링카운터는 모든 플립플롭이 0이라면 000만 출력되기 때문에 최소한 1비트는 1로 프리셋할 필요가 있습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">레지스터(Register)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">논리회로</title>
      <link href="https://huimang2.github.io/etc/computer-logic-gate" rel="alternate" type="text/html" title="논리회로" />
      <published>2023-04-24T01:00:00+09:00</published>
      <updated>2023-04-24T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-logic-gate</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-logic-gate">&lt;p&gt;지난번 글에서 컴퓨터는 2진수를 통해 데이터를 인식한다고 설명했습니다. 트랜지스터는 전류가 흐르거나 흐르지 않는 상태를 통해 1 또는 0으로 나타낼 수 있습니다. 즉, 트랜지스터를 통해 컴퓨터가 인식할 수 있는 데이터를 나타낼 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;논리회로logic-gate&quot;&gt;논리회로(Logic Gate)&lt;/h1&gt;

&lt;p&gt;트랜지스터를 도식화하면 다음과 같은데, Gate에 전압을 걸어주거나 걸어주지 않는 것으로 Drain으로 전류를 흐르게 하거나 흐르지 않게 할 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img022.png&quot; alt=&quot;img022&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 트랜지스터의 특성을 통해 스위치 역할을 함으로써 &lt;code class=&quot;language-plaintext bgcolor blue highlighter-rouge&quot; style=&quot;color:royalblue&quot;&gt;논리회로(Logic Gate)&lt;/code&gt;를 만들 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;not-gate&quot;&gt;NOT gate&lt;/h2&gt;

&lt;p&gt;NOT gate는 참을 거짓으로, 거짓을 참으로 출력하는 회로입니다. 즉, Gate에 전류가 흐르면 거짓, 전류가 흐르지 않으면 참을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img023.png&quot; alt=&quot;img023&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A에 전류가 흐르지 않으면 GND로 전류가 흐르지 않아서 출력선으로 전류가 흐르게 됩니다. 즉, 참을 출력합니다.&lt;/p&gt;

&lt;p&gt;반면에 A에 전류가 흐르면 GND로 전류가 흐를 수 있어서 출력선으로는 전류가 흐르지 않습니다. 즉, 거짓을 출력합니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;NOT A&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \bar A $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img024.png&quot; alt=&quot;img024&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;and-gate&quot;&gt;AND gate&lt;/h2&gt;

&lt;p&gt;AND gate는 두 입력선이 모두 참이면 참, 아니면 거짓을 출력하는 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img025.png&quot; alt=&quot;img025&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-1&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A AND B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ A \cdot B $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img026.png&quot; alt=&quot;img026&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;or-gate&quot;&gt;OR gate&lt;/h2&gt;

&lt;p&gt;OR gate는 두 입력선 중 하나라도 참이면 참을 출력하는 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img027.png&quot; alt=&quot;img027&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-2&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A OR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ A + B $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img028.png&quot; alt=&quot;img028&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nand-gate&quot;&gt;NAND gate&lt;/h2&gt;

&lt;p&gt;NAND gate는 AND gate의 반대값을 출력하는 회로입니다. 즉, 모든 입력이 참일 경우에만 거짓을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img029.png&quot; alt=&quot;img029&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-3&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A NAND B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \overline {A \cdot B} $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img030.png&quot; alt=&quot;img030&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nor-gate&quot;&gt;NOR gate&lt;/h2&gt;

&lt;p&gt;NOR gate는 OR gate의 반대값을 출력하는 회로입니다. 즉, 두 입력선 중 하나라도 참일 경우에는 거짓을 출력합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img031.png&quot; alt=&quot;img031&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;진리표-4&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A NOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;논리식은 $ \overline {A + B} $로 나타내며, 기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img032.png&quot; alt=&quot;img032&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;xor-gate&quot;&gt;XOR gate&lt;/h2&gt;

&lt;p&gt;XOR gate는 배타적 논리합을 구현한 회로입니다. 즉, 두 입력선의 값이 서로 다른 경우에만 참을 출력합니다.
논리식은 $ A \oplus B $로 나타내며, $ \bar A \cdot B + A \cdot \bar B $와 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표-5&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar A \cdot B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ A \cdot \bar B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A XOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 논리식을 토대로 회로를 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img033.png&quot; alt=&quot;img033&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img034.png&quot; alt=&quot;img034&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;xnor-gate&quot;&gt;XNOR gate&lt;/h2&gt;

&lt;p&gt;XOR gate는 XOR gate의 반대값을 출력하는 회로입니다. 즉, 두 입력선의 값이 서로 같은 경우에만 참을 출력합니다.
논리식은 $ \overline {A \oplus B} $ 또는 $ A⊙B $로 나타내며, $ \bar A \cdot \bar B + A \cdot B $와 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;진리표-6&quot;&gt;진리표&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar A \cdot \bar B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ A \cdot B $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A XNOR B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 논리식을 토대로 회로를 구성하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img035.png&quot; alt=&quot;img035&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기호는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img036.png&quot; alt=&quot;img036&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;조합회로combinational-circuit&quot;&gt;조합회로(Combinational Circuit)&lt;/h1&gt;

&lt;p&gt;조합회로는 출력값이 입력값에만 영향을 받는 논리회로입니다. 논리회로에 입력이 주어지면 바로 출력이 나오며, 이전의 회로 상태가 출력에 영향을 미치지 않습니다. 즉, 메모리 소자를 가지지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;가산기adder&quot;&gt;가산기(Adder)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가산기(Adder)&lt;/code&gt;는 입력들의 합을 출력하는 논리회로입니다. 가산기에는 2개의 입력을 더하는 반가산기(Half Adder, HA)와, 3개의 입력을 더하는 전가산기(Full Adder, FA)가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. 반가산기(Half Adder, HA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반가산기(HA)&lt;/code&gt;는 2진수 한 자리를 덧셈하여 캐리(Carry)와 덧셈의 결과를 출력합니다. 반가산기의 진리표는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;캐리(C)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;덧셈(S)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;진리표를 보면, 올림수인 캐리는 AND gate, 덧셈의 결과는 XOR gate와 동일함을 알 수 있습니다. 회로는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img037.png&quot; alt=&quot;img037&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반가산기의 경우 캐리에 대한 입력을 받지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최하위 비트(Least Significant Bit, LSB)&lt;/code&gt;에서만 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 전가산기(Full Adder, FA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전가산기(FA)&lt;/code&gt;는 반가산기에 캐리를 추가한 3개의 입력을 더하여 캐리와 덧셈의 결과를 출력하는 회로입니다. 전가산기의 진리표는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C&lt;sub&gt;in&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;C&lt;sub&gt;out&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;진리표만으로는 회로를 설계하기 어렵습니다. 논리식을 설계하기위해 카르노맵을 그려보겠습니다. 카르노맵에 대한 설명은 이 글에서 생략합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img038.png&quot; alt=&quot;img038&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카르노맵을 통해 다음과 같은 논리식을 설계할 수 있습니다.&lt;/p&gt;

&lt;p&gt;$$
\begin{aligned}
C_{out}
&amp;amp;= \bar A \cdot B \cdot C_{in} + A \cdot \bar B \cdot C_{in} + A \cdot B \cdot \bar C_{in} + A \cdot B \cdot C_{in} \\
&amp;amp;= (\bar A \cdot B + A \cdot \bar B) \cdot C_{in} + A \cdot B \cdot (\bar C_{in} + C_{in}) \\
&amp;amp;= (A \oplus B) \cdot C_{in} + A \cdot B \\
\\
S &amp;amp;= \bar A \cdot B \cdot \bar C_{in} + A \cdot \bar B \cdot \bar C_{in} + \bar A \cdot \bar B \cdot C_{in} + A \cdot B \cdot C_{in} \\
&amp;amp;= (\bar A \cdot B + A \cdot \bar B) \cdot \bar C_{in} + (\bar A \cdot \bar B + A \cdot B) \cdot C_{in} \\
&amp;amp;= A \oplus B \cdot \bar C_{in} + A \odot B \cdot C_{in} \\
&amp;amp;= A \oplus B \cdot \bar C_{in} + \overline{A \oplus B} \cdot C_{in} \\
&amp;amp;= A \oplus B \oplus C_{in}
\end{aligned}
$$&lt;/p&gt;

&lt;p&gt;해당 논리식을 토대로 회로를 그리면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img039.png&quot; alt=&quot;img039&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2개의 반가산기와 OR gate로 구성되어 있음을 알 수 있습니다. 간략화하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img040.png&quot; alt=&quot;img040&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전가산기 n개를 병렬로 연결한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리플 캐리 가산기(Ripple Cary Adder)&lt;/code&gt;라는 n비트 가산기를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img041.png&quot; alt=&quot;img041&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가산기의 B 입력을 부호 플래그와 XOR하여 사용한다면 덧셈과 뺄셈이 모두 가능한 회로가 됩니다. 이것은 2의 보수법을 이용한 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img042.png&quot; alt=&quot;img042&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. 캐리 예측 가산기(Carry Look-ahead Adder, CLA)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리플 캐리 가산기는 전가산기를 통해 간단하게 설계할 수 있지만, 비트수가 늘어날수록 연산속도가 느려진다는 문제가 있습니다. 왜냐하면 캐리를 입력으로 받기 때문에 상위 비트는 하위 비트가 계산될 때까지 연산을 하지 못하고 대기해야 하기 때문입니다. 이것을 해결하기 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;캐리 예측 가산기(CLA)&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;캐리 예측 가산기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 전가산기(Partial Full Adder, PFA)&lt;/code&gt;로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생성(Generation)&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전파(Propagation)&lt;/code&gt; 함수를 입력받아 이전 비트의 계산결과를 기다릴 필요 없이 연산을 한번에 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분 전가산기(PFA)&lt;/code&gt;는 전가산기(FA)에서 캐리 생성과 관련된 회로를 제외한 회로입니다. 캐리는 PFA에서 2개의 출력선에 의해 결정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img043.png&quot; alt=&quot;img043&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;생성(G) 함수&lt;/strong&gt;는 이전 비트의 결과값에 상관없이 캐리의 생성여부를 결정합니다. 부분 전가산기의 AND gate에 의해 출력된 값이 이에 해당합니다.&lt;/p&gt;

&lt;p&gt;$ G(A, B) = A \cdot B $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;전파(P) 함수&lt;/strong&gt;는 이전 비트의 결과값에 따른 캐리의 생성여부를 출력합니다. 부분 전가산기의 XOR gate에 의해 출력된 값이 이에 해당합니다.&lt;/p&gt;

&lt;p&gt;$ P(A, B) = A \oplus B $&lt;/p&gt;

&lt;p&gt;G와 P를 통해 S와 C를 구하는 논리식을 다음과 같이 세울 수 있습니다.&lt;/p&gt;

&lt;p&gt;$$
S_{i} = P_{i} \oplus C_{i} \\
C_{i+1} = G_{i} + P_{i} \cdot C_{i}
$$&lt;/p&gt;

&lt;p&gt;부분 전가산기 4개로 4비트 전가산기를 구성한다면 4개의 캐리에 대한 회로를 구성해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img044.png&quot; alt=&quot;img044&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 구성된 4비트 가산기를 2개 연결하면 8비트 가산기, 4개 연결하면 16비트 가산기를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img045.png&quot; alt=&quot;img045&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;디코더decoder--인코더encoder&quot;&gt;디코더(Decoder) / 인코더(Encoder)&lt;/h2&gt;

&lt;p&gt;디코더는 입력 변수들의 최소항(minterm)을 생성하는 논리회로입니다. n개의 입력을 통해 2&lt;sup&gt;n&lt;/sup&gt;개의 최소항을 출력합니다.&lt;/p&gt;

&lt;p&gt;최소항은 진리표에서 하나의 행만 1이 되고 나머지는 0이 되는 곱을 말합니다. 예를 들어 2개의 입력을 통해 다음과 같이 4개의 최소항을 생성할 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;해당 진리표를 통해 다음과 같이 회로를 그릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img046.png&quot; alt=&quot;img046&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 회로를 활성화 또는 비활성화 시키기위해 다음과 같이 Enable 입력을 연결하면 2X4 디코더가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img047.png&quot; alt=&quot;img047&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2X4 디코더를 2개 연결한다면 3X8 디코더를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img048.png&quot; alt=&quot;img048&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;인코더는 디코더의 반대입니다. 2&lt;sup&gt;n&lt;/sup&gt;개의 입력으로 부터 n개의 이진코드를 출력합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;인코더는 OR gate를 통해 간단하게 회로를 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img049.png&quot; alt=&quot;img049&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인코더를 통해 암호화된 출력이 디코더의 입력이 된다면 원래의 입력으로 해독할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img050.png&quot; alt=&quot;img050&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티플렉서multiplexer-mux&quot;&gt;멀티플렉서(Multiplexer, MUX)&lt;/h2&gt;

&lt;p&gt;멀티플렉서는 n개의 선택선 입력을 통해 2n개의 데이터 입력 중 하나를 선택하여 출력선으로 연결하는 논리회로입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 선택기(Data Selector)&lt;/code&gt;라고도 불립니다.&lt;/p&gt;

&lt;p&gt;CPU에서 연산을 하기 위해서는 RAM으로부터 데이터를 가져와야합니다. 이때 데이터를 가져오는 가장 간단한 방법은 램과 레지스터를 1:1로 연결하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img051.png&quot; alt=&quot;img051&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4비트만 연결해도 16개의 출력선이 필요하여 너무 복잡해집니다. 이를 해결하기 위해 멀티플렉서를 사용합니다. 멀티플렉서는 여러 입력 가운데서 하나의 입력을 선택하여 출력합니다.&lt;/p&gt;

&lt;p&gt;n개의 제어 입력을 통해 2&lt;sup&gt;n&lt;/sup&gt;개의 데이터 입력을 제어할 수 있습니다. 아래는 4비트의 입력선을 제어하기 위한 4X1 멀티플렉서 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img052.png&quot; alt=&quot;img052&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어 입력선은 디코더와 동일하며, 디코더의 출력선은 데이터 입력선과 AND 연산을 통해 입력선을 선택할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;멀티플렉서를 통해 메모리에서 출력된 데이터는 버스(bus)를 통해 CPU의 레지스터로 전달됩니다. 이때 2&lt;sup&gt;n&lt;/sup&gt;개의 출력선 중 하나를 선택하여 전송하는데, 이것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디멀티플렉서(Demultiplexer, DMUX)&lt;/code&gt;에 의해 수행됩니다.&lt;/p&gt;

&lt;p&gt;디멀티플렉서의 회로 또한 n개의 제어 입력이 필요하며, 하나의 데이터 입력선과 AND 연산을 통해 출력선을 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img053.png&quot; alt=&quot;img053&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;순차회로sequential-circuit&quot;&gt;순차회로(Sequential Circuit)&lt;/h1&gt;

&lt;p&gt;순차회로는 출력값이 이전 상태와 현재 입력값에 영향을 받는 논리회로입니다. 즉, 조합회로에 기억 기능이 추가된 회로입니다.&lt;/p&gt;

&lt;p&gt;순차회로는 클럭 신호에 의해 상태가 변하는 동기회로와 그렇지 않은 비동기회로로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;순차회로가 1비트의 정보를 기억하는 방법은 피드백(Feedback) 경로라 불리는 폐루프를 형성하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img054.png&quot; alt=&quot;img054&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 회로와 같이 피드백을 통해 NOT 게이트 사이에 비트 정보를 저장할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;래치latch&quot;&gt;래치(Latch)&lt;/h2&gt;

&lt;p&gt;래치는 클럭 입력을 가지지 않는 비동기회로입니다. 래치는 SR래치와 D래치가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. S-R 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SR래치에서 S는 Set을 의미하며 1을 출력하고, R은 Reset을 의미하며 0을 출력합니다. 각각의 출력 Q와 Q’은 다시 입력으로 들어가서 피드백을 형성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img055.png&quot; alt=&quot;img055&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;R&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$ R = 1, S = 0 $ 이면 $ Q = 0$ 이 출력되며, 출력된 Q는 S가 연결된 NOR 게이트로 피드백됩니다. $ S = 0 $ 이므로 $ \bar Q = 1 $ 이 출력되며, 출력된 $ \bar Q $ 는 R이 연결된 NOR 게이트로 피드백 됩니다. R이 연결된 NOR 게이트의 입력은 1, 1이 되므로 $ Q = 0 $ 이 되어 Reset 상태가 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ Q = 0, \bar Q = 1 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;반면 $ R = 0, S = 1 $ 이면 $ \bar Q = 0 $ 이 출력되며, 출력된 $ \bar Q $ 는 R이 연결된 NOR 게이트로 피드백됩니다. $ R = 0 $ 이므로 $ Q = 1 $ 이 출력되며, 출력된 Q는 S가 연결된 NOR 게이트로 피드백됩니다. NOR 게이트의 입력은 1, 1이 되므로 $ \bar Q = 0 $ 이 되어 Set 상태가 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ Q = 1, \bar Q = 0 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;$ R = 0, S = 0 $ 이면 $ Q = Q, \bar Q = \bar Q $ 가 되어 상태가 유지되며, $ R = 1, S = 1 $ 이면 Q와 $ \bar Q $ 가 0, 1 로 진동하게 되므로 입력이 제한됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;NAND 게이트를 사용하여 SR 래치를 만들 수도 있습니다. 이 경우 입력이 반전됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img056.png&quot; alt=&quot;img056&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;S&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;R&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$ R = 0, S = 1 $ 이면 $ Q = 0, \bar Q = 1 $ 이 되어 reset 상태가 되며, $ R = 1, S = 0 $ 이면 $ Q = 1, \bar Q = 0 $ 이 되어 set 상태가 됩니다.&lt;/p&gt;

&lt;p&gt;또한 $ R = 0, S = 0 $ 이면 Q와 $ \bar Q $ 가 0, 1 로 진동하므로 입력이 제한되며, $ R = 1, S = 1 $ 이면 $ Q = Q, \bar Q = \bar Q $ 가 되어 상태가 유지됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 게이트형 S-R 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게이트형 SR 래치는 Enable 이라 불리는 게이트 신호를 통해 출력을 결정하는 기억회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img057.png&quot; alt=&quot;img057&quot; /&gt;&lt;/p&gt;

&lt;p&gt;E 신호가 HIGH인 경우 래치의 입력이 출력에 반영되고, E 신호가 LOW인 경우 래치의 입력은 출력에 반영되지 않고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. D 래치&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;D 래치는 하나의 입력을 통해 출력 Q를 결정하는 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img058.png&quot; alt=&quot;img058&quot; /&gt;&lt;/p&gt;

&lt;p&gt;S = 0, R = 0 인 입력과 S = 1, R = 1 인 입력을 배제하여 입력과 출력이 동일한 회로를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;D&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;플립플롭flip-flop&quot;&gt;플립플롭(Flip-Flop)&lt;/h2&gt;

&lt;p&gt;플립플롭은 클럭 입력을 가지는 동기회로입니다.&lt;/p&gt;

&lt;p&gt;엄밀하게 말하자면 래치 또한 클럭신호를 가질 수 있습니다. 하지만 CLOCK 신호가 HIGH인 동안 동작하는 래치와 달리 플립플롭의 경우 CLOCK 신호가 HIGH가 되는 순간에만 동작합니다.&lt;/p&gt;

&lt;h6 id=&quot;래치의-경우&quot;&gt;래치의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img059.png&quot; alt=&quot;img059&quot; /&gt;&lt;/p&gt;

&lt;p&gt;래치는 위와 같이 CLOCK이 HIGH이면 INPUT을 출력하고 CLOCK이 LOW이면 상태를 유지합니다.&lt;/p&gt;

&lt;h6 id=&quot;플립플롭의-경우&quot;&gt;플립플롭의 경우&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img060.png&quot; alt=&quot;img060&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플립플롭의 경우 CLOCK이 HIGH가 되는 순간에만 INPUT을 출력하고 상태를 유지합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. S-R 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;S-R 플립플롭은 다음과 같이 게이트형 S-R 래치 2개로 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img061.png&quot; alt=&quot;img061&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에 있는 래치를 마스터, 뒤에 있는 래치를 슬레이브라고 하기때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마스터-슬레이브 플립플롭&lt;/code&gt;이라고도 합니다.&lt;/p&gt;

&lt;p&gt;아래 타이밍을 살펴보면 CLOCK이 HIGH인 순간에만 Q&lt;sub&gt;1&lt;/sub&gt;의 상태가 Q&lt;sub&gt;2&lt;/sub&gt;에 반영되고 &lt;sub&gt;2&lt;/sub&gt;의 상태가 유지되는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img062.png&quot; alt=&quot;img062&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. D 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;D 플립플롭은 다음과 같이 D 래치 2개로 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img063.png&quot; alt=&quot;img063&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. J-K 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JK 플립플롭은 S = 1, R = 1 입력이 제한되는 문제를 보완하기 위한 회로입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img064.png&quot; alt=&quot;img064&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 회로를 JK 래치라고 하며, J = 1, K = 1이 입력되면 $ Q = \bar Q $ 로 토글됩니다. 물론 하나의 JK 래치로는 반복적으로 토글되므로 2개의 JK 래치를 통해 플립플롭으로 구성한다면 CLOCK이 HIGH가 되는 순간에만 토글이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img065.png&quot; alt=&quot;img065&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;J&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;K&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$ \bar Q $&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Q&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. T 플립플롭&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;T 플립플롭은 JK 플립플롭에서 D 플립플롯처럼 입력을 하나만 주는 회로입니다. T가 0이면 이전값을 유지하고, T가 1이면 출력값이 토글 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer/img066.png&quot; alt=&quot;img066&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진리표는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;T&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Q&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;유지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;토글&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">지난번 글에서 컴퓨터는 2진수를 통해 데이터를 인식한다고 설명했습니다. 트랜지스터는 전류가 흐르거나 흐르지 않는 상태를 통해 1 또는 0으로 나타낼 수 있습니다. 즉, 트랜지스터를 통해 컴퓨터가 인식할 수 있는 데이터를 나타낼 수 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">데이터의 표현</title>
      <link href="https://huimang2.github.io/etc/computer-binary" rel="alternate" type="text/html" title="데이터의 표현" />
      <published>2023-04-23T01:00:00+09:00</published>
      <updated>2023-04-23T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-binary</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-binary">&lt;p&gt;지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;정보의-단위&quot;&gt;정보의 단위&lt;/h1&gt;

&lt;p&gt;컴퓨터는 MOSFET을 통해 전류가 흐르거나 흐르지 않는 상태를 인식할 수 있습니다. 전류가 흐르면 1, 전류가 흐르지 않는다면 0으로 나타낼 수 있는데, 이렇게 0과 1을 표현하는 가장 작은 정보 단위를 비트(bit)라고 합니다.&lt;/p&gt;

&lt;p&gt;1비트를 통해서는 2가지 정보를 알 수 있으며, 2비트로는 (0, 0), (0, 1), (1, 0), (1, 1) 이렇게 4가지 정보를 알 수 있습니다. n비트를 통해서는 &lt;strong class=&quot;bgcolor orange&quot; style=&quot;color:orangered&quot;&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/strong&gt;가지 정보를 표현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로그램은 수많은 비트로 이루어져 있어서 비트 단위로 데이터를 나타내기 힘들기 때문에, 데이터는 8개의 비트를 묶어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바이트(byte)&lt;/code&gt;를 정보의 기본단위로 사용합니다. 즉, 1byte는 8bit에 해당하며, 2&lt;sup&gt;8&lt;/sup&gt; = 256가지의 정보를 나타낼 수 있습니다. 보통 1byte로는 하나의 문자를 나타낼 수 있지만, 한글이나 한자 등 동양권 문자의 경우 1byte로 나타낼 수 없어서 하나의 문자당 2byte를 사용합니다.&lt;/p&gt;

&lt;p&gt;8bit가 모여 1byte가 된 것처럼, byte는 1000개씩 묶어 더 큰 단위를 나타낼 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;데이터-단위&quot;&gt;데이터 단위&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;단위&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;정의&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트(bit)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0, 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;바이트(Byte)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8 bit&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;킬로바이트(KB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메가바이트(MB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 KB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기가바이트(GB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 MB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;테라바이트(TB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 GB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;페타바이트(PB)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1000 TB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 외에도 CPU가 한 번에 처리할 수 있는 정보의 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;워드(word)&lt;/code&gt;로 나타냅니다.&lt;/p&gt;

&lt;h1 id=&quot;이진법&quot;&gt;이진법&lt;/h1&gt;

&lt;p&gt;컴퓨터는 0과 1을 사용하는 2진법(binary)을 통해 데이터를 이해합니다. 2진법은 자릿값이 올라감에 따라 그 크기가 2배씩 커지게 되므로 2진법을 십진법으로 바꾸기 위해서는 자릿수마다 2&lt;sup&gt;n&lt;/sup&gt;을 곱한 값을 모두 더하면 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어 이진수 0b1101을 십진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b1101 = 1 * 2&lt;sup&gt;3&lt;/sup&gt; + 1 * 2&lt;sup&gt;2&lt;/sup&gt; + 0 * 2&lt;sup&gt;1&lt;/sup&gt; + 1 * 2&lt;sup&gt;0&lt;/sup&gt; = 8 + 4 + 1 = 13&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴퓨터가 이진수로 음수를 표현하는 방법은 3가지가 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;부호-비트와-절댓값-방법&quot;&gt;부호 비트와 절댓값 방법&lt;/h2&gt;

&lt;p&gt;2진법으로 수를 표현할 때, 가장 왼쪽에 있는 비트의 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위 비트(Most Significant Bit, MSB)&lt;/code&gt;라고 합니다. 부호 비트와 절댓값 방법은 최상위 비트를 이용하여 음수를 표현합니다.&lt;/p&gt;

&lt;p&gt;예를 정수 13의 경우 다음과 같이 2진법으로 나타낼 수 있습니다.(보통 정수 자료형은 4byte의 크기를 가집니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 -13으로 나타내기 위해서는 최상위 비트를 1로 바꾸면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 1비트가 부호를 표현하기 위해 사용되어 표현할 수 있는 절대값의 범위는 절반으로 줄어들게 됩니다. (0 ~ 2&lt;sup&gt;16&lt;/sup&gt; - 1)&lt;/p&gt;

&lt;p&gt;또한 +0과 -0이 따로 존재하게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;1의-보수법&quot;&gt;1의 보수법&lt;/h2&gt;

&lt;p&gt;1의 보수법은 비트를 반전시켜 음수를 표현하는 방법입니다. 이 방법을 사용하면 비트의 NOT 연산만으로도 음수를 표현할 수 있어서 연산이 간단해집니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법을 통해 연산을 하는 데 있어서 캐리(carry)가 중요합니다. 캐리는 상태 레지스터의 플래그를 설명할 때 언급한 적이 있는데, 올림수나 빌림수 여부를 나타냅니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;캐리를 최하위 비트에 더해주면 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0b0111 + 0b0001 = 0b1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 2진수는 10진수로 나타내면 8이 되며, 이는 13 - 5와 동일한 결과입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 1의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0010&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0111&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 1의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법은 부호 비트와 절댓값 방법과 마찬가지로 +0과 -0이 따로 존재한다는 문제점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;2의-보수법&quot;&gt;2의 보수법&lt;/h2&gt;

&lt;p&gt;2의 보수법은 1의 보수법을 통해 표현한 값에 1을 더하여 음수를 표현하는 방법입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13을 음수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2의 보수법을 통해 연산을 하는 데 있어서 1의 보수법과 달리 캐리가 발생하면 캐리를 버립니다.&lt;/p&gt;

&lt;p&gt;예를 들어 13 - 5 를 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;13을 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-5를 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두 수를 더하면 다음과 같이 캐리가 생깁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;font color=&quot;skyblue&quot;&gt;1&lt;/font&gt; 0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1의 보수법과 달리 캐리를 버린 값이 최종 결과값이 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;이번에는 5 - 13 을 계산해보겠습니다.&lt;/p&gt;

&lt;p&gt;5를 2진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 0101&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-13을 2의 보수법을 통해 이진수로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 0011&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;두수를 더하면 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1111 1111 1111 1111 1111 1111 1111 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 결과는 캐리가 없습니다. 이 경우 결과값을 다시 2의 보수법으로 나타내면 최종 결과값이 됩니다. 부호는 마이너스(-) 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000 0000 0000 0000 0000 0000 0000 1000&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방법을 사용하면 -0은 2의 보수를 구하는 과정에서 최상위 비트를 초과한 오버플로우가 발생하여 +0이 됩니다. 그러므로 2의 보수법에서는 하나의 0만 존재하게 됩니다. 때문에 현재 대부분의 시스템에서는 2의 보수법을 사용하여 음수를 표현합니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">지난번 글에서는 CPU의 작동원리에 대하여 알아보았습니다. MOSFET에 전압을 주거나 주지 않는 것으로 전류 흐름을 제어했습니다. 이번 글에서는 컴퓨터가 데이터를 인식하는 원리를 알아보도록 하겠습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CPU의 작동 원리</title>
      <link href="https://huimang2.github.io/etc/computer-cpu" rel="alternate" type="text/html" title="CPU의 작동 원리" />
      <published>2023-04-22T01:00:00+09:00</published>
      <updated>2023-04-22T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-cpu</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-cpu">&lt;p&gt;CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img003.png&quot; alt=&quot;img003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원자는 최외각 전자가 8개일 때 가장 안정적인 구조를 가지게 되므로 순수한 실리콘의 경우 전자가 이동하지 않으므로 전류가 흐를 수 없습니다. 그러므로 최외각 전자가 3개이거나 5개인 원소를 첨가하여 전류가 흐를 수 있는 상태로 만들게 되는데, 이 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;도핑(Doping)&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;붕소(B)와 같이 최외각 전자가 3개인 원소를 첨가하게 되면 빈 자리가 생기게 되는데, 이를 양공이라고 합니다. 공유결합하고 있는 최외각 전자가 양공으로 이동하면서 전류가 흐를 수 있으며, 해당 반도체를 P형 반도체라고 합니다.&lt;/p&gt;

&lt;p&gt;인(P)과 같이 최외각 전자가 5개인 원소를 첨가하게 되면 자유전자가 1개 늘어 전류가 흐를 수 있으며, 해당 반도체는 N형 반도체라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img004.png&quot; alt=&quot;img004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 반도체는 전기적으로 중성상태에 있습니다. 두 반도체를 서로 연결한다면 N형 반도체의 자유전자가 P형 반도체의 양공으로 이동하게 됩니다.&lt;/p&gt;

&lt;p&gt;N형 반도체는 상대적으로 자유전자를 빼앗겨 (+)전하를 가지게 되고, P형 반도체는 상대적으로 자유전자를 얻으면서 (-)전하를 가지게 되면서 전기장이 형성됩니다.&lt;/p&gt;

&lt;p&gt;어느정도 이동하다가 P형 반도체의 전자 반발력으로 인해 자유전자가 양공으로 이동하지 못하게 되는데, 이때 양공이 채워져 더이상 전자가 이동할 수 없는 영역을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공핍영역&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img005.png&quot; alt=&quot;img005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 건전지의 (+)극을 N형 반도체에 연결하고 (-)극을 P형 반도체에 연결한다면 공핍영역이 넓어져 전자가 이동할 수
없습니다. 이것을 역방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img006.png&quot; alt=&quot;img006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 반대로 연결한다면 공핍영역의 전기장을 극복하고 전자가 P형 반도체에서 N형 반도체로 이동하면서 전류가 흐를 수 있게 됩니다. 이것은 순방향 연결이라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img007.png&quot; alt=&quot;img007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;건전지를 순방향으로 연결할 때만 전류가 흐를 수 있으며, 이때 전류의 방향은 P형 반도체에서 N형 반도체로 흐릅니다. 즉, 전류를 한방향으로 흐를 수 있게 하는데, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다이오드(Diode)&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img008.png&quot; alt=&quot;img008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여담으로 전자가 공핍영역을 지날 때 빛으로 에너지를 발산하기도 하는데, 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;발광 다이오드(Light Emitting Diode)&lt;/code&gt; 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LED&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img009.png&quot; alt=&quot;img009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 2개의 P형 반도체 사이에 N형 반도체를 연결하여 건전지를 각각 순방향과 역방향으로 연결해 보겠습니다. 이 경우 순방향으로 연결된 회로에만 전류가 흐릅니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img010.png&quot; alt=&quot;img010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 순방향 회로의 전압을 높여준다면 공핍영역에 의한 전자 반발력보다 건전지에 의한 양전하의 반발력이 더 커지면서 역방향 회로를 통해서도 전류가 흐를 수 있게 됩니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img011.png&quot; alt=&quot;img011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;역방향 회로에 전압을 더 높여준다면 더 많은 전자가 공핍영역을 통과할 수 있으므로 더 많은 전류가 흐르도록 할 수 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img012.png&quot; alt=&quot;img012&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 전압을 높이거나 낮추어 전류의 흐름을 제어하는 장치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트랜지스터(Transistor)&lt;/code&gt;라고 합니다. 트랜지스터는 위와 같은 PNP 트랜지스터와 NPN 트랜지스터가 있습니다.&lt;/p&gt;

&lt;p&gt;CPU는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MOSFET&lt;/code&gt;이라는 0.1nm 크기의 트랜지스터로 구성되어 있습니다. MOSFET은 금속(Metal)과 반도체(Semiconductor) 사이에 부도체인 산화막(Oxide)이 들어있는 적층 구조로 되어 있습니다. 이 구조를 MOS 구조라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img019.png&quot; alt=&quot;img019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반도체 기판이 N형이면 NMOS, P형이면 PMOS라고 부르며, 산화물인 SiO2로는 전류가 흐르지 않습니다. 아래와 같이 건전지를 연결해보겠습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img020.png&quot; alt=&quot;img020&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 오른쪽 회로가 역방향으로 연결되었기 때문에 전류가 흐르지 않습니다. 이번에는 가운데 금속에 전압을 걸어봅시다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img021.png&quot; alt=&quot;img021&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 산화물에 의하여 전류는 흐르지 않지만 위에서 아래로 전기장이 걸리면서 전자가 산화물 아래에 모이게 됩니다. 이 전자들이 N형 반도체를 이어주는 통로가 되어 전류가 흐르게 됩니다.&lt;/p&gt;

&lt;p&gt;즉, MOSFET이란 MOS의 전계 효과(Field Efect)를 활용한 트랜지스터(Transistor)입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">CPU는 트랜지스터라는 반도체로 구성되어 있습니다. 반도체는 주로 실리콘으로 만들어집니다. 실리콘은 원자번호 14로 최외각 전자가 4개이며, 실리콘 원자들끼리 전자를 공유하여 강하게 공유결합하고 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컴퓨터의 구조</title>
      <link href="https://huimang2.github.io/etc/computer-architecture" rel="alternate" type="text/html" title="컴퓨터의 구조" />
      <published>2023-04-21T01:00:00+09:00</published>
      <updated>2023-04-21T01:00:00+09:00</updated>
      <id>https://huimang2.github.io/etc/computer-architecture</id>
      <content type="html" xml:base="https://huimang2.github.io/etc/computer-architecture">&lt;h1 id=&quot;중앙처리장치cpu&quot;&gt;중앙처리장치(CPU)&lt;/h1&gt;

&lt;p&gt;CPU는 컴퓨터에서 기억, 해석, 연산, 제어라는 4가지의 주요 기능을 담당하는 장치입니다.&lt;/p&gt;

&lt;p&gt;컴퓨터의 대뇌에 해당하며, 프로그램의 명령어를 해석하여 데이터를 연산 및 처리함으로써 컴퓨터의 각 장치들을 제어합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img001.png&quot; alt=&quot;img001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터&lt;/code&gt; 3가지로 구성되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;산술논리장치&quot;&gt;산술논리장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술논리장치(Arithmetic and Logical Unit, ALU)&lt;/code&gt;는 덧셈과 뺄셈 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;산술연산&lt;/code&gt;과 논리합, 논리곱, 배타적 논리합과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리연산&lt;/code&gt;을 계산하는 디지털 회로입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img013.png&quot; alt=&quot;img013&quot; /&gt;&lt;/p&gt;

&lt;p&gt;산술논리장치는 논리합을 계산하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가산기(adder)&lt;/code&gt;, 보수값을 출력하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보수기(complementer)&lt;/code&gt;, 산술 및 논리 연산의 결과를 일시적으로 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;누산기(accumulator)&lt;/code&gt;, 명령어를 수행하기 위해 필요한 데이터를 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 레지스터(data register)&lt;/code&gt; 등으로 구성됩니다.&lt;/p&gt;

&lt;p&gt;산술논리장치가 수행하는 마이크로 연산은 다음과 같이 분류할 수 있습니다.&lt;/p&gt;

&lt;h6 id=&quot;산술-연산&quot;&gt;산술 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ADD&lt;/td&gt;
      &lt;td&gt;X ← A + B&lt;/td&gt;
      &lt;td&gt;A와 B를 더합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUB&lt;/td&gt;
      &lt;td&gt;X ← A + (~B + 1)&lt;/td&gt;
      &lt;td&gt;A에 B를 뺍니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MUL&lt;/td&gt;
      &lt;td&gt;X ← A × B&lt;/td&gt;
      &lt;td&gt;A와 B를 곱합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIV&lt;/td&gt;
      &lt;td&gt;X ← A ÷ B&lt;/td&gt;
      &lt;td&gt;A를 B로 나눕니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INC&lt;/td&gt;
      &lt;td&gt;X ← A + 1&lt;/td&gt;
      &lt;td&gt;A를 1 증가 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DEC&lt;/td&gt;
      &lt;td&gt;X ← A - 1&lt;/td&gt;
      &lt;td&gt;A를 1 감소 시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NEG&lt;/td&gt;
      &lt;td&gt;X ← ~A + 1&lt;/td&gt;
      &lt;td&gt;A의 음수값을 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h6 id=&quot;논리-연산&quot;&gt;논리 연산&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AND&lt;/td&gt;
      &lt;td&gt;X ← A &amp;amp; B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 AND 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;X ← A | B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 OR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NOT&lt;/td&gt;
      &lt;td&gt;X ← ~A&lt;/td&gt;
      &lt;td&gt;A의 보수를 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XOR&lt;/td&gt;
      &lt;td&gt;X ← A ^ B&lt;/td&gt;
      &lt;td&gt;A와 B를 비트단위로 XOR 연산 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ASR&lt;/td&gt;
      &lt;td&gt;X ← A » n, A[7] ← A[7]&lt;/td&gt;
      &lt;td&gt;부호를 유지시킨 채 A를 오른쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSL&lt;/td&gt;
      &lt;td&gt;X ← A « n&lt;/td&gt;
      &lt;td&gt;A를 왼쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LSR&lt;/td&gt;
      &lt;td&gt;X ← A » n&lt;/td&gt;
      &lt;td&gt;A를 오른쪽으로쪽으로 n비트 만큼 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROL&lt;/td&gt;
      &lt;td&gt;X ← A « 1, A[0] ← A[7]&lt;/td&gt;
      &lt;td&gt;첫 번째 비트를 마지막 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROR&lt;/td&gt;
      &lt;td&gt;X ← A » 1, A[7] ← A[0]&lt;/td&gt;
      &lt;td&gt;마지막 비트를 첫 번째 비트로 이동시킵니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;산술논리장치는 제어장치로부터 전달받은 제어신호를 통해 두 데이터 레지스터의 값을 연산하여 결과값을 누산기에 저장합니다. 이때 연산 결과에 대한 부가정보를 상태 레지스터에 저장합니다. 상태 레지스터의 구조는 CPU마다 다를 수 있으며, 상태 레지스터에 저장되는 플래그의 종류는 다음과 같습니다.&lt;/p&gt;

&lt;h6 id=&quot;상태-레지스터-플래그&quot;&gt;상태 레지스터 플래그&lt;/h6&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;플래그 종류&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;부호&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;부호 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td&gt;연산 결과의 부호를 나타냅니다. 1이면 음수, 0이면 양수임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제로 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td&gt;연산 결과가 0인지 여부를 나타냅니다. 1이면 0, 0이면 0이 아님을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;캐리 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td&gt;연산 결과에서 올림수나 빌림수가 발생했는지를 나타냅니다. 1이면 올림수나 빌림수가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;오버플로우 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
      &lt;td&gt;연산 과정에서 오버플로우가 발생했는지를 나타냅니다. 1이면 오버플로우가 발생했음을, 0이면 발생하지 않았음을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터럽트 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td&gt;인터럽트가 가능한지를 나타냅니다. 1이면 인터럽트가 가능함을, 0이면 불가능함을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;슈퍼바이저 플래그&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;P&lt;/td&gt;
      &lt;td&gt;커널모드로 실행중인지 사용자모드로 실행중인지를 나타냅니다. 1이면 커널모드, 0이면 사용자모드임을 의미합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;제어장치&quot;&gt;제어장치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어장치(Control Unit, CU)&lt;/code&gt;는 입출력장치 간 통신 및 조율을 제어하는 제어 신호를 보내고, 명령어를 읽고 해석하여 데이터 처리의 순서를 결정하는 장치입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img014.png&quot; alt=&quot;img014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어장치는 클럭(Clock), 명령어, 상태 플래그, 제어신호를 받아들이고, CPU 내부의 ALU나 레지스터 또는 CPU 외부의 제어버스로 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클럭(clock)&lt;/code&gt;이란 컴퓨터 부품을 움직이게 할 수 있는 시간 단위입니다. 클럭은 1과 0이 반복되어 나타나는데, 이 반복의 기본 단위를 클럭의 주기(period)라고 합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img015.png&quot; alt=&quot;img015&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1초동안 반복되는 주기의 횟수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주파수(frequency)&lt;/code&gt;라고 하며, 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;헤르츠(Hz)&lt;/code&gt;를 사용합니다. 인텔 코어 i5를 기준으로 기본 클럭이 2.4GHz 이며, 이것은 1초에 2.4 × 10^9번의 주기가 반복됨을 의미합니다. 그러므로 오버클럭을 하게 되면 주기가 증가하여 CPU의 처리속도를 증가시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;정리하면, 제어장치는 클럭에 맞추어 명령어 레지스터로부터 해석할 명령어를 가져와서 적절한 제어신호를 내보냅니다.&lt;/p&gt;

&lt;h2 id=&quot;레지스터&quot;&gt;레지스터&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레지스터(register)&lt;/code&gt;는 CPU 내부의 작은 임시 저장장치 입니다. 프로그램 속의 명령어와 데이터는 프로그램 실행 전/후로 레지스터에 저장됩니다. CPU 내부에는 다양한 레지스터가 존재하며, 각기 다른 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. 프로그램 카운터(Program Counter, PC)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램 카운터는 메모리에서 읽어들일 명령어의 주소를 저장합니다. 프로그램을 순차적으로 처리하기 위해 프로그램의 순서를 카운트하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;명령어 포인터(Instruction Pointer, IP)&lt;/code&gt;라고도 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. 명령어 레지스터(Instruction Register, IR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어 레지스터는 메모리에서 읽어들인 명령어를 저장하는 레지스터 입니다. 제어장치는 IR에 있는 명령어를 해석하여 제어신호를 내보냅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. 메모리 주소 레지스터(Memory Address Register, MAR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터 입니다. CPU가 읽고자 하는 주소 값을 주소 버스로 보내기 위해서는 MAR를 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. 메모리 버퍼 레지스터(Memory Buffer Register, MBR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 버퍼 레지스터는 메모리와 주고 받을 값을 저장하는 레지스터 입니다. 메모리에 값을 쓰기 위해서는 MBR을 거쳐야 하며, 메모리의 데이터 버스를 통해 값을 전달받을 때도 MBR을 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;5. 상태 레지스터(Status Register, SR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산 결과 또는 CPU의 상태에 대한 부가적인 정보를 저장하고 있는 레지스터 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;6. 작업 레지스터(Working Resister, WR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ALU와 직접 연결되어 있는 레지스터로, 연산 과정의 중간값이나 결과를 저장하는 누산기 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;7. 범용 레지스터(General Resister, GR)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;일반적인 상황에서 자유롭게 사용할 수 있는 레지스터로, 데이터와 주소를 모두 저장할 수 있습니다. ALU와는 연결되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;8. 스택 포인터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스택 포인터는 스택 주소 지정 방식에 사용되는 레지스터 입니다. 메모리 스택 영역의 꼭대기 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img016.png&quot; alt=&quot;img016&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;9. 베이스 레지스터(Stack Pointer)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;베이스 레지스터는 프로그램 카운터와 함께 변위 주소 지정 방식에 사용되는 레지스터 입니다. 주소를 지정하기 위한 기준이 되는 주소를 저장하고 있습니다.&lt;/p&gt;

&lt;p&gt;변위 주소 지정 방식은 오퍼랜드의 필드값과 특정 레지스터 값을 더하여 유효 주소를 얻게 되는데, 오퍼랜더 값과 프로그램 카운터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대 주소 지정 방식&lt;/code&gt;, 오퍼랜더 값과 베이스 레지스터의 값을 더한 주소 지정 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변위 주소 지정 방식&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;h1 id=&quot;메모리&quot;&gt;메모리&lt;/h1&gt;

&lt;p&gt;메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 장치입니다.&lt;/p&gt;

&lt;p&gt;메모리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 주소 레지스터(MAR)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메모리 버퍼 레지스터(MBR)&lt;/code&gt;로 구성되며, CPU와 데이터를 주고 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 버스(system bus)&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;시스템 버스는 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 버스(address bus)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 버스(data bus)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 버스(control bus)&lt;/code&gt;로 구성됩니다.&lt;/p&gt;

&lt;p&gt;메모리는 크게 읽기 전용 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM(Read Only Memory)&lt;/code&gt;과 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAM(Random Access Memory)&lt;/code&gt;, 비 휘발성 메모리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;플래시 메모리(Flash Memory)&lt;/code&gt;로 나눌 수 있으며, 통상적으로 메모리는 RAM을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;

&lt;p&gt;RAM의 종류는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDRAM&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DDR SDRAM&lt;/code&gt;으로 나눌 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;1. DRAM(Dynamic RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRAM은 전원이 연결되어 있더라도 저장된 데이터가 동적으로 사라지는 RAM 입니다. 그렇기 때문에 데이터의 소멸을 막기 위해서는 주기적으로 저장된 데이터를 재활성화(refresh) 해야 합니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 낮고 저렴하며 집적도가 높아 대용량으로 설계하기 용이하기 때문에 일반적으로 메모리에 사용되는 RAM은 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;2. SRAM(Static RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SRAM은 전원이 연결되어 있다면 저장된 데이터가 사라지지 않는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;상대적으로 소비전력이 높고 가격이 비싸며 집적도가 낮기 때문에 일반적으로 대용량으로 설계할 필요가 없고 빨라야 하는 캐시 메모리에서 사용되는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;3. SDRAM(Synchronous RAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SDRAM은 클럭 신호와 동기화되는 발전된 형태의 DRAM 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;royalblue&quot;&gt;4. DDR SDRAM(Double Data Rate SDRAM)&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 데이터를 주고 받는 대역폭을 넓혀 속도를 빠르게 만든 SDRAM 입니다. 최근 대중적으로 사용하는 RAM 입니다.&lt;/p&gt;

&lt;p&gt;DDR SDRAM은 SDRAM 보다 대역폭이 두 배 넓다면, DDR2 SDRAM은 DDR SDRAM 보다 대역폭이 두 배 넓습니다. 즉, DDR2 SDRAM은 SDRAM 보다 대역폭이 네 배 넓습니다.&lt;/p&gt;

&lt;p&gt;동일하게 DDR3 SDRAM은 DDR2 SDRAM 보다 대역폭이 두 배 넓으며, DDR4 SDRAM은 DDR3 SDRAM 보다 대역폭이 두 배 넓습니다. 그러므로 DDR4 SDRAM 4G는 DDR3 SDRAM 8G와 속도가 동일합니다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-메모리&quot;&gt;캐시 메모리&lt;/h2&gt;

&lt;p&gt;캐시 메모리는 CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치 입니다. CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 사용합니다.&lt;/p&gt;

&lt;p&gt;캐시 메모리는 계층적으로 L1, L2, L3 캐시 메모리로 구성할 수 있으며, 일반적으로 L1 캐시와 L2 캐시는 CPU 내부에, L3 캐시는 CPU 외부에 위치합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img017.png&quot; alt=&quot;img017&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 프로세서의 경우 코어마다 L1, L2 캐시가 있기 때문에 데이터의 일관성을 유지하기 위해 캐시 메모리를 동기화 시키는 것이 중요합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/computer/img018.png&quot; alt=&quot;img018&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캐시 메모리는 메모리보다 용량이 작기 때문에 메모리의 일부 내용을 저장합니다. 그렇기 때문에 CPU가 자주 사용할 법한 내용을 예측하여 캐시 메모리에 저장합니다.&lt;/p&gt;

&lt;p&gt;CPU는 최근에 접근했던 메모리 공간에 다시 접근하려고 하며, 접근한 메모리 공간 근처를 접근하려는 경향이 있는데, 이러한 경향을 바탕으로 만들어진 원리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조 지역성의 원리&lt;/code&gt;라고 합니다. 이 원리를 바탕으로 캐시 메모리를 사용한다면 캐시 메모리의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;보조기억장치&quot;&gt;보조기억장치&lt;/h1&gt;

&lt;p&gt;보조기억장치는 현재 실행되지 않는 프로그램이나 데이터를 저장하고 있다가 필요한 경우 RAM으로 데이터를 전달하는 장치 입니다.&lt;/p&gt;

&lt;p&gt;메모리는 보조기억장치에 비하여 비쌀 뿐만 아니라 전원이 꺼지면 저장된 내용을 잃어버린다는 단점이 존재합니다. 그러므로 데이터를 영구적으로 저장하기 위해서는 보조 기억장치에 데이터를 저장해야 합니다.&lt;/p&gt;

&lt;p&gt;보조기억장치에는 하드디스크와 플래시 메모리가 있습니다. 하드디스크는 자기적인 방식으로 데이터를 저장하는 장치이며, 플래시 메모리는 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치입니다. 대표적으로 SSD가 플래시 메모리에 속합니다.&lt;/p&gt;

&lt;h1 id=&quot;입출력장치&quot;&gt;입출력장치&lt;/h1&gt;

&lt;p&gt;입출력장치는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 장치입니다. 대표적인 입출력 장치로 키보드, 모니터, 마우스 등이 있습니다.&lt;/p&gt;

&lt;p&gt;컴퓨터로 데이터를 처리하기 위해서는 입력장치를 통해 컴퓨터로 데이터를 입력해야 하며, 컴퓨터가 처리한 결과의 데이터는 출력장치를 통해 사용자가 읽을 수 있는 형태로 돌려주어야 합니다.&lt;/p&gt;

&lt;p&gt;입력장치는 컴퓨터가 인식할 수 있는 형태로 변환시켜 메모리로 읽어 들이는 장치이고, 출력장치는 컴퓨터에서 처리된 내용을 사용자가 인식할 수 있는 형태로 바꾸어 표시하는 장치입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>huimang2</name>
        
        
      </author>

      

      
        <category term="etc" />
      

      
        <summary type="html">중앙처리장치(CPU)</summary>
      

      
      
    </entry>
  
</feed>
