<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/css/custom.css" />
    

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/css/syntax.css">
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="프로그래밍 노트" />
    <link rel="shortcut icon" href="https://huimang2.github.io/assets/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://huimang2.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Rubisco's Programming Note" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="프로그래밍 노트" />
    <meta property="og:url" content="https://huimang2.github.io/search" />
    <meta property="og:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="프로그래밍 노트" />
    <meta name="twitter:url" content="https://huimang2.github.io/" />
    <meta name="twitter:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Rubisco's Programming Note" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Rubisco's Programming Note",
        "logo": "https://huimang2.github.io/"
    },
    "url": "https://huimang2.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://huimang2.github.io/assets/images/M31_starspike.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://huimang2.github.io/search"
    },
    "description": "프로그래밍 노트"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://huimang2.github.io/">Rubisco's Programming Note</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">JAVA</a></li>
    <li class="nav-javascript" role="menuitem"><a href="/tag/javascript/">Javascript</a></li>
    <li class="nav-typescript" role="menuitem"><a href="/tag/typescript/">Typescript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-python" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-python" role="menuitem"><a href="/author_archive.html">Tag별 Posts</a></li>

</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "etc-iso-standard-7498": {
        "title": "OSI 7계층(ISO Standard 7498)",
            "author": "rubisco",
            "category": "",
            "content": "OSI 7계층데이터를 주고 받는 과정에는 많은 단계가 있습니다. 국제표준화기구(ISO)에서는 이를 역할에 따라 7개의 계층으로 나누었습니다. 이것을 OSI 7계층(Open Systems Interconnection 7 Layer)이라고 합니다.각 계층은 독립적으로 작용하며 수많은 프로토콜(Protocol)이 존재하는데 프로토콜이란 데이터를 주고 받기위한 일종의 약속을 말합니다. 프로토콜에 의해 하위 계층으로 갈수록 헤더가 붙으면서 데이터의 크기는 커집니다.            OSI 모델      프로토콜                  1층: 물리 계층      1000BASE-T, RS-232, RS-485              2층: 데이터 링크 계층      이더넷(Ethernet), PPP, UART              3층: 네트워크 계층      IP, ICMP              4층: 전송 계층      TCP, UDP              5층: 세션 계층      SSH, TLS, RPC              6층: 표현 계층      ASCII, MPEG, JPEG              7층: 응용 계층      HTTP, FTP, Telnet, DHCP      물리 계층 (Physical Layer)물리 계층의 데이터 단위는 비트(bit)이며, 네트워크 케이블과 신호에 관한 규칙을 다루고 있는 계층입니다. 통신 케이블의 종류와 신호의 규격 및 무선통신 주파수 설정, 커넥터 형태 등을 정합니다.물리 계층과 관련된 장비로는 동축 케이블의 아날로그 신호를 디지털 데이터로 변환하는 모뎀(Modem), 다수의 컴퓨터를 연결하여 하나의 네트워크로 보내는 허브(Hub), 디지털 신호를 증폭해주는 리피터(Repeater) 등이 있습니다.데이터 링크 계층 (Datalink Layer)데이터 링크 계층의 데이터 단위는 프레임(frame)이며, 물리적 매체를 통해 데이터를 전달하는 계층입니다. 네트워크 계층에 데이터를 전달하고 물리계층에서 발생하는 오류를 탐지하고 수정하는 기능을 담당합니다. 또한 MAC주소(Media Access Control Address)라는 물리적 주소를 사용하여 각 기기들의 구분을 가능하게 합니다.이 계층과 관련된 프로토콜에는 HDLC, PPP, LLC 등이 있으며, 관련된 장비로는 데이터를 MAC주소를 기반으로 빠르게 전달하는 스위치(Switch), 2개의 랜을 연결하는 브릿지(Bridge) 등이 있습니다.네트워크 계층 (Network Layer)네트워크 계층의 데이터 단위는 패킷(packet)이며, 네트워크를 논리적으로 구분하는 계층입니다. 인터넷에서는 IP주소(Internet Protocol Address)라는 논리적 주소를 사용합니다. 이 계층에서는 전송 계층에서 요구하는 서비스 품질(Qos)를 위한 수단을 제공합니다. 또한 라우팅 프로토콜을 통해 데이터를 전송하는 최적의 경로를 찾아냅니다.관련된 프로토콜에는 IP, ARP, RARP, ICMP, IGMP 등이 있으며, 관련된 장비로는 랜을 연결하는 라우터(Router)가 있습니다.전송 계층 (Transport Layer)전송 계층은 서비스를 구분하고 사용자 사이의 신뢰성 있는 데이터 전달을 담당하는 계층입니다.이 계층의 프로토콜에는 신뢰성있는 데이터 전송이 목적인 TCP(Transmission Control Protocol)와 빠른 데이터 전송이 목적인 UDP(User Datagram Protocol)가 있습니다.TCP는 세그먼트(Segment)라는 데이터 단위를 사용하며 UDP는 데이터그램(Datagram)이라는 데이터 단위를 사용합니다.TCP는 세그먼트를 작은 패킷으로 나눠 여러 경로를 통해 데이터를 전송하고 목적지에서 순서대로 패킷을 조립하여 데이터를 전달합니다. 반면 데이터그램은 순서에 상관없이 데이터를 전달하기때문에 신뢰성은 없습니다.세션 계층 (Session Layer)세션 계층은 두 컴퓨터 사이에 연결을 형성하고 유지 및 종료하는 기능을 담당하는 계층입니다. 일종의 대화통로라고 보면 됩니다. 데이터의 송수신 타이밍과 방법은 이 계층에서 규정됩니다.세션 계층의 프로토콜에는 SSH, TLS, RPC 등이 있으며, 데이터 전송 보안과 관련있습니다.표현 계층 (Presentation Layer)표현 계층은 전송되는 정보의 구문(Syntax) 및 의미(Semantics)에 관여하는 계층으로, 인코딩(Encoding), 데이터 압축(Compression), 암호화(Cryptography) 등 주요한 동작을 수행합니다. 파일의 확장자(txt, jpeg, mp4, html 등)는 이 계층과 관련된 프로토콜입니다.응용 계층 (Application Layer)응용 계층은 응용 서비스를 수행하고 사용자 인터페이스를 제공하는 계층입니다. 대표적인 프로토콜로는 html 문서 전송 프로토콜인 HTTP(HyperText Transfer Protocol), 파일 전송 프로토콜인 FTP(File Transfer Protocol), 메일 전송 프로토콜인 SMTP(Simple Mail Transfer Protocol) 등이 있습니다.TCP/IP인터넷에서 데이터를 주고 받을때 대부분 전송 계층에 속하는 TCP(Transmission Control Protocol)​와 네트워크 계층에 속하는 IP(Internet Protocol)를 많이 사용하는데 이를 묶어 TCP/IP(Transmission Control Protocol/Internet Protocol)라고 합니다. 1960년대 미 국방성에서 개발한 통신 프로토콜이며, 현재는 대부분의 컴퓨터가 기본으로 제공하는 인터넷 표준 프로토콜입니다. TCP/IP는 데이터 전송 과정을 4계층으로 나누며, OSI 모델과 다르게 각 계층이 서로 종속적입니다.네트워크 인터페이스 계층 (Network Interface Layer)네트워크 인터페이스 계층은 운영체제의 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련된 모든 것을 지원하는 계층입니다. 상위 계층(IP)에서 패킷이 도착하면 헤더에 프리앰블(Preamble)과 CRC(Cyclic Redundancy Check)를 추가합니다. 송신 측 단말기는 인터넷 계층으로부터 전달받은 패킷에 물리적 주소(MAC) 정보를 가지는 헤더를 추가하여 프레임을 만들어 전달합니다.관련 프로토콜에는 이더넷(Ethernet), 802.11x, MAC/LLC, PPP 등이 있습니다.인터넷 계층 (Internet Layer)인터넷 계층은 패킷의 인터넷 주소를 결정하고 경로를 배정하는 역할을 합니다. 관련된 프로토콜에는 IP(Internet Protocol), IP를 MAC으로 변환하는 ARP(Address Resolution Protocol), IP 패킷을 전달하는 동안 발생한 오류를 보고하는 ICMP(Internet Control Message Protocol) 등이 있습니다.전송 계층 (Transport Layer)전송 계층은 네트워크 양단의 호스트 사이의 신뢰성 있는 전송 기능을 제공합니다. 시스템의 논리 주소와 포트를 가지며, TCP와 UDP가 사용됩니다.TCP의 경우 3 Way-Handshake라는 방식으로 통신합니다. 장치간에 연결이 잘 되었는를 3번의 과정을 통해 확인하여 데이터 전송의 신뢰성을 확보합니다.SYN은synchronize sequence numbers의 약자이고 ACK는 acknowledgements의 약자입니다. 상태에 대한 설명은 아래 테이블을 참조하세요.            상태      설명                  CLOSED      닫힌 상태              LISTEN      요청 대기 상태              SYN-SENT      SYN 요청 상태              SYN-RECEIVED      SYN 요청을 받은 상태              ESTABLISHED      연결 확인 상태      (1) 클라이언트가 서버에게 SYN을 요청하고 SYN-SENT 상태가 됩니다.(2) SYN을 요청받은 서버는 SYN-RECEIVED 상태가 되고, SYN과 함께 ACK를 클라이언트에게 읍답합니다.(3) SYN+ACK를 응답받은 클라이언트는 ACK를 서버에 요청하고 클라이언트와 서버는 ESTABLISHED 상태가 됩니다.쉽게 말해서 클라이언트가 “내말 들려?” 라고 요청을 보내면 서버가 “응 들려, 넌 내말 들려?” 라고 응답하고,  클라이언트가 “응, 나도 들려” 라고 대답하면서 대화가 시작되는겁니다.응용 계층 (Application Layer)OSI 참조 모델의 세션, 표현, 응용 계층을 합친 계층입니다.",
        "url": "/etc/iso-standard-7498"
    }
    ,
    
    "etc-docker": {
        "title": "도커(Docker) 설치하기",
            "author": "rubisco",
            "category": "",
            "content": "도커란?도커는 컨테이너 기반 오픈소스 가상화 플랫폼입니다. 컨테이너란 격리된 공간에서 프로세스가 실행되도록 하는 기술입니다.버추얼머신(VM)이라고 들어보셨을겁니다. 버추얼머신은 격리된 공간에서 OS가 실행되도록 하는 기술입니다. 윈도우에 격리된 리눅스를 설치한 것이라 보면 됩니다. 쉽게말해서 컴퓨터 안에 가상의 컴퓨터가 있는겁니다.버추얼머신은 이미 설치되어 있는 OS위에 새로운 OS를 실행시키기때문에 조금 무겁습니다. 그에 비하여 도커는 기존 OS 위에 격리된 프로세스 공간을 만들어 실행시키때문에 가볍고 빠르게 동작합니다.도커를 사용하는 이유는 프로그램마다 운영환경이 다르기때문입니다. 예를 들어 A라는 프로그램은 파이썬3.8을 기반으로 작동하는데 OS에는 파이썬 3.5가 설치되어있다면 파이썬3.8을 추가적으로 설치해야합니다. ‘그럼 그냥 파이썬 3.8을 설치하면 되지’라고 생각하는 분도 있을겁니다.  하지만 프로그램은 무수히 많고 프로그램을 설치할때마다 환경을 따로 설정하는 것은 여간 번거로운 일이 아닙니다.도커를 사용한다면 격리된 가상의 공간에 배포자가 작성한 운영환경에 필요한 라이브러리를 설치하여 프로세스를 실행시키게 됩니다. 즉 따로 프로그램에 맞춰 환경설정을 할 필요가 없다는 뜻입니다.도커 설치오라클 클라우드를 통해 우분투 20.04 환경에서 도커를 설치해보겠습니다.(1) 우선 SSH를 통해 오라클 클라우드에 원격접속해주세요.$ ssh [USER]@[HOSTNAME] -p [PORT](2) 패키지를 최신상태로 업데이트 해주세요.$ sudo apt update &amp;&amp; sudo apt upgrade(3) 필수 패키지를 설치하세요.$ sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release(4) 도커와 암호화 통신을 위한 GPG 키를 추가해주세요.$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg(5) apt로 설치하기위해 stable repository를 등록합니다.echo \\  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null(6) apt로 도커 엔진을 설치합니다.$ sudo apt update$ sudo apt install docker-ce docker-ce-cli containerd.io(7) 버전을 확인해봅시다.$ sudo docker version(8) 권한을 지정하여 sudo 없이 도커를 사용할 수 있도록 합시다.$ sudo usermod -aG docker $USER포테이너(Portainer) 설치포테이너는 도커를 웹에서 GUI로 관리할 수 있는 도구입니다. 포테이너를 도커에 설치하겠습니다.(1) 포테이너 데이터를 저장할 볼륨(공간)을 만듭니다.$ docker volume create portainer_data(2) 도커로 포테이너 컨테이너를 생성합니다.$ docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce-d : 백그라운드 모드(detached mode) 실행-p 9000:9000 : 호스트 포트를 컨테이너 포트에 연결 (호스트:컨테이너)--name portainer : 컨테이너 이름 설정--restart aloways : 도커 실행시 컨테이너 실행 여부 설정-v portainer_data:/data : 호스트 볼륨을 컨테이너 볼륨에 연결portainer/portainer-ce : 컨테이너 이미지 이름포테이너가 9000번 포트에서 실행됩니다. 그러나 오라클 클라우드의 경우 22번 포트만 열려 있으므로 방화벽을 Open해야합니다. 아래 방화벽 오픈(Open)를 참조하세요.(3) 아이디와 암호를 입력하고 Create user를 클릭하여 계정을 생성합니다.(4) Get Started를 클릭합니다.(5) 설정이 완료되었습니다! 아래 사진과 같이 도커의 상태를 확인할 수 있습니다.방화벽 오픈(Open)(1) 오라클 클라우드에 로그인 후 홈 -&gt; 인스턴스를 선택합니다.(2) 생성된 인스턴스를 클릭합니다.(3) 보안 목록을 클릭합니다.22번 포트만 열려있는 것을 확인할 수 있습니다.(4) 수신 규칙 추가를 클릭합니다.(5) 소스 CIDR에 0.0.0.0/0, 대상 포트 범위에 9000을 입력하고 수신 규칙 추가를 클릭합니다.(6) OS 방화벽을 오픈합니다.iptables은 재부팅할때마다 설정 내용이 초기화되므로 iptables을 날리고 ufw를 사용하겠습니다.우선 iptables 룰 정책을 저장하기 위한 패키지를 설치합니다.$ sudo apt install iptables-persistent netfilter-persistent net-tools(7) 정책을 영구 저장합니다.$ sudo netfilter-persistent save(8) ufw에서 9000번 포트를 허용해줍니다. SSH 접속을 유지하기위해 22번 포트도 추가해줍니다.$ sudo ufw allow 9000$ sudo ufw allow 22(9) ufw를 켭니다.$ sudo ufw enable",
        "url": "/etc/docker"
    }
    ,
    
    "design-pattern-creational-singleton-pattern": {
        "title": "싱글톤 패턴(Singleton Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        싱글톤 패턴(Singleton Pattern)싱글톤 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 접근할 수 있는 방법을 제공합니다. 즉, 특정 클래스의 객체는 하나만 생성되도록 하여 동일 인스턴스를 재사용 하는 패턴입니다.구조참여 객체Singleton생성자의 접근자를 private로 설정하여 새로운 인스턴스를 생성하지 못하도록 하고, 인스턴스(Instance)의 접근을 위한 오퍼레이션(Operation)을 static으로 정의하여 해당 메소드에 의해서만 인스턴스의 접근이 가능하도록 합니다.인스턴스는 싱글턴 객체의 클래스 변수로 설정되어 클래스가 메모리의 데이터영역에 저장될 때 같이 저장됨으로써 오직 한번만 인스턴스를 생성할 수 있습니다. 이로써 싱글턴 객체는 유일한 인스턴스의 생성에 대한 책임을 지게 됩니다.종류이른 초기화 방식 (Eager Initialization)이른 초기화 방식은 싱글톤 패턴의 가장 기본적인 유형입니다.전역변수로 인스턴스를 생성하고 접근자를 private로 설정함으로써 싱글톤 객체의 오퍼레이션 메소드에 의해서만 접근이 가능하도록 합니다. 또한 생성자의 접근자를 private로 절정함으로써 외부에서 인스턴스를 생성할 수 없도록 만듭니다.EagerSingleton.javapackage design_pattern.creational.singleton;public class EagerSingleton {        private static final EagerSingleton INSTANCE = new EagerSingleton();    private EagerSingleton() {}    public static EagerSingleton getInstance() {        return INSTANCE;    }}자바에서는 static으로 선언한 클래스 변수가 곧 전역변수입니다. 클래스가 메모리의 데이터 영역에 저장될 때 클래스 변수인 INSTANCE는 싱글톤 인스턴스를 한번만 생성하여 참조함으로써 동일한 인스턴스를 재사용하는 싱글톤 원칙을 지킬 수 있게 됩니다.이른 초기화 방식의 장점은 전역변수로 싱글톤 인스턴스를 만들었기때문에 클래스 로더에 의하여 클래스가 로딩될 때 오직 한번만 인스턴스가 생성되므로 Thread-safe하게 싱글톤 객체를 생성할 수 있습니다.단점은 객체의 사용여부와 상관없이 클래스 로딩 시점에 인스턴스가 생성되어 프로그램이 종료될때까지 메모리를 점유하기때문에 자주 사용하지 않는 객체라면 비효율적일 수 있습니다.늦은 초기화 방식 (Lazy Initialization)늦은 초기화 방식은 이른 초기화 방식과 반대로 클래스의 오퍼레이션 메소드가 호출될 때 인스턴스를 생성합니다. 즉, 클래스 메소드가 호출될 때까지 메모리를 점유하지 않습니다.LazySingleton.javapackage design_pattern.creational.singleton;public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {}    public static LazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new LazySingleton();        }        return INSTANCE;    }}늦은 초기화 방식의 장점은 필요할때 객체를 생성할 수 있다는 것입니다.단점은 멀티 쓰레드(Thread) 환경에서 동시에 호출되어 싱글톤 원칙을 보장할 수 없다는 것입니다.쓰레드 안전 이른 초기화 방식 (Thread safe Lazy Initialization)늦은 초기화 방식을 보완하여 synchronized 키워드를 메소드에 선언하여 쓰레드 안전(Thread safe) 상태로 싱글톤을 생성할 수 있는 방식입니다. synchronized로 선언된 메소드는 하나의 쓰레드가 메소드를 사용하면 lock을 걸어 다른 쓰레드를 대기상태로 만듭니다.ThreadSafeLazySingleton.javapackage design_pattern.creational.singleton;public class ThreadSafeLazySingleton {    private static ThreadSafeLazySingleton INSTANCE = null;    private ThreadSafeLazySingleton() {}    public static synchronized ThreadSafeLazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new ThreadSafeLazySingleton();        }        return INSTANCE;    }}이 방식의 장점은 Thread-safe 환경이라는 것입니다.단점은 syncronized가 선언된 메소드가 호출이 많으면 성능이 나빠질 수 있습니다.DCL 방식 (Double-Checked locking)DCL 방식은 syncronized를 메소드에 선언하는 것이 아니라 메소드 내부에 syncronized 블락을 만드는 방식입니다.DCLSingleton.javapackage design_pattern.creational.singleton;public class DCLSingleton {    private volatile static DCLSingleton INSTANCE = null;    private DCLSingleton() {}    public static DCLSingleton getInstance() {        if(INSTANCE == null){            synchronized(DCLSingleton.class){                if(INSTANCE == null){                    INSTANCE = new DCLSingleton();                }            }        }        return INSTANCE;    }}위에 코드와 같이 인스턴스가 없을때 synchronized 키워드를 통해 블락을 만들어 하나의 쓰레드만 작업할 수 있도록 하고 블락 내부에서 다시한번 인스턴스 존재 여부를 체크하게 됩니다. 2번 체크하기때문에 DCL(Double Checking Locking) 방식이라 불립니다.private 접근자로 설정한 INSTANCE 클래스를 보면 volatile이라는 키워드를 사용했습니다. 하나의 프로세서(CPU)는 최적화를 위해 변수를 메인 메모리에 바로 저장하지 않고 캐쉬메모리에 저장하여 성능을 향상시킵니다. 그러나 volatile로 선언된 변수는 변수를 캐쉬메모리에 저장하지 않고 곧바로 메인메모리에 반영하도록 합니다.volatile 키워드를 사용하지 않고 멀티코어 환경에서 작업한다면 인스턴스를 캐쉬메모리에 저장하여 메인메모리에 인스턴스를 생성하기전에 다른 코어의 쓰레드가 비어있는 메모리를 참조하기때문에 문제가 발생할 수 있습니다.Holder에 의한 초기화 방식 (Initialization on demand holder idiom)이 방식은 클래스안에 클래스 홀더(Holder)를 두어 JVM 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방식입니다. 현재까지 가장 많이 이용되고 있는 방식입니다.StaticHolderSingleton.javapackage design_pattern.creational.singleton;public class StaticHolderSingleton {    private StaticHolderSingleton(){}\t\tprivate static class SingleTonHolder {\t\tprivate static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton();\t}\t\tpublic static StaticHolderSingleton getInstance(){\t\treturn SingleTonHolder.INSTANCE;\t}}위에 코드에서 보는 바와 같이 클래스 안에 private 접근자로 중첩클래스를 선언하고 중첩클래스 내부에 private 접근자로 클래스 변수를 선언했습니다. 중첩 클래스는 오퍼레이션 메소드(Operation Method)에 의하여 호출되기 전까지 참조되지 않으며, 오퍼레이션 메소드에 의하여 호출될때 클래스 로더에 의하여 싱글톤 인스턴스를 생성하게 됩니다.중첩클래스 내부에 선언된 클래스 변수는 static으로 선언되었기 때문에 중첩클래스가 로드되는 시점에 한번만 싱글톤 인스턴스를 생성할 수 있게 됩니다. 또한 final 키워드를 통해 다시 값이 할당되지 않도록 하여 싱글톤 원칙을 지킬 수 있게 됩니다.",
        "url": "/design-pattern/creational/singleton-pattern"
    }
    ,
    
    "design-pattern-intro": {
        "title": "디자인 패턴(Design Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        디자인 패턴디자인 패턴(Design Pattern)은 객체지향 프로그래밍을 할때 자주 접할 수 있는 문제를 해결하고자 만든 일종의 코드 패턴에 대한 템플릿(template)입니다.1990년대 초반 에리히 감마(Erich Gamma)에 의해 첫 소개된 이후 1995년에 이분야의 GoF(Gang of Four)라 불리는 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)에 의해 집대성 되었고, 이것이 GoF의 디자인 패턴(Design Pattern)으로 널리 알려졌습니다.디자인 패턴은 객체지향 모델링의 장점인 재사용성과 모듈성을 극대화 시켜서 이를 적용하면 시스템 개발은 물론 유지보수에도 큰 효과를 얻을 수 있습니다. 반면 객체지향 모델에 사용되므로 초기 개발시간이 길어져 소규모 프로젝트에는 적합하지 않을 수도 있습니다.디자인 패턴의 종류디자인 패턴은 크게 생성 패턴(Creational Pattern)과 구조 패턴(Structural Patterns), 행위 패턴(Behavioral Patterns)으로 나눠집니다.생성 패턴(Creational Pattern)은 객체(Object)의 인스턴스(Instance) 생성을 위한 패턴입니다. 클라이언트와 객체 인스턴스 사이의 연결을 끊어줍니다.생성 패턴에는 싱글톤 패턴(Singleton Pattern), 빌더 패턴(Builder Pattern), 팩토리 메서드 패턴(Factory Method Pattern), 추상 팩토리 패턴(Abstract Factory Pattern), 프로토타입 패턴(Prototype Pattern)이 있습니다.구조 패턴(Structural Patterns은 객체(Object)의 합성에 관한 패턴입니다. 객체의 조직화에 대한 패턴을 제공합니다.구조 패턴에는 어댑터 패턴(Adapter Pattern), 브리지 패턴(Bridge Pattern), 컴포지트 패턴(Composit Pattern), 데코레이터 패턴(Decorator Pattern), 퍼사드 패턴(Facade Pattern), 플라이웨이트 패턴(Flyweight Pattern), 프록시 패턴(Proxy Pattern)이 있습니다.행위 패턴(Behavioral Patterns)은 객체(Object)의 상호작용과 책임 분산에 대한 패턴을 제공합니다.행위 패턴에는 책임 연쇄 패턴(Chain of Responsibility Pattern), 커맨드 패턴(Command Pattern), 인터프리터 패턴(Interpreter Pattern), 이터레이터 패턴(Iterator Pattern), 메디에이터 패턴(Mediator Pattern), 메멘토 패턴(Memento Pattern), 옵저버 패턴(Observer Pattern), 상태 패턴(State Pattern), 전략 패턴(Strategy Pattern), 템플릿 메소드 패턴(Template Method Pattern), 비지터 패턴(Visitor Pattern)이 있습니다.",
        "url": "/design-pattern/intro"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://huimang2.github.io/">Rubisco's Programming Note</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search Rubisco's Programming Note</h1>
            <p class="subscribe-overlay-description">
            lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>


    <!-- highlight.js -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script> -->

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
