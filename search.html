<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/css/custom.css" />
    

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/css/syntax.css">
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="프로그래밍 노트" />
    <link rel="shortcut icon" href="https://huimang2.github.io/assets/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://huimang2.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Rubisco's Programming Note" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="프로그래밍 노트" />
    <meta property="og:url" content="https://huimang2.github.io/search" />
    <meta property="og:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="프로그래밍 노트" />
    <meta name="twitter:url" content="https://huimang2.github.io/" />
    <meta name="twitter:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Rubisco's Programming Note" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Rubisco's Programming Note",
        "logo": "https://huimang2.github.io/"
    },
    "url": "https://huimang2.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://huimang2.github.io/assets/images/M31_starspike.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://huimang2.github.io/search"
    },
    "description": "프로그래밍 노트"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://huimang2.github.io/">Rubisco's Programming Note</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">JAVA</a></li>
    <li class="nav-typescript" role="menuitem"><a href="/tag/typescript/">Typescript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-python" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-python" role="menuitem"><a href="/author_archive.html">Tag별 Posts</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "algorithm-gcd-lcm": {
        "title": "최대공약수와 최소공배수",
            "author": "rubisco",
            "category": "",
            "content": "최대공약수와 최소공배수최대공약수(GCD, Greateast Common Division)는 두 수에 대한 공약수의 최대값을 의미하며, 최소공배수(LCM, Least Common Multiple)는 두 수에 대한 공배수의 최소값을 의미합니다.최대공약수와 최소공배수는 소인수분해(Integer factorization)를 통해 구할 수 있습니다.최대공약수는 소인수의 교집합을 모두 곱한 값이고, 최소공배수는 소인수의 합집합을 모두 곱한 값입니다. 예를 들어 a = 12, b = 20 인 경우, a와 b의 최대공약수와 최소공배수는 다음과 같이 구할 수 있습니다.  a = 12 = 2 * 2 * 3b = 20 = 2 * 2 * 5a와 b의 소인수에 대한 교집합은 [2, 2]가 되고, 이를 모두 곱한 4가 최대공약수가 됩니다. 또한 a와 b의 소인수에 대한 합집합은 [2, 2, 3, 5]가 되고, 이를 모두 곱한 60이 최소공배수가 됩니다.최대공약수를 G, 최소공배수를 L이라고 한다면, 다음과 같은 식이 성립합니다.  a = 12 = G * Ab = 20 = G * B  A = a/GB = b/G  L = G * A * B = G * (a/G) * (b/G) = a*b/G이때 A와 B는 서로소가 됩니다.이를 자바스크립트 코드로 나타내면 다음과 같습니다.function GCD(a, b) {    let result = 1;    if(a &gt; b) [a, b] = [b, a];    let i = 2;        while(1) {        while(a%i === 0 &amp;&amp; b%i === 0) {            a /= i;            b /= i;            result *= i;        }        if(a === 1 || a === i++) return result;    }}function LCM(a, b) {    return a * b / GCD(a, b);}유클리드 호제법(Euclidean algorithm)  두 양의 정수 a, b (a &gt; b)에 대하여 a = bq + r (0 ≤ r &lt; b)이라 하면, a, b의 최대공약수는 b, r의 최대공약수와 같다.  즉, gcd(a, b) = gcd(b, r)이다.  r = 0이라면, a, b의 최대공약수는 b가 된다.유클리드 호제법(Euclidean algorithm)은 두 양의 정수, 혹은 두 다항식의 최대공약수를 구하는 방법입니다. 이 알고리즘은 유클리드의 원론에 적혀있는 내용으로, 인류 최초의 알고리즘이라 합니다.소인수 분해를 통해 최대공약수를 구하면 시간 복잡도가 O(N) 이지만, 유클리드 호제법으로 최대공약수를 구하면 시간 복잡도를 O(logN)으로 줄일 수 있습니다.증명gcd(a, b) = G, gcd(b, r) = G' 라고 가정 한다면, 서로소인 두 정수 A, B에 대하여 a = GA, b = GB가 성립합니다.이를 a = bq + r에 대입하면, GA = GBq + r 이므로 r = G(A - Bq)가 됩니다. 여기서 G는 b와 r의 공약수임을 확인할 수 있으며, 그러므로 G는 G'의 약수임을 알 수 있습니다.G' = mG라고 가정한다면, 서로소인 두 정수 k, l에 대하여 GB = G'k = Gmk, G(A - Bq) = G'l = Gml이 성립하며, 양변을 G로 나누면 B = mk, A - Bq = ml이 됩니다.두 연립 방정식에 의하여 A = ml + Bq = ml + mkq = m(l + kq) 가 되며, m은 A와 B의 공약수가 됨을 알 수 있습니다.여기에서 A와 B는 서로소 관계에 있으므로, m = 1 이 되며, G' = mG라고 가정했으므로 G' = G 가 됩니다.즉, gcd(a, b) = gcd(b, r)입니다.소스 코드function GCD(a, b) {    return a &lt; b ? GCD(a, b) : (a % b ? GCD(b, a % b) : b);}function LCM(a, b) {    return a * b / GCD(a, b);}관련 문제  프로그래머스(Programmers)          [12969] 최대공약수와 최소공배수      [12953] N개의 최소공배수      ",
        "url": "/algorithm/gcd_lcm"
    }
    ,
    
    "etc-phaser3": {
        "title": "게임 프레임워크 : Phaser3",
            "author": "rubisco",
            "category": "",
            "content": "Phaser3이란?RPG 만들기(일명 알만툴) 이라고 아시나요? 게임 만들기에 관심이 있었다면 한번쯤 알만툴이나 스타크래프트 유즈맵 편집기를 통해 게임을 제작해 본 적이 있을 것입니다. Phaser 또한 이러한 툴과 비슷한 자바스크립트 기반 게임 프레임워크 입니다. 자바스크립트를 기반으로 하기때문에 웹브라우저 환경에서 게임실행이 가능하도록 합니다.기본적으로 씬(Scene)과 게임 오브젝트(Game Object)로 구성되며, 물리엔진을 포함하고 있어서 손쉽게 게임을 제작할 수 있습니다.공식문서의 튜토리얼을 통해 간단한 게임을 제작해보도록 하겠습니다.  완성 프로젝트 : phaser3_example.zip프로젝트 설정우분투 20.04 LTS 환경을 기준으로 프로젝트를 생성해보겠습니다. 웹브라우저 환경에서 실행되므로 웹서버를 필요로 합니다. 간단하게 nodejs를 통해 웹서버를 만들도록 합시다.$ mkdir phaser3 &amp;&amp; cd phaser3 &amp;&amp; mkdir public &amp;&amp;  npm i http-server웹서버를 실행하면 public 폴더가 루트폴더로 설정됩니다.$ npx http-server타입스크립트를 통해 프로젝트를 만들도록 하겠습니다. 새로운 터미널을 열고 npm을 통해 typescript와 phaser를 설치합니다.$ npm i typescript phaser타입스크립트 설정파일(tsconfig.json)을 생성하고 다음과 같이 작성해줍니다.$ npx tsc --init &amp;&amp; nano tsconfig.json{    \"compilerOptions\": {        \"target\": \"ES2015\",        \"module\": \"commonJS\",        \"allowJs\": true,        \"checkJs\": true,        \"jsx\": \"preserve\",        \"outDir\": \"./public/assets/js/\",        \"removeComments\": true,        \"strict\": true,        \"noImplicitAny\": true,        \"strictNullChecks\": true,        \"strictFunctionTypes\": true,        \"strictPropertyInitialization\": true,        \"noImplicitThis\": true,        \"alwaysStrict\": true,        \"noUnusedLocals\": true,        \"noUnusedParameters\": true,        \"noImplicitReturns\": true,        \"noFallthroughCasesInSwitch\": true,        \"esModuleInterop\": true    }}모듈을 합치고 호환성을 위해 웹팩을 사용하도록 하겠습니다.$ npm i webpack webpack-cli ts-loader웹팩 설정파일을 작성합니다.$ touch webpack.config.js &amp;&amp; nano webpack.config.jswebpack.config.jsconst path = require(\"path\");module.exports = {  entry: \"./src/main.ts\",  mode: \"none\",  module: {    rules: [      {        test: /\\.tsx?$/,        use: \"ts-loader\",        exclude: /node_modules/,      },    ],  },  resolve: {    extensions: [\".tsx\", \".ts\", \".js\"],  },  output: {    filename: \"main.js\",    path: path.resolve(__dirname, \"public/assets/js\"),  },};웹팩을 watch mode로 실행하면 코드가 수정될 때마다 자동으로 컴파일 됩니다.$ npx webpack -w게임 생성우선 메인 문서를 생성합시다. http-server는 index.html를 메인 문서로 인식합니다.$ touch /public/index.html다음과 같이 컴파일된 자바스크립트 파일을 추가해주세요.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=\"/assets/js/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;게임 인스턴스는 new Phaser.Game()을 호출하여 생성할 수 있습니다. 타입스크립트 파일을 작성하겠습니다.$ touch /src/main.ts &amp;&amp; nano /src/main.tsmain.tsimport Phaser from 'phaser';const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,};new Phaser.Game(config);Game 인스턴스는 매개변수로 GameConfig 객체를 받습니다. GameConfig 객체는 게임에 필요한 여러 설정값을 프로퍼티로 가지고 있습니다.type 프로퍼티는 그래픽의 렌더링 방식을 설정합니다. 캔버스를 사용하는 Phaser.CANVAS, WebGL을 사용하는 Phaser.WEBGL, 자동설정인 Phaser.AUTO 중 하나를 입력합니다.width와 height 프로퍼티는 화면 크기를 설정합니다. number 타입이며, 픽셀 단위로 입력합니다.backgroundColor는 화면의 색상을 설정합니다. number 타입의 hex 색상코드 또는 string 타입의 rgb 색상코드를 입력합니다.다양한 프로퍼티를 알고 싶다면 공식문서를 참고하세요.씬(Scene) 생성게임 객체의 동적인 작용을 위해서는 씬 객체를 생성해야 합니다. 씬 객체의 라이프 사이클은 다음과 같습니다.mainScene.tsclass MainScene extends Phaser.Scene {    constructor() {        super({ key: 'main', active: true })    }    preload(): void {}    create(): void {}    update(time: number, delta: number): void {}    destroy(): void {}}Scene 클래스를 상속받아 각각 오버라이드 하면 됩니다.preload() 메소드는 게임에 필요한 이미지나 오디오 파일 등의 리소스를 로드할 때 사용합니다. 게임에 필요한 리소스를 Asset 이라고 합니다. asset을 로드할 때 Scene 객체의 load 프로퍼티를 사용합니다. 일단 asset이 로드되면 Loader 객체는 키값을 통해 asset에 접근할 수 있도록 해줍니다.첨부파일의 이미지를 로드하기위해 다음 코드를 작성하세요.preload(): void {    this.load.image('sky', 'assets/image/sky.png');    this.load.image('ground', 'assets/image/platform.png');    this.load.image('star', 'assets/image/star.png');    this.load.image('bomb', 'assets/image/bomb.png');         this.load.spritesheet('dude', 'assets/image/dude.png', { frameWidth: 32, frameHeight: 48 });}하나의 이미지를 로드하려면 Sene.load.image 메소드를 호출합니다. 첫번째 파라미터로 키값을, 두번째 파라미터로 asset 경로를 입력합니다.spriteSheet의 경우 Sene.load.spritesheet 메소드를 호출하여 불러올 수 있습니다. 역시 첫번째 파라미터로 키값을, 두번째 파라미터로 asset 경로를 받으며, 3번째 파라미터로 sprite 설정 객체를 받습니다. 하나의 프레임에 대한 넓이와 높이를 설정해줍니다.로드한 asset은 create() 메소드에 Scene 객체의 add 프로퍼티를 통해 Scene에 추가할 수 있습니다.create(): void {    this.add.image(400, 300, 'sky');    this.add.image(400, 300, 'star');}첫번째 파라미터는 x축 좌표, 두번째 파라미터는 y축 좌표, 세번째 파라미터는 asset의 키값에 해당합니다.씬 코드를 작성했다면 게임 설정 객체의 scene 프로퍼티에 배열로 넣어주면 됩니다. 다음과 같이 작성하고 컴파일 후 localhost:8080 으로 들어가봅시다.main.tsimport Phaser from 'phaser';import { MainScene } from './mainScene';const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,    scene: [MainScene]};new Phaser.Game(config);mainScene.tsexport class MainScene extends Phaser.Scene {    constructor() {        super({ key: 'main', active: true });    }    preload(): void {        this.load.image('sky', 'assets/image/sky.png');        this.load.image('ground', 'assets/image/platform.png');        this.load.image('star', 'assets/image/star.png');        this.load.image('bomb', 'assets/image/bomb.png');        this.load.spritesheet('dude', 'assets/image/dude.png', { frameWidth: 32, frameHeight: 48 });    }    create(): void {        this.add.image(400, 300, 'sky');        this.add.image(400, 300, 'star');    }}다음과 같이 배경과 별 이미지가 출력된 것을 확인할 수 있습니다.물리객체 생성대부분의 게임들은 물리 효과가 적용되어 있습니다. 예를 들어 캐릭터가 점프를 하면 중력의 영향을 받아 낙하 하거나 충돌시 작용 반작용 효과를 받습니다. 이런 효과를 구현하려면 많은 노력이 필요하겠지만 Phaser는 2가지 물리엔진 arcade와 matter를 포함하고 있어 손쉽게 물리 효과를 부여할 수 있습니다.arcade는 Phaser 개발자가 만든 간단한 물리 엔진입니다. 간단히 사용하기에 편하지만 복잡한 게임을 만들기에는 조금 부족합니다.matter는 상용화 된 물리 엔진입니다. 앵그리버드 물리 엔진으로 유명한 Box2d에 이어 자바스크립트에서 사용되는 양대 산맥의 물리 엔진으로 알려져 있습니다.Phaser 튜토리얼에 따라 arcade 엔진으로 물리 객체를 생성해보겠습니다. 우선 게임 설정 객체에 physics 프로퍼티를 설정해주세요.const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,    scene: [MainScene],    physics: {        default: 'arcade',        arcade: {            gravity: { y: 300 },            debug: false        }    }};씬 객체의 create 메소드에 다음과 같이 물리 객체를 생성하는 코드를 작성해 주세요.create(): void {    this.add.image(400, 300, 'sky');    const platforms = this.physics.add.staticGroup();    platforms.create(400, 568, 'ground').setScale(2).refreshBody();    platforms.create(600, 400, 'ground');    platforms.create(50, 250, 'ground');    platforms.create(750, 220, 'ground');}씬 객체에서 physics 프로퍼티는 arcade 물리 엔진을 의미합니다. 물리 객체에는 dynamic 객체와 static 객체가 있습니다. dynamic 객체는 중력이나 가속도의 영향을 받아 상호작용 할 수 있는 객체이고, static 객체는 벽과 같이 중력의 영향도 받지 않을 뿐더러 부딪쳐도 움직이지 않는 객체입니다.위에 코드에서는 우선 지형을 static 객체로 만들어보았습니다. static 그룹 객체를 만들고 4개의 static 객체를 추가했습니다. create 메소드에서 첫번째 파라미터는 x축 좌표, 두번째 파라미터는 y축 좌표, 세번째 파라미터는 asset의 키값입니다.캐릭터 생성이제 지형 위를 움직일 캐릭터를 생성해 보겠습니다.다음 코드를 create 메소드에 추가해주세요.const player = this.physics.add.sprite(100, 450, 'dude').setName(\"player\");player.setBounce(0.2);player.setCollideWorldBounds(true);this.anims.create({    key: 'left',    frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),    frameRate: 10,    repeat: -1});this.anims.create({    key: 'turn',    frames: [ { key: 'dude', frame: 4 } ],    frameRate: 20});this.anims.create({    key: 'right',    frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),    frameRate: 10,    repeat: -1});this.physics.add.sprite() 메소드를 통해 캐릭터의 sprite를 추가했습니다. sprite는 2d 이미지 합성을 통해 애니메이션 효과를 내는 기술입니다. 움직임이 있는 이미지라고 보시면 됩니다.  setName 함수를 통해 나중에 호출할 수 있도록 이름을 설정합니다.Physics Game Object Factory에 의해 생성된 sprite는 기본적으로 dynamic 객체가 됩니다. 플레이어 객체에 setBounce()를 통해 바운스를 설정하면 충돌시 작용 반작용 효과를 나타낼 수 있습니다. 또한 setCollideWorldBounds()를 통해 WoldBounds를 true로 설정하면 화면 경계에서 충돌 효과가 나타납니다. setGravityY()를 통해서는 중력의 크기를 설정할 수 있습니다.Scene 객체의 anims.create() 메소드를 통해서는 애니메이션 객체를 만들 수 있습니다. key는 애니메이션 객체의 키가 되고 frames는 프레임을, frameRate는 fps를 나타냅니다. repeat는 애니메이션의 반복수를 나타내는데 -1은 무한을 의미합니다.지형 객체는 static 객체이기 때문에 dinamic 객체인 캐릭터와 상호작용하기 위해서는 collider 객체로 충돌을 설정해야 합니다. 다음 코드를 씬 객체의 create 메소드에 추가해주세요.this.physics.add.collider(player, platforms);캐릭터 이동이제 키보드를 통해 캐릭터를 이동할 수 있도록 해보겠습니다.update 메소드에 다음 코드를 작성합니다. update 메소드는 씬 객체가 존재하는 동안 주기적으로 실행되는 메소드 입니다.update(_time: number, _delta: number): void {    const cursors = this.input.keyboard.createCursorKeys();    const player = this.children.getByName(\"player\") as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;    if (cursors.left.isDown)    {        player.setVelocityX(-160);        player.anims.play('left', true);    }    else if (cursors.right.isDown)    {        player.setVelocityX(160);        player.anims.play('right', true);    }    else    {        player.setVelocityX(0);        player.anims.play('turn');    }    if (cursors.up.isDown &amp;&amp; player.body.touching.down)    {        player.setVelocityY(-330);    }}의미는 알기 쉬울 것입니다. 주기적으로 해당 키보드를 누르고 있는지 체크하여 속도를 설정하고 키에 해당하는 애니메이션을 실행합니다.별 모으기이제 별을 모으는 코드를 작성해보겠습니다. 우선 별을 static 객체로 생성합니다. 다음 코드를 create 메소드에 추가합니다.let stars = this.physics.add.group({    key: 'star',    repeat: 11,    setXY: { x: 12, y: 0, stepX: 70 }});this.data.set(\"stars\", stars);stars.children.iterate(function (child) {    (child as Phaser.Physics.Arcade.Image).setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));});static 그룹 객체를 만들고 12개의 별 객체를 만듭니다. 그룹 객체를 만들때 처음 1개는 자동으로 생성되므로 11번 반복하여 12개의 별 객체가 생성됩니다. x축 좌표는 12픽셀부터 시작하여 70픽셀 간격으로 생성됩니다. iterate 메소드를 통해 순차적으로 Y축 바운스를 설정해줍니다.static 객체인 지형과 별 그룹 객체가 상호작용 하도록 다음 코드를 create 메소드에 추가합니다.this.physics.add.collider(stars, platforms);캐릭터가 별을 수집하면 별 객체가 사라지도록 설정해줍시다. 이것은 arcade 물리 객체의 overlap 메소드를 통해 가능합니다. 다음 코드를 create 메소드에 추가해 주세요.this.physics.add.overlap(player, stars, this.collectStar, undefined, this);player 객체가 stars 객체와 overlap 되면 collectStar 메소드를 호출합니다. 해당 메소드를 작성해주세요.collectStar (_player: Phaser.Types.Physics.Arcade.GameObjectWithBody, star: Phaser.Types.Physics.Arcade.GameObjectWithBody): void {    (star as Phaser.Physics.Arcade.Image).disableBody(true, true);}star 객체의 disableBody 함수를 호출하면 해당 객체가 사라집니다.점수 설정별을 모으면 점수가 증가 하도록 하겠습니다. 우선 create 메소드에 점수 데이터와 텍스트 asset을 추가해주세요.this.data.set(\"score\", 0);this.add.text(16, 16, 'score: 0', { fontSize: '32px', backgroundColor: '#000' }).setName(\"scoreText\");다음으로 위에서 생성한 collectStar 메소드에 다음 코드를 추가합니다.this.data.set(\"score\", this.data.get(\"score\") as number + 10);(this.children.getByName(\"scoreText\") as Phaser.GameObjects.Text).setText('Score: ' + (this.data.get(\"score\") as number));장애물 설정마지막으로 장애물을 설정해 보겠습니다. 별을 모두 수집하면 폭탄이 하나 나오고 새로운 별 그룹 객체가 생성됩니다. create 메소드에 다음 코드를 추가합니다.const bombs = this.physics.add.group();this.data.set(\"bombs\", bombs);this.physics.add.collider(bombs, platforms);this.physics.add.collider(player, bombs, this.hitBomb, undefined, this);폭탄의 그룹인 dynamic 그룹 객체를 생성하여 collider 객체로 충돌을 설정합니다. 또한 플레이어가 폭탄에 닿으면 hitBomb 메소드를 호출합니다.hitBomb 메소드는 다음과 같이 작성합니다.hitBomb (player: Phaser.Types.Physics.Arcade.GameObjectWithBody, _bomb: Phaser.Types.Physics.Arcade.GameObjectWithBody): void {    this.physics.pause();    (player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).setTint(0xff0000);    (player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).anims.play('turn');}폭탄에 닿으면 물리 객체의 상호작용이 정지되고 플레이어 캐릭터의 색이 빨같게 됩니다.마지막으로 collectStar 메소드에 다음 코드를 추가합니다.const stars = this.data.get(\"stars\") as Phaser.Physics.Arcade.Group;if (stars.countActive(true) === 0) {    stars.children.iterate(function (child) {        (child as Phaser.Physics.Arcade.Image).enableBody(true, (child as Phaser.Physics.Arcade.Image).x, 0, true, true);    });    const x = ((player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).x &lt; 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);    const bombs = this.data.get(\"bombs\") as Phaser.Physics.Arcade.Group;    const bomb = bombs.create(x, 16, 'bomb');    bomb.setBounce(1);    bomb.setCollideWorldBounds(true);    bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);}별 객체가 하나도 없다면 새로운 별 객체 그룹을 생성하고 폭탄을 하나 생성하도록 합니다. 폭탄에 각각 바운스와 월드 바운스, 속도를 설정합니다.",
        "url": "/etc/phaser3"
    }
    ,
    
    "typescript-interface": {
        "title": "클래스와 인터페이스",
            "author": "rubisco",
            "category": "",
            "content": "클래스(class)클래스(class)는 자바스크립트 es6에 추가된 타입입니다. es6 이전에는 클래스가 없고 프로토타입을 기반으로 클래스를 만들었으나, 클래스가 추가되면서 조금 더 명료하게 클래스를 작성할 수 있게 되었습니다.클래스 선언클래스 선언은 다음과 같이 합니다.class User { }함수의 선언과 달리 클래스는 호이스팅 되지 않습니다. 선언된 클래스는 new 키워드를 통해 인스턴스화(Instantiation) 될 수 있습니다.let user: User = new User(); 클래스 생성자생성자는 constructor 키워드를 통해 정의할 수 있습니다.class User {    constructor(name: String) {        console.log(name);    }}let user: User = new User(\"rubisco\"); 인스턴스 속성객체의 속성과 마찬가지로 인스턴스도 속성을 가질 수 있으며, 클래스 내부에서는 this 키워드를 통해 접근 가능합니다. 또한 다른 언어들과 비슷하게 접근자 키워드를 통해 속성 접근을 제한할 수 있습니다.접근자에는 public, protected, private가 있으며, 기본값은 public입니다.타입스크립트 컴파일시 환경설정에 --strictPropertyInitialization 옵션이 있다면 반드시 속성을 초기화 해주어야 합니다.class User {    private name: string;    constructor(name: string) {        this.name = name;    }}let user: User = new User(\"rubisco\"); 만약 읽기전용 속성을 생성하려면 자바에서 final 키워드를 붙이는 것과 같이 readonly 키워드를 속성 앞에 붙입니다.class User {    private readonly name: string;    constructor(name: string) {        this.name = name;    }}let user: User = new User(\"rubisco\"); Getter / Setter자바스크립트의 클래스 또한 Getter와 Setter를 선언할 수 있습니다. 메소드 앞에 get 키워드를 붙이면 getter, set 키워드를 붙이면 setter가 됩니다.class User {    private _name: string;    constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }}let user: User = new User(\"rubisco\");console.log(user.name); // \"rubisco\" 출력user.name = \"spot\";console.log(user.name); // \"spot\" 출력클래스의 확장자바와 마찬가지로 타입스크립트의 클래스도 extends 키워드를 통해 상속이 가능합니다. 또한 super 키워드를 통해 부모 클래스에 접근할 수 있습니다.class Animal {        private _name: string;    protected constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }}class Dog extends Animal {    constructor(name: string) {        super(name);    }    sniff(): void {        console.log(`${ this.name }이(가) 냄새를 맡습니다.`);    }}class Bird extends Animal {    constructor(name: string) {        super(name);    }    fly(): void {        console.log(`${ this.name }이(가) 날아다닙니다.`);    }}let dog: Dog = new Dog(\"코커스파니엘\");let bird: Bird = new Bird(\"까마귀\");dog.sniff();bird.fly();추상 클래스추상 클래스는 클래스 앞에 abstract 키워드를 통해 선언할 수 있습니다. 일반 클래스와 달리 추상 클래스는 인스턴스화가 불가능하며, 추상 클래스를 상속받은 자식 클래스에게 추상 메소드의 구현을 강제합니다.abstract class Animal {        private _name: string;    protected constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }    abstract move(): void;}class Dog extends Animal {    constructor(name: string) {        super(name);    }    move(): void {        console.log(\"네발로 걷습니다.\");    }}class Bird extends Animal {    constructor(name: string) {        super(name);    }    move(): void {        console.log(\"날개로 날아다닙니다.\");    }}let dog: Dog = new Dog(\"코커스파니엘\");let bird: Bird = new Bird(\"까마귀\");dog.move();bird.move();인터페이스(Interface)타입스크립트의 핵심 원리 중 하나는 값이 가지는 형태에 초점을 맞추어 타입체크를 한다는 것입니다. 이러한 동적 타이핑을  덕 타이핑(duck typing)이라고 합니다.  “어떤 새가 오리처럼 보이고 오리처럼 헤엄치는 오리처럼 운다면 그것은 오리일 것이다.”덕 타이핑은 덕 테스트에서 유래한 단어로, 타입스크립트에서 데이터의 타입은 인터페이스 형태에 의하여 결정됩니다.자바스크립트만 다뤄 본 개발자들은 인터페이스라는 개념이 생소하게 느껴질 것입니다. 인터페이스는 자바나 C# 등 정적 타입 언어에서 이미 많이 쓰이고 있는 개념으로, 여러가지 타입을 가지는 프로퍼티로 이루어진 새로운 타입을 정의하는 규칙입니다. 인터페이스에 선언된 프로퍼티나 메소드의 구현을 강제하여 일관성을 유지하도록 하는 역할을 합니다.인터페이스는 타입의 이름을 짓는 코드 내부의 계약을 정의할 뿐만 아니라 프로젝트 외부에서 사용하는 코드의 계약을 정의하는 강력한 방법입니다. 프로퍼티와 메소드를 가진다는 점에서 클래스와 유사하지만 직접적으로 인스턴스를 생성할 수 없으며, 모든 메소드는 추상 메소드로 구성됩니다.인터페이스 정의인터페이스를 정의하는 문법은 객체(object) 타입과 유사합니다.let user: {    index: number;    name: string;    level: number;};위에 객체를 인터페이스로 정의하면 다음과 같습니다.interface User {    index: number;    name: string;    level: number;};인터페이스나 클래스는 파스칼 표기법(Pascal case)를 사용하여 정의하는 것이 관례이며, 정의된 인터페이스는 다음과 같이 사용가능합니다.let user: User = { index: 1, name: 'rubisco', level: 4 };객체 타입과 마찬가지로 읽기 전용 속성 또는 선택 속성을 정의할 수도 있습니다.interface User {    readonly index: number;    name: string;    level: number;    item?: string;};let player: User = { index: 2, name: 'spot', level: 4 };함수형 인터페이스(Functional Interface)인터페이스를 통해 함수 타입을 정의하는 것도 가능합니다. 함수 타입을 정의하기 위해서는 호출 시그니쳐(call signature) 즉, 매개변수의 타입 정의가 필요합니다.interface User {    readonly name: string;    hp: number;    mp: number;    item?: string;};interface GetUserName {    (player: User): string;}const getUserName: GetUserName = function(user) {    return user.name;}위의 코드를 보면 GetUserName이라는 인터페이스를 통해 해당 타입의 함수는 User 타입의 매개변수를 받고 문자열을 반환한다는 것을 알 수 있습니다.함수형 인터페이스를 통해 람다식을 작성함으로써 코드를 간결하게 표현할 수도 있습니다.const getUserNameLambda: GetUserName = (user) =&gt; user.name;하이브리드 타입(Hybrid Type)호출 시그니처와 속성 타입을 동시에 가지는 인터페이스를 하이브리드 타입(Hybrid Type)이라고 합니다.interface Player {    readonly name: string;    hp: number;    mp: number;    power: number;    items?: string[];};interface Battle {    (player: Player, opponent: Player): Battle;    attack(): void;    turn: number;}let battle = &lt;Battle&gt; function (player: Player, opponent: Player): Battle {    if (battle.turn == null) battle.turn = 0;    battle.turn += 1;    battle.attack = () =&gt; player.hp -= opponent.power;    return battle;};let player1: Player = { name: 'rubisco', hp: 50, mp: 10, power: 10 };let player2: Player = { name: 'enemy', hp: 50, mp: 10, power: 10 };battle(player1, player2).attack();console.log(battle.turn, player1.hp);위에 코드에서 Battle 인터페이스는 호출 시그니처와 속성을 모두 가진 하이브리드 타입 입니다.인덱서블 타입 (Indexable Types)인덱서블 타입은 타입을 인덱스로 사용할 수 있도록 합니다. 자바에서 list와 map 타입이 인덱서블 타입에 해당합니다. 인덱서의 타입은 number와 string, symbol만  지정할 수 있습니다.interface User {    readonly name: string;};interface UserArray {    [index: number]: User;}let user1: User = { name: \"Kim\" };let user2: User = { name: \"Lee\" };let users:UserArray = [user1, user2];console.log(users[1].name);인터페이스 확장인터페이스는 자바와 마찬가지로 extends 키워드를 통해 상속이 가능합니다.interface GameObject {    name: string;    hp: number;    mp?: number;}interface Player extends GameObject {    attack(): void;    defense(): void;}let player: Player = {    name: \"rubisco\",    hp: 50,    mp: 10,    attack: function (): void {        console.log(\"공격!\");    },    defense: function (): void {        console.log(\"방어!\");    }}player.attack();인터페이스의 경우 클래스와 달리 extends 키워드를 통해 다중 상속이 가능합니다.interface GameObject {    name: string;    hp: number;    mp?: number;}interface Attack {    attack(): void;}interface Defense {    defense(): void;}interface Player extends GameObject, Attack, Defense {}let player: Player = {    name: \"rubisco\",    hp: 50,    mp: 10,    attack: function() {        console.log(\"공격!\");    },    defense: function() {        console.log(\"방어!\");    },}player.attack();클래스의 인터페이스 구현클래스에서 인터페이스를 구현하기 위해서는 implements 키워드를 사용합니다.interface Animal {    move(): void;}class Dog implements Animal {        move(): void {        console.log(\"네발로 걷습니다.\");    }}let dog: Dog = new Dog();dog.move();구현을 강제한다는 점에서 추상 클래스와 비슷하지만 추상 클래스와 달리 인터페이스는 다중 상속이 가능합니다. 상황에 따라 중복된 기능을 가지며 같은 조상으로 부터 물려받을 것이 보장되길 원한다면 추상클래스를, 기능이 중복되지만 조상이 다르다면 인터페이스를 사용하면 됩니다.",
        "url": "/typescript/interface"
    }
    ,
    
    "typescript-syntax": {
        "title": "타입스크립트 문법(TypeScript Syntax)",
            "author": "rubisco",
            "category": "",
            "content": "기본 타입자바스크립트는 다음과 같이 7가지 내장 타입을 제공합니다.  Number  String  Boolean  Symbol  Null  Undefined  Object타입스크립트에는 자바스크립트의 내장 타입에 해당하는 원시 타입이 있습니다.  number  string  boolean  symbol  null  undefined  object타입스크립트에만 존재하는 원시 타입도 있습니다.  unknown  never  void  any그 외에도 다음과 같은 참조 타입이 있습니다.  Array  Tuple  Enum원시 타입(Primitive Type)불리언(Boolean)boolean은 가장 기본적인 데이터 타입으로, 참/거짓(true/false)값을 나타냅니다.let isDone: boolean = false;숫자(Number)자바스크립트처럼 타입스크립트의 모든 숫자는 부동소수점을 사용합니다. 16진수, 10진수 literal과 2진수, 8진수 literal도 지원합니다.let decimal: number = 10;let hex: number = 0xff0a;let binary: number = 0b1010;let octet: number = 0o777;문자열(String)자바스크립트와 마찬가지로 큰따옴표(\") 또는 작은따옴표(')를 통해 문자열을 나타냅니다.let color: string = \"red\";let name: string = 'rubisco';백틱(`)으로 문자열을 감싸서 템플릿 문자열을 만들 수도 있습니다.let name: string = \"rubisco\";let introduce: string = `안녕하세요? ${ name } 입니다.`; // \"안녕하세요? \" + name + \" 입니다.\" 와 동일Null / Undefinednull과 undefined 타입은 각각 null과 undefined라는 하나의 값만을 가집니다. null은 변수를 선언했지만 빈값을 할당한 상태를 의미하며, undefined는 변수를 선언했지만 값이 없는 상태 즉, 타입이 없는 상태를 의미합니다. typeof 메소드를 통해 자료형을 확인해보면 null은 object, undefined는 undefined 타입인 것을 확인할 수 있습니다.null과 undefined는 기본적으로 모든 타입의 하위타입이므로 아무런 설정이 없다면 아래와 같은 할당이 허용됩니다.let name: string = null;하지만 이러한 동작은 버그를 양산하기 쉽습니다. 엄격한 타입 체크를 위해 타입스크립트 2.0부터 옵션으로 --strictNullChecks 플래그가 추가되었습니다. 옵션에 이 플래그를 추가하면 null과 undefined 값을 다른 타입에 할당하는 것을 방지할 수 있습니다.Any / Unknownany 타입은 모든 데이터 타입을 허용할 때 사용합니다. 데이터 타입을 미리 알 수 없는 경우 사용할 수 있지만 불가피한 경우를 제외하고는 사용하지 않는것이 권장됩니다. 보통 자바스크립트 문법을 점진적으로 타입스크립트 문법으로 바꿀때 사용합니다.let letter: any = \"문자\";letter = 20; // string 타입이 들어있지만 number 타입이 들어갈 수 있습니다.unknown 타입은 타입스크립트 3.0부터 도입되었습니다. any 타입과 동일하게 모든 타입의 값을 허용하지만 엄격한 타입 체크를 요구합니다.let num: any = 10;console.log(num.length); // undefined 출력let unknownValue: unknown = 10;console.log(unknownValue.length); // 에러 발생 : Object is of type 'unknown'.ts(2571)num 변수와 unknwonValue 변수에는 숫자가 할당되어 length 메소드를 가지고 있지 않습니다. any타입인 num의 경우 length 메소드를 호출하면 undefined 값을 출력합니다. 반면에 unknown 타입인 unknownValue는 오류를 출력합니다.unknown 타입의 경우 다음과 같은 엄격한 타입체크가 필요합니다.let unknownValue: unknown = 10;if(typeof unknownValue === \"string\") {    console.log(unknownValue.length);} else {    console.log(undefined);}Void / Nevervoid 타입은 null과 undefined만 값으로 가질 수 있는 타입입니다. 함수에서는 리턴값이 없을때 사용합니다.function msg_logger(msg: any): void {    console.log(msg);}never 타입은 아무런 값을 가지지 않는 타입입니다. null, undefined를 포함한 모든 타입의 최하위 타입에 속하기 때문에 never을 제외한 어떤 값도 할당될 수 없습니다. 무한 루프를 돌거나 에러를 출력하는 함수의 경우 리턴값 자체가 없기때문에 never 타입을 가집니다.function infiniteLoop(): never {    while (true) {} // 무한 루프}function error(message: string): never {    throw new Error(message); // 에러 출력}참조 타입(Reference Type)객체(Object)자바스크립트는 프로토타입 객체 기반 언어로, 원시 자료형을 제외한 모든 데이터가 객체(Object)로 구성됩니다.object 타입은 중괄호({})를 사용하여 선언할 수 있습니다.let user: {name: string, age: number} = {name: '홍길동', age: 19};위에 코드에 보는 바와 같이 콜론(:)의 좌변에는 속성의 키워드값이, 우변에는 속성 타입이 들어갑니다. 각 속성의 구분은 위에 코드처럼 콤마(,)로 구분하며, 세미콜론(;)을 통해서도 구분가능합니다.let user: {    name: string;     age: number;} = {name: '홍길동', age: 19};속성명 뒤에 물음표(?)를 붙이면 해당 속성을 선택 속성으로 선언할 수 있습니다.let user: {    name: string;     age: number;    comment?: string;} = {name: '홍길동', age: 19};위 코드에서 comment의 값은 할당되지 않았지만 선택속성이므로 오류없이 객체 값이 할당될 수 있습니다.속성명 앞에 readonly 키워드를 붙이면 값의 재할당을 막을 수 있습니다. 변수에서 const 키워드를 통한 변수 할당과 동일합니다.let user: {    readonly name: string;     age: number;} = {name: '홍길동', age: 19};user.name = '고길동'; // error TS2540: Cannot assign to 'name' because it is a constant or a read-only property.배열(Array)배열의 경우 2가지 방법으로 타입을 지정할 수 있습니다.첫번째 방법은 타입 뒤에 []을 붙이는 것입니다.let colors: string[] = ['red','orange','yellow','green'];두번째 방법은 제네릭(generic) 배열 타입을 사용하는 것입니다.let colors: Array&lt;string&gt; = ['red','orange','yellow','green'];튜플(Tuple)튜플은 배열과 유사하며, 요소(element)의 수가 고정된 배열을 나타낼 수 있습니다.let member: [number, string] = [1, 'rubisco'];열거(Enum)열거형은 자바의 열거형과 마찬가지로 숫자 또는 문자열 값의 집합에 이름을 부여할 수 있습니다.enum Week { SUN, MON, TUE, WED, THU, FRI, SAT }let today: Week = Week.WED;인덱스 번호로도 접근가능합니다.enum Week { SUN, MON, TUE, WED, THU, FRI, SAT }let tomarrow: Week = Week[4]; // Week.THU와 동일자바처럼 초기 인덱스 번호를 지정해 줄 수도 있습니다.enum Week { SUN = 1, MON, TUE, WED, THU, FRI, SAT }let yesterday: Week = Week[3]; // Week.TUE와 동일또한 자바와 달리 문자열 값을 지정해 줄 수 있습니다.enum Color {    RED = \"red\",    BLUE = \"blue\",    GREEN = \"green\"}let color: Color = Color.RED; // 문자열 \"red\"와 동일타입 추론과 타입 단언타입 추론(Type Inference)타입 추론(Type Inference)이란 타입스크립트가 코드를 해석해나가는 동작을 의미합니다. 아래와 같이 타입을 선언하지 않고 변수에 값을 할당하면 타입스크립트에서는 str 변수를 string 타입으로 추론합니다.let str = \"spot\" // string 타입 값이 할당되었으므로 string 타입으로 추론그러므로 str 변수에 문자열이 아닌 숫자를 재할당한다면 오류가 발생합니다.str = 1 // Type 'number' is not assignable to type 'string'.const나 readonly 키워드가 있는 경우 타입스크립트는 구체적인 literal 타입을 추론합니다.const x = 1 // 1로 추론타입 단언(type assertion)타입스크립트 컴파일러는 타입 표기, 타입 추론 등을 이용해 값의 타입을 판단합니다. 하지만 때로는 컴파일러가 가진 정보를 무시하고 개발자가 원하는 임의의 타입을 값에 할당하고 싶을 수 있는데, 이때 필요한 것이 타입 단언(type assertion)입니다.let div = document.querySelector('div');div.innerText = \"rubisco\"; // Object is possibly 'null'.ts(2531)위의 코드의 경우 타입스크립트는 div가 null일 경우까지 추론하게 됩니다. div가 null일 경우 innerText 메소드가 존재하지 않게 되므로 오류를 출력하게 됩니다. 이럴때 변수 뒤에 as 키워드를 붙여 타입 단언을 해줄 수 있습니다. 자바에서 명시적 형변환(Casting)과 같은데, 형변환은 런타임에서 발생하는 동작이고 타입 단언은 컴파일시 발생하는 동작이라는 차이가 있습니다.let div = document.querySelector('div');(div as HTMLDivElement).innerText = \"rubisco\";변수 뒤에 느낌표(!)를 붙여서 값이 무조건 존재한다는 확정적 할당 단언(definitive assignment assertion)을 함으로써 이를 해결할 수도 있습니다.let div = document.querySelector('div');div!.innerText = \"rubisco\";제네릭(Generic)제네릭은 자바 또는 C# 등의 언어에서 재사용성이 높은 컴포넌트를 만들 때 자주 활용되는 특징입니다. 특히, 한가지 타입보다 여러 가지 타입에서 동작하는 컴포넌트를 생성하는데 사용됩니다. 함수나 클래스를 사용하는 시점에 타입을 선언함으로써 타입을 파라미터처럼 사용할 수 있습니다.제네릭 타입은 함수 이름 뒤에 괄호(&lt;&gt;)로 표기하며 괄호안에 타입명을 적습니다. 관습적으로 T는 Type, E는 Element, K는 Key, V는 Value, N은 Number를 뜻합니다.아래와 같이 코드를 작성해 봅시다.function toArray(a: number | string, b: number | string): (number | string)[] {    return [a, b];}let o1 = toArray(1, 2); // 배열 [1, 2]가 대입let o2 = toArray(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 선언에서 | 기호는 OR를 의미합니다. 다시 말해서 toArray 함수의 파라미터는 숫자형이나 문자형의 데이터를 받을 수 있습니다. 이를 제네릭을 통해 선언하면 다음과 같이 작성할 수 있습니다.function toArray&lt;T&gt;(a: T, b: T): T[] {    return [a, b];}let o1 = toArray&lt;number&gt;(1, 2); // 배열 [1, 2]가 대입let o2 = toArray&lt;string&gt;(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 추론을 통해 아래와 같이 타입 변수를 생략해도 됩니다.function toArray&lt;T&gt;(a: T, b: T): T[] {    return [a, b];}let o1 = toArray(1, 2); // 배열 [1, 2]가 대입let o2 = toArray(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 변수를 여러 개 지정할 수도 있습니다.function toArray&lt;T, U&gt;(a: T, b: U): [T, U] {    return [a, b];}let o1 = toArray(1, \"a\"); // 배열 [1, \"a\"]가 대입제네릭을 사용하지 않으면 선언해준 데이터 타입으로만 반환값을 선언할 수 있습니다. 즉, 정적입니다. 하지만 제네릭을 사용한다면 동적으로 반환값을 선언할 수 있습니다.물론 다음과 같이 any 타입으로 동적 선언을 해줄 수도 있습니다.function toArray(a: any, b: any): any {    return [a, b];}이렇게 타입을 선언한다고 해서 함수의 동작에 문제가 발생하지는 않지만, 타입 검사를 하지 않기때문에 오류를 찾아내는 것이 힘들어집니다. 제네릭을 통해 타입을 선언한다면 타입 검증 과정을 거치기 때문에 좀 더 효율성 있는 개발이 이루어질 수 있을 것입니다.",
        "url": "/typescript/syntax"
    }
    ,
    
    "typescript-typescript": {
        "title": "타입스크립트(TypeScript)란?",
            "author": "rubisco",
            "category": "",
            "content": "자바스크립트(JavaScript)자바스크립트는 모질라 재단에서 개발한 프로토타입 기반의 스크립트 언어입니다. HTML, CSS와 함께 웹을 구성하는 요소중 하나입니다. HTML이 웹페이지의 구조를 정의하고 CSS가 웹페이지를 디자인 한다면 자바스크립트는 클라이언트 단에서 웹페이지가 동적으로 동작하도록 합니다.HTML5가 등장하기 이전에 웹 애플리케이션(Web Application)은 어도비 플래시(Adobe Flash)나 마이크로소프트 실버라이트(Microsoft Silverlight), 마이크로소프트 액티브X(Microsoft ActiveX) 등의 외부 플러그인에 의존했습니다.그러나 HTML5의 등장 이후 플러그인의 기능이 자바스크립트로 구현가능해졌고, AJAX의 활성화로 SPA(Single Page Application)가 대세가 되었습니다.또한 예전에는 웹브라우저의 인터프리터에 의해 클라이언트 단에서만 동작했지만 Node.js가 등장하면서 서버 단에서도 런타임 환경에서 동작이 가능해졌습니다.타입스크립트(TypeScript)타입스크립트는 마이크로소프트에서 구현한 자바스크립트 슈퍼셋 프로그래밍 언어입니다. 즉, 자바스크립트 문법에 타입스크립트 문법을 추가한 언어입니다. 이때문에 올바르게 작성된 자바스크립트 코드는 타입스크립트 코드로 사용가능합니다.자바스크립트가 동적 타입의 인터프리터 언어로 런타임에서 오류를 발견할 수 있는 반면 타입스크립트는 정적 타입의 컴파일 언어로 타입스크립트 컴파일러 또는 바벨(Babel)을 통해 자바스크립트 코드로 컴파일해야합니다. 즉, 타입스크립트는 변수나 함수에 타입을 명시하여 사전에 오류를 발견하여 자바스크립트 개발의 생산성을 높일 수 있습니다.타입스크립트는 2020년 스택 오버플로(Stack Overflow)에서 전세계 6만 5천 명의 개발자를 대상으로 실시한 설문조사에서 개발자가 가장 좋아하고 관심을 가지는 프로그래밍 언어 2위에 오를 정도로 인기있는 언어입니다. 요즘은 대형 SI 프로젝트에서 흔하게 사용되고 있으며, 개발자 구인 시 자바스크립트보다 타입스크립트를 우대기술로 언급하고 있습니다.타입스크립트 사용 이유에러를 사전에 발견앞서 설명했듯이 타입스크립트는 코드를 컴파일을 필요로 정적인 언어이며, 타입을 명시하기때문에 사전에 에러를 검출하는 것이 가능합니다.function sum(a, b) {    return a + b;}sum('1', '2'); // '12'위의 덧셈 함수는 1 + 2를 의도했을테지만, 자바스크립트의 경우 타입이 명시적이지 않기 때문에 동적 타이핑(Dynamic Typing)에 의하여 숫자 3이 아닌 문자열 '12'를 출력합니다.즉, 개발자가 의도하지 않은 값이 나올 수 있으며 디버깅이 어렵게 됩니다.function sum(a: number, b: number) {    return a + b;}sum('1', '2'); // error TS2345: Argument of type '\"1\"' is not assignable to parameter of type 'number'.반면 타입스크립트의 경우 타입을 number라고 명시했기때문에 문자열이 들어간다면 컴파일 단계에서 사전에 오류를 포착할 수 있습니다. 명시적인 정적 타입 지정은 개발자의 의도를 명확하게 기술하여 코드 가독성을 높이고 디버깅을 쉽게 할 수 있도록 합니다.도구의 지원타입스크립트는 IDE를 포함한 다양한 도구의 지원을 받을 수 있습니다. Visual Studio Code의 경우 툴의 내부가 타입스크립트로 작성되어 있기 때문에 타입스크립트 개발에 최적화 되어 있습니다.변수 a의 타입은 number 이므로 toLocaleString 함수를 사용가능합니다. 자바스크립트의 경우 함수명을 직접 입력해야 하지만, 타입스크립트는 스니펫을 통해 빠른 코드 작성이 가능합니다.자바스크립트 호환타입스크립트는 자바스크립트의 슈퍼셋 언어이므로 자바스크립트와 100% 호환됩니다. 따라서 자바스크립트로 작성된 코드를 쉽게 타입스크립트로 변환할 수 있습니다.개발환경 구축우분투 20.04 LTS 버전을 기준으로 타입스크립트 개발환경을 구축해 보겠습니다.작업공간(work space) 만들기프로젝트를 위한 작업공간을 하나 생성합시다.~$ mkdir -p ws/typescript &amp;&amp; cd ws/typescriptnodejs 설치apt를 통해 nodejs와 npm을 설치합니다.~/ws/typescript$ sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install nodejs npmnodejs의 여러버전을 관리하고 싶다면 nvm을 통해 설치할 수도 있습니다.NVM GitHub에서 버전을 확인후 설치해주세요.~/ws/typescript$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash설치후 다음 명령어를 입력하여 NVM을 활성화 시킵니다.~/ws/typescript$ source ~/.bashrcnodejs 설치는 다음과 같습니다.$ nvm install node  # 최신 버전 설치$ nvm install --lts # 최신 LTS 버전 설치$ nvm install 16.14.0  # 특정 버전 설치$ nvm install 16  # 특정 버전 16의 최신 릴리즈 설치typescript 설치npm을 통해 타입스크립트를 전역으로 설치합니다. nodejs와 npm이 설치되어있어야 합니다.~/ws/typescript$ sudo npm i -g typescript설치가 되었는지 확인하기 위해 다음 명령어를 입력합니다.~/ws/typescript$ tsc -v프로젝트 내에서만 타입스크립트를 설치하고 싶다면 다음과 같이 명령어를 입력합니다.~/ws/typescript$ npm i typescript -D~/ws/typescript$ npx tsc -v타입스크립트 파일 코드 작성타입스크립트의 확장자는 .ts입니다. app.ts 파일을 생성후 에디터로 엽니다.~/ws/typescript$ touch app.ts &amp;&amp; nano app.ts다음 예제 코드를 작성하세요.const message: string = 'hello world';console.log(message);컴파일(Compile)코드를 저장하고 다음 명령어를 입력하여 컴파일합니다.~/ws/typescript$ tsc app.ts컴파일이 완료되면 자바스크립트 파일(app.js)이 생성됩니다.var message = 'hello world';console.log(message);자동으로 컴파일하고 싶다면 --watch 또는 -w 옵션을 주면 됩니다.설정파일 : tsconfig.json컴파일시 명령어를 통해 여러 옵션을 줄 수 있습니다.~$ tsc app.ts --strict true --target ES6 --lib ES2015,DOM --module CommonJS옵션 명령어 뿐만 아니라 tsconfig.json 파일을 통해서도 옵션을 줄 수 있습니다. 다음 명령어를 통해 default 설정파일을 생성할 수 있습니다.~$ tsc --init컴파일 옵션에 대해서는 다음 페이지를 참조하세요: 영문 / 한글",
        "url": "/typescript/typescript"
    }
    ,
    
    "etc-iso-standard-7498": {
        "title": "OSI 7계층(ISO Standard 7498)",
            "author": "rubisco",
            "category": "",
            "content": "OSI 7계층데이터를 주고 받는 과정에는 많은 단계가 있습니다. 국제표준화기구(ISO)에서는 이를 역할에 따라 7개의 계층으로 나누었습니다. 이것을 OSI 7계층(Open Systems Interconnection 7 Layer)이라고 합니다.각 계층은 독립적으로 작용하며 수많은 프로토콜(Protocol)이 존재하는데 프로토콜이란 데이터를 주고 받기위한 일종의 약속을 말합니다. 프로토콜에 의해 하위 계층으로 갈수록 헤더가 붙으면서 데이터의 크기는 커집니다.            OSI 모델      프로토콜                  1층: 물리 계층      1000BASE-T, RS-232, RS-485              2층: 데이터 링크 계층      이더넷(Ethernet), PPP, UART              3층: 네트워크 계층      IP, ICMP              4층: 전송 계층      TCP, UDP              5층: 세션 계층      SSH, TLS, RPC              6층: 표현 계층      ASCII, MPEG, JPEG              7층: 응용 계층      HTTP, FTP, Telnet, DHCP      물리 계층 (Physical Layer)물리 계층의 데이터 단위는 비트(bit)이며, 네트워크 케이블과 신호에 관한 규칙을 다루고 있는 계층입니다. 통신 케이블의 종류와 신호의 규격 및 무선통신 주파수 설정, 커넥터 형태 등을 정합니다.물리 계층과 관련된 장비로는 동축 케이블의 아날로그 신호를 디지털 데이터로 변환하는 모뎀(Modem), 다수의 컴퓨터를 연결하여 하나의 네트워크로 보내는 허브(Hub), 디지털 신호를 증폭해주는 리피터(Repeater) 등이 있습니다.데이터 링크 계층 (Datalink Layer)데이터 링크 계층의 데이터 단위는 프레임(frame)이며, 물리적 매체를 통해 데이터를 전달하는 계층입니다. 네트워크 계층에 데이터를 전달하고 물리계층에서 발생하는 오류를 탐지하고 수정하는 기능을 담당합니다. 또한 MAC주소(Media Access Control Address)라는 물리적 주소를 사용하여 각 기기들의 구분을 가능하게 합니다.이 계층과 관련된 프로토콜에는 HDLC, PPP, LLC 등이 있으며, 관련된 장비로는 데이터를 MAC주소를 기반으로 빠르게 전달하는 스위치(Switch), 2개의 랜을 연결하는 브릿지(Bridge) 등이 있습니다.네트워크 계층 (Network Layer)네트워크 계층의 데이터 단위는 패킷(packet)이며, 네트워크를 논리적으로 구분하는 계층입니다. 인터넷에서는 IP주소(Internet Protocol Address)라는 논리적 주소를 사용합니다. 이 계층에서는 전송 계층에서 요구하는 서비스 품질(Qos)를 위한 수단을 제공합니다. 또한 라우팅 프로토콜을 통해 데이터를 전송하는 최적의 경로를 찾아냅니다.관련된 프로토콜에는 IP, ARP, RARP, ICMP, IGMP 등이 있으며, 관련된 장비로는 랜을 연결하는 라우터(Router)가 있습니다.전송 계층 (Transport Layer)전송 계층은 서비스를 구분하고 사용자 사이의 신뢰성 있는 데이터 전달을 담당하는 계층입니다.이 계층의 프로토콜에는 신뢰성있는 데이터 전송이 목적인 TCP(Transmission Control Protocol)와 빠른 데이터 전송이 목적인 UDP(User Datagram Protocol)가 있습니다.TCP는 세그먼트(Segment)라는 데이터 단위를 사용하며 UDP는 데이터그램(Datagram)이라는 데이터 단위를 사용합니다.TCP는 세그먼트를 작은 패킷으로 나눠 여러 경로를 통해 데이터를 전송하고 목적지에서 순서대로 패킷을 조립하여 데이터를 전달합니다. 반면 데이터그램은 순서에 상관없이 데이터를 전달하기때문에 신뢰성은 없습니다.세션 계층 (Session Layer)세션 계층은 두 컴퓨터 사이에 연결을 형성하고 유지 및 종료하는 기능을 담당하는 계층입니다. 일종의 대화통로라고 보면 됩니다. 데이터의 송수신 타이밍과 방법은 이 계층에서 규정됩니다.세션 계층의 프로토콜에는 SSH, TLS, RPC 등이 있으며, 데이터 전송 보안과 관련있습니다.표현 계층 (Presentation Layer)표현 계층은 전송되는 정보의 구문(Syntax) 및 의미(Semantics)에 관여하는 계층으로, 인코딩(Encoding), 데이터 압축(Compression), 암호화(Cryptography) 등 주요한 동작을 수행합니다. 파일의 확장자(txt, jpeg, mp4, html 등)는 이 계층과 관련된 프로토콜입니다.응용 계층 (Application Layer)응용 계층은 응용 서비스를 수행하고 사용자 인터페이스를 제공하는 계층입니다. 대표적인 프로토콜로는 html 문서 전송 프로토콜인 HTTP(HyperText Transfer Protocol), 파일 전송 프로토콜인 FTP(File Transfer Protocol), 메일 전송 프로토콜인 SMTP(Simple Mail Transfer Protocol) 등이 있습니다.TCP/IP인터넷에서 데이터를 주고 받을때 대부분 전송 계층에 속하는 TCP(Transmission Control Protocol)​와 네트워크 계층에 속하는 IP(Internet Protocol)를 많이 사용하는데 이를 묶어 TCP/IP(Transmission Control Protocol/Internet Protocol)라고 합니다. 1960년대 미 국방성에서 개발한 통신 프로토콜이며, 현재는 대부분의 컴퓨터가 기본으로 제공하는 인터넷 표준 프로토콜입니다. TCP/IP는 데이터 전송 과정을 4계층으로 나누며, OSI 모델과 다르게 각 계층이 서로 종속적입니다.네트워크 인터페이스(Network Interface) 계층네트워크 인터페이스 계층은 운영체제의 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련된 모든 것을 지원하는 계층입니다. 상위 계층(IP)에서 패킷이 도착하면 헤더에 프리앰블(Preamble)과 CRC(Cyclic Redundancy Check)를 추가합니다. 송신 측 단말기는 인터넷 계층으로부터 전달받은 패킷에 물리적 주소(MAC) 정보를 가지는 헤더를 추가하여 프레임을 만들어 전달합니다.관련 프로토콜에는 이더넷(Ethernet), 802.11x, MAC/LLC, PPP 등이 있습니다.인터넷(Internet) 계층인터넷 계층은 패킷의 인터넷 주소를 결정하고 경로를 배정하는 역할을 합니다. 관련된 프로토콜에는 IP(Internet Protocol), IP를 MAC으로 변환하는 ARP(Address Resolution Protocol), IP 패킷을 전달하는 동안 발생한 오류를 보고하는 ICMP(Internet Control Message Protocol) 등이 있습니다.인터넷은 INTERconnected NETwork에서 만들어진 합성어로, TCP/IP를 통해 연결된 모든 네트워크의 집합체입니다.IP 주소에는 32비트 체계인 IPv4와 128비트 체계인 IPv6가 있습니다.IPv4는 최대 65,532byte로 이루어져 있으며, 5개의 클래스로 나눠집니다. 유니캐스트, 브로드캐스트, 멀티캐스트를 지원합니다.IPv6는 IPv4의 주소 부족 문제를 해결하기 위해 만들어졌으며, 유니캐스트, 멀티캐스트, 애니캐스트를 지원합니다.전송(Transport) 계층전송 계층은 네트워크 양단의 호스트 사이의 신뢰성 있는 전송 기능을 제공합니다. 시스템의 논리 주소와 포트를 가지며, TCP와 UDP가 사용됩니다.TCP의 경우 3 Way-Handshake라는 방식으로 통신합니다. 장치간에 연결이 잘 되었는를 3번의 과정을 통해 확인하여 데이터 전송의 신뢰성을 확보합니다.SYN은synchronize sequence numbers의 약자이고 ACK는 acknowledgements의 약자입니다. 상태에 대한 설명은 아래 테이블을 참조하세요.            상태      설명                  CLOSED      닫힌 상태              LISTEN      요청 대기 상태              SYN-SENT      SYN 요청 상태              SYN-RECEIVED      SYN 요청을 받은 상태              ESTABLISHED      연결 확인 상태      (1) 클라이언트가 서버에게 SYN을 요청하고 SYN-SENT 상태가 됩니다.(2) SYN을 요청받은 서버는 SYN-RECEIVED 상태가 되고, SYN과 함께 ACK를 클라이언트에게 읍답합니다.(3) SYN+ACK를 응답받은 클라이언트는 ACK를 서버에 요청하고 클라이언트와 서버는 ESTABLISHED 상태가 됩니다.쉽게 말해서 클라이언트가 “내말 들려?” 라고 요청을 보내면 서버가 “응 들려, 넌 내말 들려?” 라고 응답하고,  클라이언트가 “응, 나도 들려” 라고 대답하면서 대화가 시작되는겁니다.응용(Application) 계층OSI 참조 모델의 세션, 표현, 응용 계층을 합친 계층입니다.",
        "url": "/etc/iso-standard-7498"
    }
    ,
    
    "etc-docker": {
        "title": "도커(Docker) 설치하기",
            "author": "rubisco",
            "category": "",
            "content": "도커란?도커는 컨테이너 기반 오픈소스 가상화 플랫폼입니다. 컨테이너란 격리된 공간에서 프로세스가 실행되도록 하는 기술입니다.버추얼머신(VM)이라고 들어보셨을겁니다. 버추얼머신은 격리된 공간에서 OS가 실행되도록 하는 기술입니다. 윈도우에 격리된 리눅스를 설치한 것이라 보면 됩니다. 쉽게말해서 컴퓨터 안에 가상의 컴퓨터가 있는겁니다.버추얼머신은 이미 설치되어 있는 OS위에 새로운 OS를 실행시키기때문에 조금 무겁습니다. 그에 비하여 도커는 기존 OS 위에 격리된 프로세스 공간을 만들어 실행시키때문에 가볍고 빠르게 동작합니다.도커를 사용하는 이유는 프로그램마다 운영환경이 다르기때문입니다. 예를 들어 A라는 프로그램은 파이썬3.8을 기반으로 작동하는데 OS에는 파이썬 3.5가 설치되어있다면 파이썬3.8을 추가적으로 설치해야합니다. ‘그럼 그냥 파이썬 3.8을 설치하면 되지’라고 생각하는 분도 있을겁니다.  하지만 프로그램은 무수히 많고 프로그램을 설치할때마다 환경을 따로 설정하는 것은 여간 번거로운 일이 아닙니다.도커를 사용한다면 격리된 가상의 공간에 배포자가 작성한 운영환경에 필요한 라이브러리를 설치하여 프로세스를 실행시키게 됩니다. 즉 따로 프로그램에 맞춰 환경설정을 할 필요가 없다는 뜻입니다.도커 설치오라클 클라우드를 통해 우분투 20.04 환경에서 도커를 설치해보겠습니다.(1) 우선 SSH를 통해 오라클 클라우드에 원격접속해주세요.$ ssh [USER]@[HOSTNAME] -p [PORT](2) 패키지를 최신상태로 업데이트 해주세요.$ sudo apt update &amp;&amp; sudo apt upgrade(3) 필수 패키지를 설치하세요.$ sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release(4) 도커와 암호화 통신을 위한 GPG 키를 추가해주세요.$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg(5) apt로 설치하기위해 stable repository를 등록합니다.echo \\  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null(6) apt로 도커 엔진을 설치합니다.$ sudo apt update$ sudo apt install docker-ce docker-ce-cli containerd.io(7) 버전을 확인해봅시다.$ sudo docker version(8) 권한을 지정하여 sudo 없이 도커를 사용할 수 있도록 합시다.$ sudo usermod -aG docker $USER포테이너(Portainer) 설치포테이너는 도커를 웹에서 GUI로 관리할 수 있는 도구입니다. 포테이너를 도커에 설치하겠습니다.(1) 포테이너 데이터를 저장할 볼륨(공간)을 만듭니다.$ docker volume create portainer_data(2) 도커로 포테이너 컨테이너를 생성합니다.$ docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce-d : 백그라운드 모드(detached mode) 실행-p 9000:9000 : 호스트 포트를 컨테이너 포트에 연결 (호스트:컨테이너)--name portainer : 컨테이너 이름 설정--restart aloways : 도커 실행시 컨테이너 실행 여부 설정-v portainer_data:/data : 호스트 볼륨을 컨테이너 볼륨에 연결portainer/portainer-ce : 컨테이너 이미지 이름포테이너가 9000번 포트에서 실행됩니다. 그러나 오라클 클라우드의 경우 22번 포트만 열려 있으므로 방화벽을 Open해야합니다. 아래 방화벽 오픈(Open)를 참조하세요.(3) 아이디와 암호를 입력하고 Create user를 클릭하여 계정을 생성합니다.(4) Get Started를 클릭합니다.(5) 설정이 완료되었습니다! 아래 사진과 같이 도커의 상태를 확인할 수 있습니다.방화벽 오픈(Open)(1) 오라클 클라우드에 로그인 후 홈 -&gt; 인스턴스를 선택합니다.(2) 생성된 인스턴스를 클릭합니다.(3) 보안 목록을 클릭합니다.22번 포트만 열려있는 것을 확인할 수 있습니다.(4) 수신 규칙 추가를 클릭합니다.(5) 소스 CIDR에 0.0.0.0/0, 대상 포트 범위에 9000을 입력하고 수신 규칙 추가를 클릭합니다.(6) OS 방화벽을 오픈합니다.iptables은 재부팅할때마다 설정 내용이 초기화되므로 iptables을 날리고 ufw를 사용하겠습니다.우선 iptables 룰 정책을 저장하기 위한 패키지를 설치합니다.$ sudo apt install iptables-persistent netfilter-persistent net-tools(7) 정책을 영구 저장합니다.$ sudo netfilter-persistent save(8) ufw에서 9000번 포트를 허용해줍니다. SSH 접속을 유지하기위해 22번 포트도 추가해줍니다.$ sudo ufw allow 9000$ sudo ufw allow 22(9) ufw를 켭니다.$ sudo ufw enable",
        "url": "/etc/docker"
    }
    ,
    
    "design-pattern-creational-singleton-pattern": {
        "title": "싱글톤 패턴(Singleton Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        싱글톤 패턴(Singleton Pattern)싱글톤 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 접근할 수 있는 방법을 제공합니다. 즉, 특정 클래스의 객체는 하나만 생성되도록 하여 동일 인스턴스를 재사용 하는 패턴입니다.구조참여 객체Singleton생성자의 접근자를 private로 설정하여 새로운 인스턴스를 생성하지 못하도록 하고, 인스턴스(Instance)의 접근을 위한 오퍼레이션(Operation)을 static으로 정의하여 해당 메소드에 의해서만 인스턴스의 접근이 가능하도록 합니다.인스턴스는 싱글턴 객체의 클래스 변수로 설정되어 클래스가 메모리의 데이터영역에 저장될 때 같이 저장됨으로써 오직 한번만 인스턴스를 생성할 수 있습니다. 이로써 싱글턴 객체는 유일한 인스턴스의 생성에 대한 책임을 지게 됩니다.종류이른 초기화 방식 (Eager Initialization)이른 초기화 방식은 싱글톤 패턴의 가장 기본적인 유형입니다.전역변수로 인스턴스를 생성하고 접근자를 private로 설정함으로써 싱글톤 객체의 오퍼레이션 메소드에 의해서만 접근이 가능하도록 합니다. 또한 생성자의 접근자를 private로 절정함으로써 외부에서 인스턴스를 생성할 수 없도록 만듭니다.EagerSingleton.javapackage design_pattern.creational.singleton;public class EagerSingleton {        private static final EagerSingleton INSTANCE = new EagerSingleton();    private EagerSingleton() {}    public static EagerSingleton getInstance() {        return INSTANCE;    }}자바에서는 static으로 선언한 클래스 변수가 곧 전역변수입니다. 클래스가 메모리의 데이터 영역에 저장될 때 클래스 변수인 INSTANCE는 싱글톤 인스턴스를 한번만 생성하여 참조함으로써 동일한 인스턴스를 재사용하는 싱글톤 원칙을 지킬 수 있게 됩니다.이른 초기화 방식의 장점은 전역변수로 싱글톤 인스턴스를 만들었기때문에 클래스 로더에 의하여 클래스가 로딩될 때 오직 한번만 인스턴스가 생성되므로 Thread-safe하게 싱글톤 객체를 생성할 수 있습니다.단점은 객체의 사용여부와 상관없이 클래스 로딩 시점에 인스턴스가 생성되어 프로그램이 종료될때까지 메모리를 점유하기때문에 자주 사용하지 않는 객체라면 비효율적일 수 있습니다.늦은 초기화 방식 (Lazy Initialization)늦은 초기화 방식은 이른 초기화 방식과 반대로 클래스의 오퍼레이션 메소드가 호출될 때 인스턴스를 생성합니다. 즉, 클래스 메소드가 호출될 때까지 메모리를 점유하지 않습니다.LazySingleton.javapackage design_pattern.creational.singleton;public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {}    public static LazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new LazySingleton();        }        return INSTANCE;    }}늦은 초기화 방식의 장점은 필요할때 객체를 생성할 수 있다는 것입니다.단점은 멀티 쓰레드(Thread) 환경에서 동시에 호출되어 싱글톤 원칙을 보장할 수 없다는 것입니다.쓰레드 안전 이른 초기화 방식 (Thread safe Lazy Initialization)늦은 초기화 방식을 보완하여 synchronized 키워드를 메소드에 선언하여 쓰레드 안전(Thread safe) 상태로 싱글톤을 생성할 수 있는 방식입니다. synchronized로 선언된 메소드는 하나의 쓰레드가 메소드를 사용하면 lock을 걸어 다른 쓰레드를 대기상태로 만듭니다.ThreadSafeLazySingleton.javapackage design_pattern.creational.singleton;public class ThreadSafeLazySingleton {    private static ThreadSafeLazySingleton INSTANCE = null;    private ThreadSafeLazySingleton() {}    public static synchronized ThreadSafeLazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new ThreadSafeLazySingleton();        }        return INSTANCE;    }}이 방식의 장점은 Thread-safe 환경이라는 것입니다.단점은 syncronized가 선언된 메소드가 호출이 많으면 성능이 나빠질 수 있습니다.DCL 방식 (Double-Checked locking)DCL 방식은 syncronized를 메소드에 선언하는 것이 아니라 메소드 내부에 syncronized 블락을 만드는 방식입니다.DCLSingleton.javapackage design_pattern.creational.singleton;public class DCLSingleton {    private volatile static DCLSingleton INSTANCE = null;    private DCLSingleton() {}    public static DCLSingleton getInstance() {        if(INSTANCE == null){            synchronized(DCLSingleton.class){                if(INSTANCE == null){                    INSTANCE = new DCLSingleton();                }            }        }        return INSTANCE;    }}위에 코드와 같이 인스턴스가 없을때 synchronized 키워드를 통해 블락을 만들어 하나의 쓰레드만 작업할 수 있도록 하고 블락 내부에서 다시한번 인스턴스 존재 여부를 체크하게 됩니다. 2번 체크하기때문에 DCL(Double Checking Locking) 방식이라 불립니다.private 접근자로 설정한 INSTANCE 클래스를 보면 volatile이라는 키워드를 사용했습니다. 하나의 프로세서(CPU)는 최적화를 위해 변수를 메인 메모리에 바로 저장하지 않고 캐쉬메모리에 저장하여 성능을 향상시킵니다. 그러나 volatile로 선언된 변수는 변수를 캐쉬메모리에 저장하지 않고 곧바로 메인메모리에 반영하도록 합니다.volatile 키워드를 사용하지 않고 멀티코어 환경에서 작업한다면 인스턴스를 캐쉬메모리에 저장하여 메인메모리에 인스턴스를 생성하기전에 다른 코어의 쓰레드가 비어있는 메모리를 참조하기때문에 문제가 발생할 수 있습니다.Holder에 의한 초기화 방식 (Initialization on demand holder idiom)이 방식은 클래스안에 클래스 홀더(Holder)를 두어 JVM 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방식입니다. 현재까지 가장 많이 이용되고 있는 방식입니다.StaticHolderSingleton.javapackage design_pattern.creational.singleton;public class StaticHolderSingleton {    private StaticHolderSingleton(){}\t\tprivate static class SingleTonHolder {\t\tprivate static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton();\t}\t\tpublic static StaticHolderSingleton getInstance(){\t\treturn SingleTonHolder.INSTANCE;\t}}위에 코드에서 보는 바와 같이 클래스 안에 private 접근자로 중첩클래스를 선언하고 중첩클래스 내부에 private 접근자로 클래스 변수를 선언했습니다. 중첩 클래스는 오퍼레이션 메소드(Operation Method)에 의하여 호출되기 전까지 참조되지 않으며, 오퍼레이션 메소드에 의하여 호출될때 클래스 로더에 의하여 싱글톤 인스턴스를 생성하게 됩니다.중첩클래스 내부에 선언된 클래스 변수는 static으로 선언되었기 때문에 중첩클래스가 로드되는 시점에 한번만 싱글톤 인스턴스를 생성할 수 있게 됩니다. 또한 final 키워드를 통해 다시 값이 할당되지 않도록 하여 싱글톤 원칙을 지킬 수 있게 됩니다.",
        "url": "/design-pattern/creational/singleton-pattern"
    }
    ,
    
    "design-pattern-intro": {
        "title": "디자인 패턴(Design Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        디자인 패턴디자인 패턴(Design Pattern)은 객체지향 프로그래밍을 할때 자주 접할 수 있는 문제를 해결하고자 만든 일종의 코드 패턴에 대한 템플릿(template)입니다.1990년대 초반 에리히 감마(Erich Gamma)에 의해 첫 소개된 이후 1995년에 이분야의 GoF(Gang of Four)라 불리는 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)에 의해 집대성 되었고, 이것이 GoF의 디자인 패턴(Design Pattern)으로 널리 알려졌습니다.디자인 패턴은 객체지향 모델링의 장점인 재사용성과 모듈성을 극대화 시켜서 이를 적용하면 시스템 개발은 물론 유지보수에도 큰 효과를 얻을 수 있습니다. 반면 객체지향 모델에 사용되므로 초기 개발시간이 길어져 소규모 프로젝트에는 적합하지 않을 수도 있습니다.디자인 패턴의 종류디자인 패턴은 크게 생성 패턴(Creational Pattern)과 구조 패턴(Structural Patterns), 행위 패턴(Behavioral Patterns)으로 나눠집니다.생성 패턴(Creational Pattern)은 객체(Object)의 인스턴스(Instance) 생성을 위한 패턴입니다. 클라이언트와 객체 인스턴스 사이의 연결을 끊어줍니다.생성 패턴에는 싱글톤 패턴(Singleton Pattern), 빌더 패턴(Builder Pattern), 팩토리 메서드 패턴(Factory Method Pattern), 추상 팩토리 패턴(Abstract Factory Pattern), 프로토타입 패턴(Prototype Pattern)이 있습니다.구조 패턴(Structural Patterns은 객체(Object)의 합성에 관한 패턴입니다. 객체의 조직화에 대한 패턴을 제공합니다.구조 패턴에는 어댑터 패턴(Adapter Pattern), 브리지 패턴(Bridge Pattern), 컴포지트 패턴(Composit Pattern), 데코레이터 패턴(Decorator Pattern), 퍼사드 패턴(Facade Pattern), 플라이웨이트 패턴(Flyweight Pattern), 프록시 패턴(Proxy Pattern)이 있습니다.행위 패턴(Behavioral Patterns)은 객체(Object)의 상호작용과 책임 분산에 대한 패턴을 제공합니다.행위 패턴에는 책임 연쇄 패턴(Chain of Responsibility Pattern), 커맨드 패턴(Command Pattern), 인터프리터 패턴(Interpreter Pattern), 이터레이터 패턴(Iterator Pattern), 메디에이터 패턴(Mediator Pattern), 메멘토 패턴(Memento Pattern), 옵저버 패턴(Observer Pattern), 상태 패턴(State Pattern), 전략 패턴(Strategy Pattern), 템플릿 메소드 패턴(Template Method Pattern), 비지터 패턴(Visitor Pattern)이 있습니다.",
        "url": "/design-pattern/intro"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://huimang2.github.io/">Rubisco's Programming Note</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search Rubisco's Programming Note</h1>
            <p class="subscribe-overlay-description">
            lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>


    <!-- highlight.js -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script> -->

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
