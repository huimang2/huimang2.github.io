<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- 웹 폰트 설정 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/css/custom.css" />
    

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- syntax.css -->
    <link rel="stylesheet" href="/assets/css/syntax.css">
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="프로그래밍 노트" />
    <link rel="shortcut icon" href="https://huimang2.github.io/assets/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://huimang2.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Rubisco's Programming Note" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="프로그래밍 노트" />
    <meta property="og:url" content="https://huimang2.github.io/search" />
    <meta property="og:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="프로그래밍 노트" />
    <meta name="twitter:url" content="https://huimang2.github.io/" />
    <meta name="twitter:image" content="https://huimang2.github.io/assets/images/M31_starspike.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Rubisco's Programming Note" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Rubisco's Programming Note",
        "logo": "https://huimang2.github.io/"
    },
    "url": "https://huimang2.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://huimang2.github.io/assets/images/M31_starspike.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://huimang2.github.io/search"
    },
    "description": "프로그래밍 노트"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


    <!-- MathJax -->
    

</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://huimang2.github.io/">Rubisco's Programming Note</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">JAVA</a></li>
    <li class="nav-typescript" role="menuitem"><a href="/tag/typescript/">Typescript</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">Python</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-python" role="menuitem"><a href="/archive.html">All Posts</a></li>
    <li class="nav-python" role="menuitem"><a href="/author_archive.html">Tag별 Posts</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "javascript-javascript": {
        "title": "자바스크립트 기초",
            "author": "rubisco",
            "category": "",
            "content": "자바스크립트란?자바스크립트(Javascript)는 프로토타입 기반의 스크립트 언어입니다. 오늘날 HTML, CSS와 함께 웹을 구성하는 요소 중 하나이며, 모든 웹 브라우저에는 자바스크립트 인터프리터가 내장되어 있습니다.자바스크립트는 1995년에 넷스케이프(Netscape)의 브랜든 아이크(Brendan Eich)가 10일만에 설계한 것으로 시작되었습니다. 처음에는 모카(Mocha)라는 이름으로 개발되었지만 4달 만에 라이브스크립트(LiveScript)로 개명한 후 다시 3달 후에 자바스크립트(JavaScript)로 이름을 변경하여 오늘날까지 이어지고 있습니다.ECMAScript자바스크립트가 개발된 이후 마이크로소프트(Microsoft)에서는 자바스크립트에 자사만의 문법을 넣어 JScript를 개발했습니다.넷스케이프의 자바스크립트와 마이크로소프트의 JScript는 서로 호환되지 못하는 경우가 있어서 크로스 브라우징 문제를 일으켰습니다.이 문제를 해결하기 위해 넷스케이프는 표준화를 위한 기술 규격을 비영리 표준화기구인 ECMA 인터네셔널에 제출하였고, ECMA-262라는 이름으로 1997년 표준화가 시작되었습니다.초기에는 마이크로소프트의 비협조적인 태도로 표준화에 실패했지만, 2차 브라우저 전쟁에서 구글의 Chrome에게 패배하고 2009년 ECMAScript 5가 제정되면서 표준 문제가 다소 해결되었습니다.오늘날 구글 크롬(Chrome)의 V8 엔진, 모질라 파이어폭스(Firefox)의 SpiderMonkey 엔진, 마이크로소프트 에지(Edge)의 Chakra 엔진 등은 ECMAScript 표준을 따르고 있습니다.ECMAScript 6ECMAScript 6은 ECMA-262 표준의 제 6판입니다. ES6, ES2015, ECMAScript 2015는 모두 ECMAScript 6를 뜻합니다.ES6에서는 다양한 문법들이 추가되었습니다.템플릿 리터럴ES6에서는 템플릿 리터럴을 통해 문자열 표현이 간단해졌습니다. 작은 따옴표(‘)나 큰 따옴표(“) 대신 백틱(`)을 통해 문자열을 감싸 표현할 수 있습니다. 이때 플레이스 홀더(${변수})를 통해 백틱 내부에 문자열과 변수를 함께 표현할 수 있습니다.ES5var nickName = \"루비스코\"console.log(\"닉네임은 \" + nickName + \"입니다.\");ES6var nickName = \"루비스코\"console.log(`닉네임은 ${nickName}입니다.`);화살표 함수ES6에서는 람다식이라 불리는 화살표 함수를 통해 함수 선언이 조금 더 간단해졌습니다.ES5의 경우 익명함수는 다음과 같이 선언합니다.ES5var plus = function(a, b) {  return a + b;}console.log(plus(1, 2));ES6에서는 다음과 같이 표현할 수 있습니다.ES6const plus = (a, b) =&gt; {  return a + b;}console.log(plus(1, 2));리턴문이 위와 같이 한줄이라면 블록과 retrun문을 생략하여 다음과 같이 나타낼 수 있습니다.ES6const plus = (a, b) =&gt; a + b;console.log(plus(1, 2));매개변수가 1개인 경우 괄호의 생략도 가능합니다.ES6const msg = text =&gt; `메시지: ${text}`;console.log(msg('메시지입니다.'));람다식을 통해 함수를 선언할 경우 블록 스코프가 무시되므로 this를 따로 변수에 담을 필요가 없습니다.ES5var car = {  model: 'k5',  price: 6000,  msg() {    var self = this;    var text = function() {      return self.model;    }    return `모델: ${text()}`;  }}console.log(car.msg());ES6var car = {  model: 'k5',  price: 6000,  msg() {    var text = () =&gt; this.model;    return `모델: ${text()}`;  }}console.log(car.msg());변수 선언ES5에서는 var를 통해 변수를 선언합니다. 반면 ES6에서는 let, const를 통해 변수를 선언할 수 있습니다.var는 변수의 중복선언과 재할당이 가능합니다.ES5var text = '루비스코';console.log(text); // 루비스코var text = '스팟';console.log(text); // 스팟let은 변수의 중복선언은 불가능하지만 재할당은 가능합니다.ES6let text = '루비스코';console.log(text); // 루비스코text = '스팟';console.log(text); // 스팟let text = '루비스코'; // Uncaught SyntaxError: Identifier 'text' has already been declaredconst는 변수의 중복선언 뿐만 아니라 재할당도 불가능합니다.ES6const text = '루비스코';console.log(text); // 루비스코text = '스팟'; // Uncaught SyntaxError: Identifier 'text' has already been declared",
        "url": "/javascript/javascript"
    }
    ,
    
    "vue-vue-router": {
        "title": "Vue.js: Vue Router",
            "author": "rubisco",
            "category": "",
            "content": "Vue Router란?Vue Router는 Vue.js를 통해 단일 페이지 어플리케이션(Single Page Application, SPA)을 구현할 때 사용하는 라이브러리입니다.라우팅(Routing)은 출발지에서 목적지까지의 경로를 결정하는 기능입니다. 웹어플리케이션에서 라우팅은 뷰(View)에서 다른 뷰로 이동하는 내비게이션을 관리하기 위한 기능을 의미합니다.SPA가 보편화 되기 전 전통적인 라우팅은 서버에서 처리했습니다. 클라이언트에서 URL을 통해 서버에 페이지를 요청(Request)하면 서버에서는 해당 HTML파일을 찾아 렌더링을 통해 HTML을 완성하여 클라이언트에게 응답(Response)을 보냅니다. 클라이언트의 역할은 서버에 요청을 보내는 것밖에 없으며 서버가 모든 라우팅에 대한 권한을 가지고 처리하기 때문에 서버 사이드 라우팅이라고 합니다.SPA의 경우 라우팅을 클라이언트에서 처리합니다. 클라이언트에서 서버에 페이지를 요청하면 서버에서는 단순히 하나의 HTML 파일을 응답으로 보냅니다. URL에 해당하는 내용은 클라이언트에서 AJAX를 통해 비동기 요청을 보내어 데이터를 응답받고 자바스크립트를 통해 페이지를 렌더링합니다. 클라이언트에서 라우팅에 대한 권한을 가지고 처리하기 때문에 클라이언트 사이드 라우팅이라고 합니다.즉, Vue Router는 Vue.js를 통해 클라이언트 사이드 라우팅을 돕는 라이브러리입니다.Vue Router 사용라우터 등록Vue Router를 사용하려면 Vuex처럼 Vue Router를 Vue에 추가해야합니다.Vue Router 사용 선언import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter)Vuex와 마찬가지로 CDN을 통해 Vue Router를 import하여 모듈방식으로 개발하는 경우 Vue Router를 로드하면 자동으로 Vue Router를 사용하도록 설정되기 때문에 생략가능합니다. Vue 2버전의 경우 Vue Router 3버전을 로드합니다.Vue Router의 사용을 선언하고 Vue 인스턴스의 옵션으로 router를 넣어주면 해당 컴포넌트에서 라우터를 사용할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport router from \"./router.js\";new Vue({  router,}).$mount('#app')router.jsexport default new VueRouter();라우트(Routes) 옵션라우터(Router) 인스턴스의 옵션에는 mode와 routes가 있습니다. 여기에서 routes 옵션에는 라우팅할 URL과 컴포넌트 등을 포함한 라우트(route) 객체 배열을 입력합니다.라우트 객체의 속성은 다음과 같습니다.라우트 객체의 속성            속성      내용                  path      라우트의 URL 경로              name      라우트 이름              component      라우트가 로드할 컴포넌트              components      라우트가 로드될 때 주입될 컴포넌트 목록              redirect      리다이렉트할 컴포넌트              alias      라우트 별칭              children      중첩된 라우트 목록              props      동적 세그먼트 변수를 컴포넌트의 props 속성으로 주입할 것인지에 대한 여부      path의 경우 필수 속성이며 나머지는 옵션에 해당합니다. 하지만 component나 components의 경우 입력되지 않으면 빈 화면이 로드되므로 거의 필수라고 보면 됩니다.Vue Router에서는 router-view 컴포넌트와 router-link 컴포넌트를 제공합니다. router-view 컴포넌트는 URL에 해당하는 컴포넌트를 렌더링하는 역할을 하며, router-link 컴포넌트는 라우팅을 요청하는 역할을 합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;nav&gt;      &lt;router-link to=\"/\"&gt;Main Page&lt;/router-link&gt; |      &lt;router-link to=\"/first\"&gt;First Page&lt;/router-link&gt; |      &lt;router-link to=\"/second\"&gt;Second Page&lt;/router-link&gt;    &lt;/nav&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;router-link 컴포넌트의 to 속성에는 라우트 경로를 입력하면 해당 라우트 경로를 가진 라우트에 매핑됩니다. 라우트를 설정하기 전에 매핑될 컴포넌트부터 작성하겠습니다.MainPage.jsexport default {  template: `&lt;div&gt;Main Page&lt;/div&gt;`}FirstPage.jsexport default {  template: `&lt;div&gt;First Page&lt;/div&gt;`}SecondPage.jsexport default {  template: `&lt;div&gt;Second Page&lt;/div&gt;`}이제 라우터에 라우트를 설정해줍니다.router.jsimport MainPage from \"./MainPage.js\";import FirstPage from \"./FirstPage.js\";import SecondPage from \"./SecondPage.js\";export default new VueRouter({  routes: [    { path: '/', component: MainPage },    { path: '/first', component: FirstPage },    { path: '/second', component: SecondPage }  ]});출력 결과네비게이션을 클릭함에 따라 URL이 변하는 것을 볼 수 있습니다. Vue Router에서 기본으로 사용하는 모드는 Hash 모드입니다. 아래에서 다시 설명할텐데 URL의 형식이 프로토콜://호스트:포트/#/경로입니다. 즉, 해시태그를 사용하여 페이지를 이동하지 않고 화면을 렌더링하여 마치 페이지를 이동한 것 같이 보이도록 합니다.라우터 인스턴스에 설정한 라우트를 보면 path와 component 속성이 존재합니다. 라우트는 router-link의 to 속성값에 해당하는 path와 매핑되고, 유저의 라우팅 요청시 해당 라우트의 컴포넌트가 router-view에 렌더링됩니다.동적 라우트 매칭동적 라우트란 경로에 변수를 가지고 있는 라우트를 의미합니다. 예를 들어 게시글 페이지의 경우 게시글 번호로 페이지를 매핑할 수 있습니다.예를 들어 스프링 프레임워크를 통해 웹어플리케이션을 만들때 컨트롤러에 @GetMapping('/board/{documentId}') 형식으로 어노테이션을 작성하여 게시글 페이지에 매핑하고, @PathVariable('documentId') Long documentId 형태로 documentId 파라미터를 주입받았습니다.이처럼 Vue에서도 파라미터를 통해 동적인 라우트 매핑이 가능한데, 이때 경로에 포함되어 있는 변수를 동적 세그먼트라고 합니다. 동적 세그먼트에는 어떤 값이 들어오는지 알 수 없으므로 라우트의 path 속성에 패턴을 정의해주어야 합니다.동적 세그먼트는 콜론(:)으로 시작하는 변수명으로 할당할 수 있으며, 컴포넌트 내에서 this.$route.params를 통해 접근할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;nav&gt;      &lt;router-link to=\"/board/1\"&gt;1&lt;/router-link&gt; |      &lt;router-link to=\"/board/2\"&gt;2&lt;/router-link&gt; |      &lt;router-link to=\"/board/3\"&gt;3&lt;/router-link&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;BoardDetail.jsexport default {  template: `&lt;div&gt;documentId: {{ $route.params.documentId }}&lt;/div&gt;`}router.jsimport BoardDetail from \"./BoardDetail.js\";export default new VueRouter({  routes: [    { path: '/board/:documentId', component: BoardDetail }  ]});출력 결과동적 라우트를 사용할 경우 동적 세그먼트가 변경되더라도 Vue Router는 이를 동일한 경로로 인식하여 컴포넌트를 다시 로드하지 않고 기존에 로드된 컴포넌트를 재사용합니다. 그러므로 Vue 인스턴스의 created나 mounted 훅을 통해 경로 변경을 감지할 수 없습니다.경로 변경을 감지하기 위해서는 watch 옵션을 통해 $route 객체를 감지하면 됩니다.BoardDetail.jsexport default {  template: `&lt;div&gt;documentId: {{ $route.params.documentId }}&lt;/div&gt;`,  watch: {    '$route' (to, from) {      console.log(\"old path: \", from.params.documentId);      console.log(\"new path: \", to.params.documentId);    }  }}출력 결과중첩된 라우트중첩된 라우트는 /user/profile, /user/boardDetail과 같이 URL의 세그먼트가 중첩된 라우트를 말합니다.중첩된 라우트중첩된 profile과 boardDetail 경로의 경우 user 라우트의 children 속성에 정의하면 됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;nav&gt;      &lt;router-link :to=\"/user/profile\"&gt;Profile&lt;/router-link&gt; |      &lt;router-link to=\"/user/boardDetail\"&gt;BoardDetail&lt;/router-link&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;User.jsexport default {  template: `    &lt;div&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  `}Profile.jsexport default {  template: `&lt;div&gt;닉네임 : Rubisco&lt;/div&gt;`}BoardDetail.jsexport default {  template: `&lt;div&gt;작성한 글 내용&lt;/div&gt;`}router.jsimport User from \"./User.js\";import Profile from \"./Profile.js\";import BoardDetail from \"./BoardDetail.js\";export default new VueRouter({  routes: [    {      path: '/user',      component: User,      children: [        { path: 'profile', component: Profile },        { path: 'boardDetail', component: BoardDetail }      ]     }  ]});출력 결과프로그래밍 방식 내비게이션Vue Router에서는 메소드를 통해 라우팅할 수 있도록 지원하고 있습니다. push, replace, go 메소드가 존재하며, 각각 history API의 pushState, replaceState, go 메소드와 상응합니다.매개변수로 location, onComplete, onAbort를 받습니다. location은 라우팅 경로, onComplete는 라우팅에 완료된 후에 호출될 함수, onAbort는 라우팅에 실패하면 호출될 함수입니다.push 메소드는 브라우저의 히스토리에 라우트 객체를 저장후 페이지를 이동하고, replace 메소드는 히스토리에 저장하지 않고 페이지를 이동합니다. 히스토리에 라우트 객체가 저장된다면 브라우저의 뒤로가기 버튼으로 이전 페이지로 이동이 가능합니다.BoardDetail.jsexport default {  template: `    &lt;button @click=\"goBack\"&gt;뒤로&lt;/button&gt;  `,  methods: {    goBack() {      this.$router.go(-1)    }  }}이름을 가지는 라우트동적 라우팅의 경우 라우트에 이름(name)을 설정하여 사용하는 것이 편리할 수도 있습니다. router-link 컴포넌트의 to props에 name을 전달하여 라우트를 링크할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;nav&gt;      &lt;router-link :to=\"{ name: 'profile' }\"&gt;Profile&lt;/router-link&gt; |      &lt;router-link :to=\"{ name: 'boardDetail' }\"&gt;BoardDetail&lt;/router-link&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;router.jsimport User from \"./User.js\";import Profile from \"./Profile.js\";import BoardDetail from \"./BoardDetail.js\";export default new VueRouter({  routes: [    {      path: '/user',      component: User,      children: [        { path: 'profile', name: 'profile', component: Profile },        { path: 'boardDetail', name: 'boardDetail', component: BoardDetail }      ]     }  ]});이름을 가지는 뷰때로는 여러 개의 뷰를 중첩하지 않고 동시에 표시하는 경우가 있습니다.여러 레이아웃을 가진 뷰이 경우 router-view 컴포넌트에 이름을 설정하여 각각의 컴포넌트를 바인딩할 수 있습니다.라우터 인스턴스에는 components 속성을 설정하는데, router-view의 이름을 key값으로 하고 바인딩할 컴포넌트를 value로 가지는 객체를 설정합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view name=\"header\"&gt;&lt;/router-view&gt;    &lt;router-view name=\"main\"&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;HeaderComponent.jsexport default {  template: `&lt;div&gt;Header&lt;/div&gt;`}MainComponent.jsexport default {  template: `&lt;div&gt;Main&lt;/div&gt;`}router.jsimport MainComponent from \"./MainComponent.js\";import HeaderComponent from \"./HeaderComponent.js\";export default new VueRouter({  routes: [    {      path: '/',      components: {        header: HeaderComponent,        main: MainComponent      }    }  ]});이름을 가지지 않은 router-view 컴포넌트는 기본적으로 default 라는 이름을 가집니다.리다이렉트와 별칭리다이렉트(redirect)는 사용자가 어떤 페이지에 접속하는 경우 자동으로 다른 페이지로 보내는 기능입니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;router.jsimport MainPage from \"./MainPage.js\";export default new VueRouter({  routes: [    { path: '/', redirect: '/main' },    { path: '/main', component: MainPage }  ]});이 경우 루트 페이지(/)에 접속하면 자동으로 /main 페이지로 리다이렉트 되어 MainPage 컴포넌트가 뷰에 바인딩됩니다.출력 결과별칭(alias)은 페이지의 이동없이 URL만 변경되는 기능입니다.router.jsimport MainPage from \"./MainPage.js\";export default new VueRouter({  routes: [    { path: '/main', alias: '/',  component: MainPage }  ]});이 경우 루트 페이지(/) 페이지에 접속하면 /main 페이지에 접속한 것처럼 MainPage 컴포넌트가 뷰에 바인딩됩니다.출력 결과라우트 컴포넌트에 속성 전달컴포넌트에서 $route를 사용하여 동적 세그먼트에 접근하는 경우 특정 URL에서만 사용할 수 있는 컴포넌트가 되어 버립니다. 즉, 컴포넌트가 라우트와 강하게 결합되어 있습니다. 이는 컴포넌트의 재사용성을 떨어트릴 수 있습니다.Vue Router는 라우트와의 결합도를 낮출 수 있도록 라우트의 동적 세그먼트를 컴포넌트의 props 속성으로 주입할 수 있는 기능을 제공합니다.라우트의 props를 true로 설정하는 경우 $route.params가 컴포넌트의 props로 설정됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue-router@3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;nav&gt;      &lt;router-link to=\"/board/1\"&gt;1&lt;/router-link&gt; |      &lt;router-link to=\"/board/2\"&gt;2&lt;/router-link&gt; |      &lt;router-link to=\"/board/3\"&gt;3&lt;/router-link&gt;    &lt;/nav&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;BoardDetail.jsexport default {  template: `&lt;div&gt;documentId: {{ documentId }}&lt;/div&gt;`,  props: {    documentId: {      type: String,      required: true    }  }}router.jsimport BoardDetail from \"./BoardDetail.js\";export default new VueRouter({  routes: [    { path: '/board/:documentId', component: BoardDetail, props: true }  ]});출력 결과props를 객체로 설정한다면 해당 각체의 속성이 컴포넌트의 props로 전달됩니다.함수로 설정할 수도 있는데, 이 경우 라우트를 매개변수로 받으며 props 객체를 반환해야 합니다.해시모드와 히스토리 모드Vue Router는 해시(hash, #) 모드와 히스토리(history) 모드 2가지를 지원합니다. 기본값은 해시 모드 입니다.해시 모드는 SPA가 개발되기 시작하면서 고안된 기법으로 해시태그를 사용하여 페이지를 이동하는 것처럼 보이지만 실제로는 페이지를 이동하지 않습니다. 이는 브라우저가 페이지 경로를 읽을 때 해시(#) 뒤쪽으로 오는 문자열은 경로로 인식하지 않는 성질을 이용한 것입니다.해시모드의 경우 호스트 주소와 경로 사이에 해시(#)를 붙여 URL을 나타냅니다.해시 모드  프로토콜://호스트주소:포트/#/경로히스토리 모드는 HTML5의 history API를 사용하는 방법입니다. history API는 pushState라는 메소드를 제공하는데, 이 메소드는 URL을 변경하고 브로우저의 히스토리를 남기지만 실제로는 페이지를 이동하지 않는 기능을 가집니다. 그러므로 pushState를 사용하여 URL을 변경하면 브라우저가 페이지 이동으로 인식하지 않습니다. 그러나 히스토리가 저장되기 때문에 사용자에게 실제 페이지를 이동한 것처럼 보이도록 합니다.히스토리 모드  프로토콜://호스트주소:포트/경로물론 Vue Router는 해시 모드든 히스토리 모드든 내부적으로는 history API를 사용하여 라우팅 하기 때문에 해시 모드 역시 히스토리를 저장합니다.다만 history API를 지원하지 않는 브라우저의 경우 해시 모드는 페이지가 이동하지 않지만 히스토리 모드는 페이지가 이동해버린다는 단점이 있습니다.",
        "url": "/vue/vue-router"
    }
    ,
    
    "vue-vuex": {
        "title": "Vue.js: Vuex",
            "author": "rubisco",
            "category": "",
            "content": "Vuex란?Vuex는 Vue로 작성된 어플리케이션의 상태를 통합적으로 관리할 수 있도록 도와주는 라이브러리입니다.어플리케이션의 규모가 커지면 컴포넌트가 많아지고, 각 컴포넌트의 상태는 분산됩니다. 컴포넌트가 많아질 수록 각각의 상태에 대한 상호작용이 어려워지는데, Vuex는 분산된 상태를 하나의 저장소에 모아 복잡한 상호작용을 단순화 할 수 있습니다.Flux 패턴Flux는 기존의 MVC 패턴의 문제점을 해결하기 위해 페이스북에서 고안한 아키텍처입니다.MVC 패턴의 컨트롤러(Controller)는 모델(Model)의 데이터를 조회하거나 업데이트하는 역할을 하며, 모델(Model)의 변화는 뷰(View)에 반영됩니다. 또한 사용자가 뷰(View)를 통해 데이터를 입력하면, 모델(Model)에 영향을 주면서 데이터를 관리합니다.MVC 패턴의 데이터 흐름MVC 패턴을 사용함으로써 개발자들은 조금 더 확장이 유연하고 유지 보수하기에 용이한 어플리케이션을 작성할 수 있습니다.그러나 MVC 패턴의 문제 중 하나는 하나의 컨트롤러가 여러 개의 모델이나 뷰를 컨트롤러를 제어할 수 있다는 점입니다. 페이스북과 같은 대규모 어플리케이션들이 등장하게 되면서 어플리케이션의 내부 구조가 복잡하게 되었습니다.MVC 패턴의 복잡성이를 해결하고자 페이스북 개발팀은 Flux 아키텍처를 개발했습니다. Flux 패턴의 경우 MVC 패턴과 달리 데이터 흐름이 양방향이 아닌 단방향으로 흐릅니다.Flux 패턴의 데이터 흐름Flux 패턴에서 데이터는 언제나 액션 -&gt; 디스패처 -&gt; 스토어 -&gt; 뷰의 순서로 흐르기 때문에 뷰에서 사용자 액션에 의하여 데이터가 업데이트 된다면 액션부터 다시 시작하여 디스패처를 통해 스토어에 있는 데이터를 업데이트한 후 뷰에 반영합니다.이러한 단방향 데이터의 흐름은 데이터의 상태를 예측하기 쉽게 만들어 디버깅을 용이하게 함으로써 유지보수를 용이하게 합니다.액션(Action)스토어(Store)를 변경하기 위해서는 디스패처(Dispatcher)를 통한 업데이트가 이루어져야 하는데, 이때 디스패처를 실행시키는 인수 객체가 액션(Action)입니다.액션은 타입(type)과 페이로드(payload)로 이루어진 단순한 객체입니다.액션(Action){  type: 'INCREASE_NUM',  payload: { num: 1 }}액션의 타입은 개발자가 직정 정의한 상수입니다. 이러한 액션은 액션 생성자(Action Creator)를 통해 생성됩니다.디스패처(Dispatcher)디스패처(Dispatcher)는 Flux의 모든 데이터 흐름을 관리하는 역할을 합니다. 액션에 대한 콜백 함수를 제공하며, 액션이 발생하면 디스패처의 콜백 함수를 통해 액션의 메시지를 전달받습니다.스토어(Store)스토어(Store)는 어플리케이션의 모든 상태와 로직을 담고 있으며, MVC 패턴의 모델(Model)과 같은 역할을 합니다.스토어의 상태를 변경하기 위해서는 반드시 액션을 생성한 후 디스패처를 통해 스토어 상태 변경을 요청해야 합니다.콜백 함수를 통해 스토어 상태가 변경되면 이벤트를 통해 뷰(View)에 새로운 상태를 전달하여 뷰가 스스로 업데이트 하도록 합니다.뷰(View)Flux 패턴의 뷰(View)는 MVC 패턴의 뷰와는 다르게 단순히 화면을 렌더링하는 것 이외에도 컨트롤러(Controller) 역할을 하기도 합니다.최상위 뷰는 스토어의 상태를 가져와 자식 뷰에 분배하는 역할을 하기 때문에 컨트롤러-뷰(Controller-View)라고도 부릅니다.자식 뷰는 직접 스토어의 데이터를 받아오는 대신 부모 뷰로부터 Props를 통해 데이터를 전달받습니다.VuexVuex는 Flux 아키텍처에 영감을 받아 제작된 상태관리 라이브러리입니다. 많은 부분에서 Flux 아키텍처의 메커니즘을 차용하고 있습니다.Vuex의 데이터 흐름Vue에서 Vuex를 사용하려면 Vue.use(Vuex)를 입력하여 Vuex의 사용을 선언해야합니다.Vuex 사용 선언import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)하지만 CDN을 통해 Vuex를 import하여 모듈방식으로 개발하는 경우 Vuex를 로드하면 자동으로 Vuex를 사용하도록 설정되기 때문에 생략가능합니다. Vue 2버전의 경우 Vuex 3버전을 로드합니다.Vuex의 사용을 선언하고 Vue 인스턴스의 옵션으로 store를 넣어주면 해당 컴포넌트에서 스토어를 사용할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vuex@3/dist/vuex.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport store from \"./store.js\";new Vue({  store,}).$mount('#app')store.jsexport default new Vuex.Store();이제 스토어의 옵션을 알아보겠습니다.상태(State)상태(State)는 어플리케이션에서 공통으로 관리할 상태, 즉 모델(Model)을 의미합니다. Vuex는 단일 상태 트리를 사용하며, 이 단일 객체는 원본 소스의 역할을 합니다. 이는 각 어플리케이션마다 하나의 저장소만 갖게 된다는 것을 의미합니다.컴포넌트에서 스토어의 접근은 $store 프로퍼티를 통해 접근할 수 있으며, 컴포넌트에서 스토어의 상태에 접근하려면 Vue 인스턴스의 computed를 통해 접근합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vuex@3/dist/vuex.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;{{ num }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport store from \"./store.js\";new Vue({  store,  computed: {    num() {      return this.$store.state.num;    }  }}).$mount('#app')store.jsexport default new Vuex.Store({  state: {    num: 0  }});출력 결과this.$store.state를 통해 상태에 접근하면 여러 상태에 접근할 경우 반복적이고 장황해질 수 있는데, 이때 Vuex에서 제공하는 mapState 헬퍼 함수를 사용하면 간결하게 접근할 수 있습니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapState(['num'])}).$mount('#app')헬퍼 함수 뿐만 아니라 다른 computed를 함께 사용하고 싶다면 객체 전개 연산자(Object Spread Operator)를 사용하면 됩니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: {    ...Vuex.mapState(['num'])  }}).$mount('#app')게터(Getters)게터(Getters)는 스토어 내에서 Vue의 computed와 같은 역할을 합니다. 컴포넌트에서 스토어 상태를 기반으로 상태를 계산하는 경우 다음과 같이 작성할 수 있습니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: {    double: {      return 2 * this.$store.state.num;    }  }}).$mount('#app')double 데이터는 스토어에 있는 num 데이터에 2를 곱한 값을 반환합니다. 간단한 식이기 때문에 문제없어 보이지만 만약 식이 복잡할 경우 해당 리턴값을 다른 컴포넌트에서 사용한다면 동일한 식을 중복해서 작성해야 합니다.게터를 사용한다면 중복된 식을 각각의 컴포넌트에 작성할 필요없이 스토어로부터 캐시된 데이터값을 가져올 수 있게 됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vuex@3/dist/vuex.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;{{ double }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport store from \"./store.js\";new Vue({  store,  computed: {    double() {      return this.$store.getters.double;    }  }}).$mount('#app')store.jsexport default new Vuex.Store({  state: {    num: 2  },  getters: {    double(state, _getters){      return 2 * state.num    }  }});출력 결과getters에 선언된 함수는 1번째 매개변수로 스토어의 상태를, 2번째 매개변수로 getters 속성 자체를 전달받습니다.상태와 마찬가지로 Vuex의 mapGetters 헬퍼 함수를 통해 간결한 접근을 할 수도 있습니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapGetters(['double'])}).$mount('#app')역시 헬퍼 함수 뿐만 아니라 다른 computed를 함께 사용하고 싶다면 객체 전개 연산자(Object Spread Operator)를 사용하면 됩니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: {    ...Vuex.mapGetters(['double'])  }}).$mount('#app')변이(Mutation)변이(Mutation)는 스토어 상태를 변경할 수 있는 유일한 방법입니다. 변이 함수의 이름은 액션의 타입과 동일하며, 스토어 상태를 변경하는 로직을 가집니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vuex@3/dist/vuex.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ num }}&lt;/div&gt;    &lt;button @click=\"increment\"&gt;증가&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapState(['num']),  methods: {    increment() {      this.$store.commit('INCREMENT', 10)    }  }}).$mount('#app')store.jsexport default new Vuex.Store({  state: {    num: 0  },  mutations: {    INCREMENT (state, payload) {      state.num += payload    }  }});출력 결과mutations에 선언된 함수는 1번째 매개변수로 스토어의 상태를, 2번째 매개변수로 payload를 전달받습니다.컴포넌트에서 변이에 접근하려면 this.$store.mutations와 같은 직접적인 접근은 불가하며, 스토어의 commit 메소드를 실행시켜야 합니다. 1번째 매개변수로 변이 함수 이름(액션 타입)을, 2번째 매개변수로 payload를 전달합니다.변이 역시 Vuex에서 mapMutations 헬퍼 함수를 제공하고 있으므로 다음과 같이 작성할 수 있습니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapState(['num']),  methods: {    ...Vuex.mapMutations(['INCREMENT']),    increment() {      this.INCREMENT(10)    }  }}).$mount('#app')액션(Actions)변이 안에서 중요한 사실은 반드시 동기적(Synchronized)이어야 한다는 것입니다. Vue의 공식 디버그 툴인 Vue Devtools는 UI를 통해 변이를 추적하여 스토어의 상태를 확인할 수 있는데, 이때 변이의 추적은 commit 메소드의 호출을 기준으로 합니다.만약 변이를 비동기(Asynchronized) 함수로 작성한다면 commit 시점과 콜백 시점이 다르기 때문에 어플리케이션의 상태 추적을 힘들게 만들 수 있습니다.아래와 같이 INCREMENT 변이 함수에 setTimeout을 통해 비동기적으로 상태를 변경시켜 보겠습니다.store.jsexport default new Vuex.Store({  state: {    num: 0  },  mutations: {    INCREMENT (state, payload) {      setTimeout(function() {        state.num += payload      }, 1000)    }  }});출력 결과를 확인하면 Vue Devtools에서 스토어 상태를 제대로 반영하지 못하는 것을 확인할 수 있습니다.출력 결과이를 해결하기 위한 기능이 액션(Actions)입니다.액션 함수를 비동기로 작성하여 콜백 함수에서 commit를 통해 변이 함수를 호출하여 스토어 상태를 변경할 수 있습니다.main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapState(['num']),  methods: {    increment() {      this.$store.dispatch('increment', 10)    }  }}).$mount('#app')store.jsexport default new Vuex.Store({  state: {    num: 0  },  mutations: {    INCREMENT (state, payload) {        state.num += payload    }  },  actions: {    increment (context, payload) {      setTimeout(function() {        context.commit('INCREMENT', payload)      }, 1000)    }  }});출력 결과actions에 선언된 함수는 1번째 매개변수로 스토어 context 자체를, 2번째 매개변수로 payload를 전달받습니다.컴포넌트에서 액션에 접근하려면 스토어의 dispatch 메소드를 실행시켜야 합니다. 1번째 매개변수로 액션 함수 이름을, 2번째 매개변수로 padyload를 전달합니다.변이 역시 Vuex에서 mapActions 헬퍼 함수를 제공하고 있으므로 다음과 같이 작성할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vuex@3/dist/vuex.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ num }}&lt;/div&gt;    &lt;button @click=\"incrementHandler\"&gt;증가&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport store from \"./store.js\";new Vue({  store,  computed: Vuex.mapState(['num']),  methods: {    ...Vuex.mapActions(['increment']),    incrementHandler() {      this.increment(10)    }  }}).$mount('#app')",
        "url": "/vue/vuex"
    }
    ,
    
    "etc-oh-my-zsh": {
        "title": "Oh My Zsh",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 우분투에 zsh Configuration 프레임워크인 Oh My Zsh를 설치해보도록 하겠습니다.커널(Kenel)과 쉘(Shell)oh my zsh를 설치하기 전에 커널(Kernel)과 쉘(Shell)이 무엇인지 알 필요가 있습니다.컴퓨터는 크게 물리적인 형태를 가지고 있는 하드웨어(HardWare)와 형태는 없지만 하드웨어를 동작시키는 소프트웨어(Software)로 구성되어 있습니다.소프트웨어는 운영체제(Operating System, OS)와 운영체제 위에서 동작하는 응용 소프웨어(Application Software)로 나눌 수 있습니다.운영체제는 하드웨어를 효율적으로 사용하기 위해 메모리나 CPU의 자원을 관리하고 여러 프로그램이 필요로 하는 공통적인 서비스를 제공하는 소프트웨어입니다. 리눅스(Linux), 윈도우(Windows), 맥OS(Mac OS)등이 운영체제에 해당합니다.운영체제는 커널(Kenel)과 시스템 소프트웨어(System Software)로 구분됩니다.커널은 운영체제의 핵심부로써, 하드웨어의 자원을 관리하는 역할을 수행합니다.커널의 경우 컴퓨터 자원만을 바라보고 있기 때문에 사용자 또는 응용 소프트웨어와 상호작용 않습니다. 그러므로 커널과 상호작용하기 위한 인터페이스가 필요한데, 이때 사용하는 시스템 소프트웨어가 쉘(Shell) 입니다.윈도우 운영체제에서는 명령 프롬프트(Command Prompt)가 쉘에 해당합니다.zsh와 Oh My Zsh리눅스는 표준 쉘로써 bash를 사용합니다. BASH는 Bourne-again shell의 약자로, 유닉스의 오리지날 쉘인 sh(Bourne Shell)을 기반으로 만들어졌습니다. 대표적인 리눅스 기반 GNU 운영체제인 우분투(Ubuntu) 역시 bash를 사용합니다.zsh는 bash, ksh, tcsh의 일부 기능을 포함하여 수많은 개선 사항이 갖추어진 확장형 sh입니다. Mac OS 10.15 버전인 카탈리나부터는 기본 쉘로 zsh를 사용합니다.zsh는 커스텀이 비교적 자유로우며, 각종 테마나 플러그인의 추가/삭제가 가능합니다. 또한 경로를 자동으로 추론하거나 타이핑 교정, 명령어 추천 등 많은 기능을 포함합니다.경로 자동추론/h/u/ws를 입력후 TAB키를 누르면 가장 비슷한 경로를 추론하여 자동완성됩니다.타이핑 교정commit를 cmmit로 잘못입력했다면 이를 교정하여 commit를 입력할 것을 추천합니다.명령어 추천git c를 입력후 TAB키를 누르면 c로 시작하는 명령어 옵션을 추천해줍니다.Oh My Zsh는 zsh의 이러한 환경설정을 다루기위한 프레임워크입니다. 프레임워크 없는 zsh는 빈 껍데기에 불과하다고 보면 됩니다.공식 홈페이지에 적힌 설명에 따르면 oh-my-zsh를 사용하면 카페에서 낮선 사람들이 다가와 \"대단해! 너 천재야?\"라고 묻는다고 합니다 :)본격적으로 맥의 감성을 우분투에 반영해보겟습니다.Oh My Zsh 설치zsh 설치우선 zsh를 설치해야합니다. apt를 통해 zsh를 설치해주도록 합시다.zsh 설치$ sudo apt install zshoh my zsh 설치다음으로 oh-my-zsh를 설치해주도록 합시다. curl이나 wget을 통해 sh 스크립트 파일을 다운받고 실행시키면 됩니다.curl을 통한 설치$ sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"wget을 통한 설치$ sh -c \"$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"설치가 완료되면 zsh를 기본 쉘로 변경할 것인지 묻는데, y를 입력하면 터미널이 실행될 때 기본쉘로 zsh를 사용합니다.테마 설정이제 테마를 설정하겠습니다. 테마는 .zshrc 파일에서 ZSH_THEME를 설정하여 변경할 수 있습니다.vi 또는 nano 에디터를 통해 해당 파일을 편집합니다..zshrc 파일 편집$ sudo nano ~/.zshrcZSH_THEME가 robbyrussell로 입력되어 있습니다. 이 부분에 사용하고 싶은 테마를 입력하면 됩니다.저는 국룰(?)인 agnoster 테마를 사용하도록 하겠습니다.CTRL + O를 눌러 저장하고 CTRL + X를 눌러 nano 에디터를 빠져나옵니다.설정된 테마를 적용하기 위해 .zshrc를 소싱합니다..zshrc 소싱$ source ~/.zshrc해당 테마를 사용할 경우 폰트가 깨지는 문제가 발생할 수 있으므로, 이를 해결하기 위해 powerline 폰트를 설치합니다.powerline 폰트 설치$ sudo apt install fonts-powerline다른 테마는 아래 페이지에서 확인이 가능합니다.  https://github.com/ohmyzsh/ohmyzsh/wiki/Themes플러그인 설치syntax hightlightsyntax hightlight는 말그대로 구문을 강조하는 플러그인 입니다.  GITHUB: https://github.com/zsh-users/zsh-syntax-highlightingbash의 경우 명령어와 옵션을 구분하지 않고 모두 흰색으로 입력됩니다.bash의 경우zsh에 해당 플러그인을 설치한다면 구문이 강조되어 사용할 수 있는 명령어는 녹색으로, 사용할 수 없는 명령어는 빨간색으로, 옵션은 흰색으로 입력됩니다.사용할 수 있는 명령어의 경우사용할 수 없는 명령어의 경우oh-my-zsh에서 플러그인을 사용하기 위해서는 ~/.oh-my-zsh/custom/plugins 폴더에 플러그인을 다운받고 .zshrc 파일에서 plugins를 설정하면 됩니다.우선 git를 통해 플러그인을 다운로드 받겠습니다. (git가 설치되어 있음을 전제로 합니다.)syntax hightlight 플러그인 다운로드$ git clone https://github.com/zsh-users/zsh-syntax-hightlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightingvi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다..zshrc 파일 편집$ sudo nano ~/.zshrc처음에 plgins에 (git)가 설정되어 있습니다. 여기에 구분자를 스페이스로 하여 zsh-syntax-hightlight를 추가해주도록 합시다.CTRL + O를 눌러 저장하고 CTRL + X를 눌러 nano 에디터를 빠져나옵니다..zshrc를 소싱하면 플러그인이 바로 적용됩니다..zshrc 소싱$ source ~/.zshrcautosuggestionsautosuggestions는 히스토리 기반으로 최근에 입력한 명령어를 미리보기 형태로 보여주는 플러그인 입니다.  GITHUB: https://github.com/zsh-users/zsh-autosuggestionsautosuggestions 플러그인 적용플러그인을 적용하기 위해서는 syntax highlighte 플러그인을 적용한 방식 그대로 설정하면 됩니다.autosuggestions 플러그인 다운로드$ git clone https://github.com/zsh-users/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestionsvi 또는 nano 에디터를 통해 .zshrc 파일을 편집합니다..zshrc 파일 편집.zshrc를 소싱하면 플러그인이 바로 적용됩니다..zshrc 소싱$ source ~/.zshrc",
        "url": "/etc/oh-my-zsh"
    }
    ,
    
    "vue-vue-lifecycle": {
        "title": "Vue.js: lifecycle",
            "author": "rubisco",
            "category": "",
            "content": "라이프사이클(Lifecycle)Vue 인스턴스의 라이프사이클은 다음과 같습니다.크게 생성(Creation), 마운트(Mounting), 업데이트(Updating), 소멸(Destruction) 4가지 단계를 거치게 되며, Vue 인스턴스는 각각의 단계에서 훅(Hook)을 위한 API를 제공하고 있습니다.생성(Creation) 단계Vue 인스턴스가 생성될 때 제일 먼저 실행되는 단계입니다. 컴포넌트가 DOM에 바인딩 되기 전에 수행하며, 서버 렌더링 중에도 실행됩니다.아직 컴포넌트가 DOM에 바인딩 되지 않았기 때문에 $el 프로퍼티를 통해 DOM에 접근하거나 참조할 수 없습니다.beforeCreate제일 먼저 실행되는 훅으로 Vue 인스턴스가 초기화 된 직후 실행됩니다. DOM에 접근할 수 없을 뿐만 아니라 데이터나 이벤트가 활성화되지 않아 접근할 수 없습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsnew Vue({  data() {    return {      msg: 'hello, world!'    }  },  beforeCreate() {    console.log('beforeCredate Hook');    console.log('msg: ' + this.msg);  }}).$mount('#app')해당 코드를 작성후 콘솔창을 확인하면 msg 데이터가 undefined로 출력됩니다.출력 결과createdVue 인스턴스가 DOM에 바인딩되거나 View가 렌더링 되기 전에 실행되는 훅입니다. 데이터와 이벤트가 활성화되었기 때문에 해당 인스턴스의 프로퍼티를 통해 data에 접근할 수 있습니다.main.jsnew Vue({  data() {    return {      msg: 'hello, world!'    }  },  created() {    console.log('created Hook');    console.log('msg: ' + this.msg);    console.log('$el: ' + this.$el);  }}).$mount('#app')해당 코드를 작성후 콘솔창을 확인하면 데이터 모델에는 접근할수 있지만 DOM에는 접근할 수 없습니다.출력 결과데이터를 설정하거나 이벤트 리스너를 선언해야 한다면 이 단계에서 하는 것이 적절합니다.마운트(Mounting) 단계Vue 인스턴스가 DOM에 바인딩되는 단계입니다. 훅이 가장 많이 사용되는 단계이며, View의 렌더링 전후로 컴포넌트에 접근할 수 있습니다.생성 단계와 달리 서버 렌더링 중에는 훅이 실행되지 않습니다.beforeMount템플릿이 컴파일되고 View가 렌더링 되기 전에 실행되는 훅입니다. 템플릿이 컴파일되어 가상 DOM은 생성되었지만 실제 DOM에는 바인딩 되지 않은 상태입니다.mountedView가 렌더링되고 Vue 인스턴스가 DOM에 바인딩 된 이후 실행되는 훅입니다.일반적으로 부모와 자식 컴포넌트 사이에 훅의 실행순서는 다음과 같습니다.부모 / 자식 컴포넌트 사이의 훅 실행순서부모 컴포넌트의 템플릿이 렌더링된 이후 실제 DOM에 바인딩 하기 전에 자식 컴포넌트가 생성됩니다. 즉, 부모 컴포넌트의 beforeMounte -&gt; 자식 컴포넌트의 beforeMounte -&gt; 자식 컴포넌트의 mounted -&gt; 부모 컴포넌트의 mounted 순서로 훅이 실행됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;child-component /&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport ChildComponent from \"./ChildComponent.js\";new Vue({  components: { ChildComponent },  beforeMount() {    console.log('parent component beforeMount hook');  },  mounted() {    console.log('parent component mounted hook');  }}).$mount('#app')ChildComponent.jsexport default {  template: `&lt;div&gt;child component&lt;/div&gt;`,  beforeMount() {    console.log('child component beforeMount hook')  },  mounted() {    console.log('child component mounted hook');  }}출력 결과업데이트(Undating) 단계DOM이 리렌더링되는 단계입니다. Vue 인스턴스의 데이터 모델이 변경되거나 View가 리렌더링 될 때 훅이 실행됩니다.디버깅이나 프로파일링시 리렌더링 시기를 확인할 경우 사용하며, Vue 인스턴스의 데이터 변경을 확인할 때는 보통 computed나 watch 옵션을 사용합니다.beforeUpdate컴포넌트의 데이터가 변경되어 가상 DOM이 패치되고 View가 렌더링 되기전에 실행되는 훅입니다.컴포넌트가 리렌더링 되기 전에 반응형 데이터의 신규 상태를 확인할 경우 사용합니다.updatedView가 렌더링된 이후 실행되는 훅입니다.mounted와 마찬가지로 부모 컴포넌트의 beforeUpdate -&gt; 자식 컴포넌트의 beforeUpdate -&gt; 자식 컴포넌트의 updated -&gt; 부모 컴포넌트의 updated 순서로 훅이 실행됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;child-component :num=\"num\" @click=\"num++\" /&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport ChildComponent from \"./ChildComponent.js\";new Vue({  components: { ChildComponent },  data() {    return {      num: 0    }  },  beforeUpdate() {    console.log('parent component beforeUpdate hook');  },  updated() {    console.log('parent component updated hook');  }}).$mount('#app')ChildComponent.jsexport default {  template: `    &lt;div&gt;      &lt;button @click=\"$emit('click')\"&gt;클릭&lt;/button&gt;      &lt;span&gt;{{ num }}&lt;/span&gt;    &lt;/div&gt;  `,  props: ['num'],  beforeUpdate() {    console.log('child component beforeUpdate hook')  },  updated() {    console.log('child component updated hook');  }}자식 컴포넌트의 버튼을 클릭하면 부모 컴포넌트로 이벤트가 전달되고, 해당 이벤트는 num 데이터를 1 증가시킵니다. 자식 컴포넌트는 num 데이터를 props로 전달받아 템플릿에 바인딩합니다.클릭 버튼을 누르면 다음과 같은 순서로 훅이 실행되는 것을 확인할 수 있습니다.출력 결과소멸(Destruction) 단계Vue 인스턴스가 DOM에서 해제되는 단계입니다. DOM으로부터 이벤트 리스너 또는 구독 상태를 제거하기위해 사용합니다.beforeDestroyVue 인스턴스가 DOM으로부터 바인딩이 해제되기 직전에 실행되는 훅입니다. Vue 인스턴스가 동작하고 있기 때문에 모든 속성에 접근할 수 있습니다.destroyedVue 인스턴스의 바인딩이 해제된 직후에 실행되는 훅입니다. 바인딩이 해제되었기 때문에 해당 인스턴스 속성으로 접근할 수 없습니다. 또한 하위 Vue 인스턴스 역시 해제됩니다.",
        "url": "/vue/vue-lifecycle"
    }
    ,
    
    "vue-vue-component": {
        "title": "Vue.js: component",
            "author": "rubisco",
            "category": "",
            "content": "컴포넌트(Components)컴포넌트(components)는 Vue의 매우 중요한 요소 중 하나로, 하나의 어플리케이션을 작은 요소로 분해하여 은닉성과 재사용성을 가지게 해줍니다. 컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 빠르게 게발할 수 있습니다.컴포넌트 구성전역 컴포넌트(Global Components)전역 컴포넌트는 여러 Vue 인스턴스에서 공통으로 사용할 수 있는 컴포넌트 입니다.전역 컴포넌트를 등록하기 위해서는 Vue 라이브러리의 component 함수를 호출하며, 매개변수로는 컴포넌트 이름과 Vue 인스턴스의 옵션을 넣어줍니다.template 옵션을 통해 템플릿을 설정할 수 있으며, data 옵션의 경우 Object 타입으로 설정하면 해당 컴포넌트를 사용하는 모든 인스턴스에서 동일한 데이터를 공유하게 되므로 함수 형태로 설정하여 데이터를 독립적으로 사용하도록 합니다.컴포넌트 등록Vue.component('global-component', {  template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,  data() {    return {      message: '전역 컴포넌트'    }  }})컴포넌트 이름은 위의 코드와 같이 케밥 케이스(kebab case)로 설정하며, 2단어 이상으로 구성되도록 합니다. Vue 인스턴스에 컴포넌트 이름의 태그를 넣어주면 컴포넌트가 출력됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsVue.component('global-component', {  template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,  data() {    return {      message: '전역 컴포넌트'    }  }})new Vue().$mount('#app')출력 결과컴포넌트는 다음과 같이 재사용이 가능합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;출력 결과전역 컴포넌트 이므로 모든 Vue 인스턴스에서 사용가능합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app1\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div id=\"app2\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsVue.component('global-component', {  template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,  data() {    return {      message: '전역 컴포넌트'    }  }})new Vue().$mount('#app1')new Vue().$mount('#app2')출력 결과컴포넌트의 이름은 케밥 케이스로 작성하지만 다음과 같이 파스칼 케이스(pascal case) 또는 카멜 케이스(camel case)로 작성해도 자동으로 케밥 케이스로 변경되어 컴파일됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsVue.component('GlobalComponent', {  template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,  data() {    return {      message: '전역 컴포넌트'    }  }})new Vue().$mount('#app')출력 결과지역 컴포넌트(Local Components)지역 컴포넌트는 Vue 인스턴스의 components 옵션에 등록하며, 해당 컴포넌트가 등록된 인스턴스에서만 사용가능합니다. 컴포넌트 이름과 옵션을 key-value 쌍으로 입력하여 등록합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsnew Vue({  components: {    'global-component': {      template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,      data() {        return {          message: '지역 컴포넌트'        }      }    }  }}).$mount('#app')출력 결과전역 컴포넌트처럼 키값을 파스칼 케이스 또는 카멜 케이스로 선언해도 됩니다.main.jsnew Vue({  components: {    GlobalComponent: {      template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,      data() {        return {          message: '지역 컴포넌트'        }      }    }  }}).$mount('#app')재사용성을 위해 컴포넌트 옵션을 변수로 선언할 수 있으며, Object를 참조하는 변수는 키값이 될 수 있으므로 다음과 같이 작성할 수 있습니다.main.jsconst GlobalComponent = {  template: `&lt;template&gt;{{ message }}&lt;/template&gt;`,  data() {    return {      message: '지역 컴포넌트'    }  }}new Vue({  components: { GlobalComponent }}).$mount('#app')컴포넌트를 모듈 형태로 작성하여 import 한다면 유지보수가 쉬워집니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport GlobalComponent from \"./GlobalComponent.js\"new Vue({  components: { GlobalComponent }}).$mount('#app')GlobalComponent.jsexport default {  template: `&lt;div&gt;{{ message }}&lt;/div&gt;`,  data() {    return {      message: '지역 컴포넌트'    }  }}컴포넌트간 통신컴포넌트간 데이터의 전달은 단방향으로만 이동할 수 있습니다.컴포넌트 사이의 데이터 전달부모 컴포넌트에서 자식 컴포넌트로는 props를 통해 데이터를 전달하며, 자식 컴포넌트에서 부모 컴포넌트로는 event를 통해 데이터를 전달할 수 있습니다.props를 통한 데이터 전달부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하기 위해서는 자식 컴포넌트에 props 옵션을 등록합니다. 부모 컴포넌트에서는 속성(attribute)을 통해 props를 전달할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component title=\"타이틀1\" /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport GlobalComponent from \"./GlobalComponent.js\"new Vue({  components: { GlobalComponent }}).$mount('#app')GlobalComponent.jsexport default {  template: `&lt;div&gt;{{ title }}&lt;/div&gt;`,  props: ['title']}출력 결과v-bind 디렉티브를 통한 props 전달도 가능합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;global-component :title=\"message\" /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport GlobalComponent from \"./GlobalComponent.js\"new Vue({  components: { GlobalComponent },  data: {    message: '데이터 전달'  }}).$mount('#app')GlobalComponent.jsexport default {  template: `&lt;div&gt;{{ title }}&lt;/div&gt;`,  props: ['title']}출력 결과이벤트를 통한 데이터 전달자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하기 위해서는 부모 컴포넌트에서 v-on 디렉티브로 이벤트를 등록합니다. 자식 컴포넌트에서는 $emit 메소드를 통해 이벤트를 호출할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;custom-button @print=\"printText\" /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport CustomButton from \"./CustomButton.js\"new Vue({  components: { CustomButton },  methods: {    printText() {      console.log('Print Text!!')    }  }}).$mount('#app')CustomButton.jsexport default {  template: `&lt;button @click=\"clickBtn\"&gt;버튼클릭&lt;/button&gt;`,  methods: {    clickBtn() {      this.$emit('print')    }  }}부모 컴포넌트에서 자식 태그에 print 이벤트를 등록하고, 해당 이벤트가 호출되면 printText 메소드를 호출합니다. 자식 컴포넌트에서는 클릭시 clickBtn 메소드를 호출하고, 해당 메소드에서는 print 이벤트를 호출하여 콘솔 로그가 출력됩니다.출력 결과$emit 메소드의 2번째 파라미터에 전달할 데이터를 줄수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;custom-button @print=\"printText\" /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport CustomButton from \"./CustomButton.js\"new Vue({  components: { CustomButton },  methods: {    printText(msg) {      console.log(msg)    }  }}).$mount('#app')CustomButton.jsexport default {  template: `&lt;button @click=\"clickBtn\"&gt;버튼클릭&lt;/button&gt;`,  methods: {    clickBtn() {      this.$emit('print', '메시지 전달')    }  }}출력 결과컴포넌트 사이의 데이터 전달컴포넌트 사이에서는 이벤트버스를 통해 데이터를 서로 교환할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;&lt;custom-button @print=\"printText\" /&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsimport CustomButton from \"./CustomButton.js\"import EventBus from \"./EventBus.js\"new Vue({  components: { CustomButton },  methods: {    printText(msg) {      console.log(msg)    }  },  created() {    EventBus.$on('print', this.printText)  }}).$mount('#app')EventBus.jsexport default new Vue();CustomButton.jsimport EventBus from \"./EventBus.js\"export default {  template: `&lt;button @click=\"clickBtn\"&gt;버튼클릭&lt;/button&gt;`,  methods: {    clickBtn() {      EventBus.$emit('print', '이벤트 버스로 데이터 전달')    }  }}이벤트를 주고 받기위한 EventBus라는 Vue 인스턴스를 하나 생성합니다. 해당 인스턴스에서 $on 메소드를 통해 이벤트를 등록할 수 있고, $emit 메소드를 통해 이벤트를 호출할 수 있습니다.app 컴포넌트가 생성될 때 EventBus에 print 이벤트를 등록하고, custom-button 컴포넌트를 클릭하면 EventBus에서 print 이벤트를 호출합니다.출력 결과",
        "url": "/vue/vue-component"
    }
    ,
    
    "vue-vue-option": {
        "title": "Vue.js: option",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 Vue 인스턴스의 옵션에 대해 알아보겠습니다.elel 옵션은 Vue 인스턴스를 DOM에 바인딩 하기위한 옵션입니다. css 선택자를 통해 el 옵션의 값을 설정해주면 해당 선택자에 대한 DOM에 Vue 인스턴스가 바인딩됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  el: '#app'})index.html 파일을 열고 콘솔창에 mv를 입력하면 Vue 인스턴스가 생성되어 있습니다.해당 Vue 인스턴스는 id가 app인 div DOM에 바인딩되어 있으며, $el 프로퍼티를 통해 확인가능합니다.datadata 옵션은 Vue 인스턴스가 관리할 데이터를 정의합니다. 해당 옵션에 정의된 데이터는 Model에 해당하며, Vue 인스턴스는 모델 데이터의 변경을 감지하여 View를 업데이트하게 됩니다.앞서 설명했듯이 data는 Object 또는 Object를 리턴하는 함수 형태로 정의할 수 있습니다.main.js (Object로 정의)const mv = new Vue({  data: {    message: 'Hello, world!'  }}).$mount('#app')main.js (Function으로 정의)const mv = new Vue({  data() {    return {      message: 'Hello, world!'    }  }}).$mount('#app')data 옵션에 정의된 모델은 Vue 인스턴스의 $data 프로퍼티를 통해 접근할 수 있으며, Vue 인스턴스가 모델의 프록시가 되어 모델 속성의 이름으로 Vue 인스턴스를 통해서도 접근할 수도 있습니다.Vue 인스턴스는 모델을 프록시하여 모델 속성값을 통해 $data 프로퍼티와 같은 데이터를 참조methodsmethods 옵션은 Vue 인스턴스 내부에서 사용하기위한 메소드를 정의합니다. 저번 글에서 v-on 디렉티브를 통해 클릭 이벤트에 메소드를 바인딩했습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ num }}&lt;/div&gt;    &lt;button v-on:click=\"increase\"&gt;증가&lt;/button&gt;    &lt;button v-on:click=\"decrease\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    num: 0  },  methods: {    increase() {      this.num++    },    decrease() {      this.num--    }  }}).$mount('#app')출력 결과data 옵션과 마찬가지로 Vue 인스턴스는 해당 옵션에 정의된 메소드를 프록시하고 있어서 Vue 인스턴스의 프로퍼티를 통해 메소드의 호출이 가능합니다.Vue 인스턴스를 통한 메소드 호출즉, method 옵션에 선언된 메소드 또한 Vue 인스턴스가 관리하기 때문에 DOM에 바인딩할 수 있습니다. 만약 메소드 내부에서 사용하는 변수가 변경되어 View가 업데이트 된다면, 바인딩된 메소드는 자동으로 호출됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ calcNum() }}&lt;/div&gt;    &lt;button @click=\"num++\"&gt;증가&lt;/button&gt;    &lt;button @click=\"num--\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    num: 0  },  methods: {    calcNum() {      console.log(\"num: \" + this.num)      return this.num    }  }}).$mount('#app')위의 코드와 다르게 메소드를 2개로 정의한 것이 아니라 클릭 이벤트에 의하여 num 데이터를 증가시키거나 감소시키며, calcNum 메소드의 리턴값을 바인딩했습니다.num 데이터가 변경되면 바인딩된 calcNum 메소드가 호출되어 View가 업데이트 됩니다.출력 결과calcNum 메소드가 호출되면 콘솔 로그가 출력되는데, 이벤트를 통해 num 데이터 값을 변경시킬 때마다 calcNum 메소드가 호출되는 것을 확인할 수 있습니다.computedcomputed 옵션은 methods 옵션과 동일한 기능을 하지만 차이점이 있습니다.우선 메소드의 바인딩 방식에 차이가 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ calcNum }}&lt;/div&gt;    &lt;button @click=\"num++\"&gt;증가&lt;/button&gt;    &lt;button @click=\"num--\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    num: 0  },  computed: {    calcNum() {      console.log(\"num: \" + this.num)      return this.num    }  }}).$mount('#app')methods의 경우 명령형의 관점으로 calcNum()을 바인딩한 반면, computed는 선언형 관점으로 메소드 이름인 calcNum만 바인딩합니다. 결과를 확인하면 methods와 동일하게 calcNum 메소드가 호출됩니다.출력 결과동작 방식에도 차이점이 존재합니다. methods는 View가 업데이트될 때마다 호출되는 반면, computed는 리턴값이 캐싱되어 내부 로직에 변화가 있을때만 호출됩니다.예를 들어 calcNum 메소드가 2 * this.num이라는 값을 리턴한다면 methods는 View가 업데이트 될 때마다 calcNum이 호출되어 2 * this.num을 연산한 후 View에 출력될 것입니다.반면에 computed는 num 데이터에 변경이 있어야만 calcNum이 호출되고 리턴값은 캐싱되어 num 데이터에 변경이 없다면 View가 업데이트 되어도 calcNum이 호출되지 않고 캐싱된 값이 View에 출력됩니다.우선 아래와 같이 코드를 작성합시다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;      &lt;div&gt;{{ calcMethodsNum() }}&lt;/div&gt;      &lt;button @click=\"methodsNum++\"&gt;증가&lt;/button&gt;      &lt;button @click=\"methodsNum--\"&gt;감소&lt;/button&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div&gt;      &lt;div&gt;{{ calcComputedNum }}&lt;/div&gt;      &lt;button @click=\"computedNum++\"&gt;증가&lt;/button&gt;      &lt;button @click=\"computedNum--\"&gt;감소&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    computedNum: 0,    methodsNum: 0  },  methods: {    calcMethodsNum() {      console.log(\"methodsNum: \" + this.methodsNum)      return this.methodsNum    }  },  computed: {    calcComputedNum() {      console.log(\"computedNum: \" + this.computedNum)      return this.computedNum    }  }}).$mount('#app')우선 methodsNum을 변경시켜봅니다. 아래 결과를 보면 methodsNum에 대한 로그가 출력되므로, calcMethodsNum이 호출된다는 것을 확인할 수 있습니다.출력 결과다음으로 computedNum을 변경시켜봅시다. 아래 결과를 보면 computedNum에 대한 로그 뿐만 아니라 methodsNum에 대한 로그도 함께 출력됩니다. 즉, calcComputedNum이 호출될 뿐만 아니라 calcMethodsNum도 호출됩니다.출력 결과이것은 methodsNum에 변경이 없더라도 computedNum의 변경에 의해 View가 업데이트 되기 때문입니다.이러한 동작방식의 차이로 인해 메소드를 바인딩해야 한다면 methods 보다는 computed로 메소드를 선언하여 바인딩 하는 것이 성능이 좋습니다.computed를 통해 getter와 setter를 따로 선언할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ calcNum }}&lt;/div&gt;    &lt;button @click=\"num++\"&gt;증가&lt;/button&gt;    &lt;button @click=\"num--\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    num: 0  },  computed: {    calcNum: {      set(num) {        this.num = num;      },      get() {        return 2 * this.num;      }    }  }}).$mount('#app')computed에 calcNum의 getter와 setter를 따로 선언했습니다. getter의 경우 num 데이터에 2를 곱한 값을 리턴하며, setter의 경우 num 데이터를 파라미터 num값으로 변경합니다.출력 결과View에 바인딩할 경우 getter를 통해 calcNum에 캐싱된 값을 반환하고, setter를 통해 calcNum을 설정하면 num 데이터가 설정값으로 변경되어 calNum의 getter를 호출하고 View를 업데이트합니다.computred 속성을 getter와 setter로 나눌 경우 아직 설명하지 않은 v-model 디렉티브를 설정할 때 유용한데, 다음에 확인해보도록 하겠습니다.watchwatch 옵션은 Vue 인스턴스의 프로퍼티 변화를 감지하여 특정 콜백 함수를 호출합니다. 해당 콜백 함수는 파라미터로 변경후 값(newVal)과 변경전 값(oldVal)을 받습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    message: 0  },  watch: {    message: function(newVal, oldVal) {      console.log(\"newVal: \" + newVal, \"oldVal: \" + oldVal)    }  }}).$mount('#app')출력 결과methods나 computed를 통해서도 데이터 변경을 감지할 수 있지만 데이터 타입이 Object인 경우 그 속성의 변화까지는 감지하지 못합니다. watch의 경우 deep옵션을 통해 Object 속성의 변화까지 감지할 수 있습니다.main.jsconst mv = new Vue({  data: {    obj: { a: 'aaa' }  },  watch: {    obj: {      handler(newObj) {        console.log(\"변경값: \" + newObj.a)      },      deep: true    }  }}).$mount('#app')출력 결과",
        "url": "/vue/vue-option"
    }
    ,
    
    "vue-vue-default-directive-2": {
        "title": "Vue.js: directive (2)",
            "author": "rubisco",
            "category": "",
            "content": "v-prev-pre 디렉티브를 선언하면 해당 태그는 컴파일되지 않고 그대로 출력됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-pre&gt;{{ message }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    message: 'hello, world!'  }}).$mount('#app')출력 결과v-pre 디렉티브가 없다면 텍스트 보간에 의하여 hello, world!가 출력되어야 하지만, 출력 결과를 확인하면 컴파일 되지않고 {{ message }}가 텍스트 그대로 출력됩니다.v-oncev-once 디렉티브는 일회성 디렉티브 입니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-once&gt;{{ message }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    message: 'hello, world!'  }}).$mount('#app')출력 결과를 확인하면 아래와 같이 텍스트 보간에 의하여 hello, world!라는 텍스트가 출력됩니다.출력 결과message를 변경하면 바인딩된 텍스트 메시지도 변경되어야 하지만, v-once 디렉티브의 경우 처음 컴파일된 메시지 상태가 그대로 남습니다.출력 결과v-cloakv-cloak 디렉티브는 컴파일 되기전 Mustache 태그를 감추기 위해 사용됩니다.아래와 같이 setTimeout 메소드를 통해 3초후 vue 객체를 생성하고 텍스트 보간을 하겠습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;{{ message }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jssetTimeout(() =&gt; {  new Vue({    data: {      message: 'hello, world!'    }  }).$mount('#app')}, 3000)아래와 같이 출력 결과를 확인하면 vue 객체가 생성되어 컴파일 되기 전까지 Mustache 태그가 그대로 표시됩니다.출력 결과v-cloak 디렉티브는 vue 객체가 컴파일 된 이후 자동으로 제거되기 때문에 v-cloak 속성을 선택자로 하여 display: none; 스타일 속성을 추가하면 됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;style&gt;    [v-cloak] { display: none; }  &lt;/style&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-cloak&gt;{{ message }}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;출력 결과v-showv-show 디렉티브는 v-if 디렉티브와 유사하게 조건문에 대하여 DOM 렌더링 여부를 결정합니다.하지만 태그 자체를 생성하거나 제거하는 v-if와 달리 v-show는 display 스타일 속성을 통해 렌더링을 결정합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;span v-show=\"isNotice\"&gt;{{ notice }}&lt;/span&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    notice: 'notice',    isNotice: true  }}).$mount('#app')isNotice를 false로 변경하면 태그 자체가 사라지는 것이 아니라 display: none; 스타일 속성이 추가되는 것을 확인할 수 있습니다.출력 결과태그 자체를 추가하거나 제거하는 것이 아니기 때문에 조건이 자주 변경된다면 v-if 디렉티브보다 v-show 디렉티브를 사용하는 것이 효율적입니다.v-onv-on 디렉티브는 이벤트를 연결합니다. 아직 컴포넌트에 대해서 설명하지 않았지만 하위 컴포넌트에서 상위 컴포넌트로의 데이터 전달은 이벤트를 통해 가능합니다.이벤트는 v-on:[이벤트 이름]=\"메소드명\" 형태로 연결합니다. 클릭이벤트를 연결해보겠습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ num }}&lt;/div&gt;    &lt;button v-on:click=\"increase\"&gt;증가&lt;/button&gt;    &lt;button v-on:click=\"decrease\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    num: 0  },  methods: {    increase() {      this.num++    },    decrease() {      this.num--    }  }}).$mount('#app')각각의 버튼에 대한 클릭 이벤트에 num 데이터를 1 증가시키는 메소드와 1 감소시키는 메소드를 연결했습니다.출력 결과v-on 디렉티브는 v-bind 디렉티브를 : 기호를 통해 선언하는 것처럼 @ 기호를 통해 선언할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ num }}&lt;/div&gt;    &lt;button @click=\"increase\"&gt;증가&lt;/button&gt;    &lt;button @click=\"decrease\"&gt;감소&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;",
        "url": "/vue/vue-default-directive-2"
    }
    ,
    
    "vue-vue-default-directive-1": {
        "title": "Vue.js: directive (1)",
            "author": "rubisco",
            "category": "",
            "content": "디렉티브(Derectives)디렉티브(Directives)는 번역하자면 지시문이라고 할 수 있습니다. 지난번 텍스트 보간에 사용한 v-text 디렉티브처럼 Vue의 디렉티브에는 v- 라는 접두사가 붙습니다. 디렉티브를 HTML 템플릿 구문의 속성으로 작성하면 해당 지시문이 DOM에 적용됩니다.디렉티브는 Vue에서 제공하는 내장 디렉티브(Built-in Directives)와 사용자가 만들어서 사용하는 커스텀 디렉티브(Custom Directives)가 있습니다.이번 글에서는 Vue에서 기본적으로 제공하는 내장 디렉티브에 대해서 알아보겠습니다.v-html지난번에 텍스트 보간에 v-text를 사용했습니다. 만약 v-text를 사용하여 html 태그를 작성한다면 DOM이 생성되는 것이 아니라 텍스트 자체가 출력됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-text=\"html\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    html: `&lt;font color=\"red\"&gt;Red Color&lt;/font&gt;`  }}).$mount('#app')출력 결과하지만 v-html 디렉티브를 사용하면 html 템플릿을 통해 DOM을 생성합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-html=\"html\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;출력 결과동적으로 html을 렌더링 하는 것은 XSS 공격을 받을 가능성이 있기때문에 해당 디렉티브는 입력할 내용을 신뢰할 수 있을 경우에만 사용할 것을 권장합니다.v-bindv-bind는 태그 속성에 모델 데이터를 바인딩하거나 자식 컴포넌트에 프로퍼티를 전달할 때 사용합니다. 컴포넌트는 다음에 알아보도록 하고 우선 속성을 바인딩 하겠습니다.속성 바인딩은 v-bind:[key] = \"value\" 형태로 작성합니다. 예를 들어 id 속성에 id 데이터를 바인딩 하려면 다음과 같이 작성합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-bind:id=\"id\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    id: 'bindingTest'  }}).$mount('#app')DevTools를 통해 DOM 태그를 확인하면 id가 모델에 입력된 id값 bindingTest가 되었음을 확인할 수 있습니다.출력 결과해당 디렉티브는 :[key] = \"value\" 형태로 줄일 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :id=\"id\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;class 속성의 경우 Object 타입으로 다중 속성을 바인딩할 수 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :class=\"{a: true, b: true, c: false}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue().$mount('#app')출력 결과다음과 같이 속성을 각각 바인딩 할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :class=\"{a, b, c}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    a: true,    b: true,    c: false  }}).$mount('#app')한번에 Object 타입을 바인딩할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :class=\"classObj\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    classObj: {      a: true,      b: true,      c: false    }  }}).$mount('#app')배열로 바인딩할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :class=\"['a', 'b']\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue().$mount('#app')Object를 배열로 바인딩하여 클래스 속성을 합칠 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :class=\"[{a: true}, {b: true}, {c: false}]\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;style 속성 또한 class 속성과 유사합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" :style=\"styleObj\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    styleObj: {      fontSize: '20px',      'font-weight': 'bold',      color: 'red'    },    message: 'hello, world!'  }}).$mount('#app')출력 결과키값을 카멜 케이스(Camel Case)로 선언하면 스타일 속성이 케밥 케이스(Kebab Case)로 변경됩니다.styleObj에 선언한 fontSize가 자동으로 font-size 속성으로 변경된 것을 확인할 수 있습니다.v-if / v-else-if / v-else조건에 따라 DOM을 렌더링하고 싶다면 v-if 디렉티브를 사용합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;span v-if=\"isNotice\"&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    notice: 'notice',    isNotice: true  }}).$mount('#app')isNotice가 true이므로 조건식을 만족하여 해당 DOM은 렌더링되어 나타납니다.출력 결과콘솔창을 통해 isNotice를 false로 변경한다면 조건식을 만족하지 못하여 해당 DOM은 사라집니다.출력 결과처음 조건을 만족하지 못했을때 다른 조건문을 만족하는지 확인하고 싶다면 v-else-if 디렉티브를, 조건문을 만족하지 못했을 경우에 출력하고 싶다면 v-else 디렉티브를 사용합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;font v-if=\"color === 'red'\" color=\"red\"&gt;red&lt;/font&gt;    &lt;font v-else-if=\"color === 'blue'\" color=\"blue\"&gt;blue&lt;/font&gt;    &lt;font v-else&gt;default&lt;/font&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    color: 'red',  }}).$mount('#app')출력 결과여러 태그를 한꺼번에 묶어서 조건문을 처리하고 싶다면 template 태그에 v-if 디렉티브를 입력하면 됩니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;template v-if=\"isNotice\"&gt;      &lt;div&gt;1&lt;/div&gt;      &lt;div&gt;2&lt;/div&gt;      &lt;div&gt;3&lt;/div&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    isNotice: true  }}).$mount('#app')이 경우 template 태그는 렌더링 되지 않게 됩니다.출력 결과v-for반복문의 경우 v-for 디렉티브를 입력하면 됩니다. 배열, map, set 등 iterable 객체 및 Object 타입에 대한 반복문 작성이 가능합니다.v-for 디렉티브 선언&lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, key, index) in object\"&gt;&lt;/div&gt;예제는 아래와 같습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div v-for=\"(member, idx) in members\" :key=\"member.id\"&gt;      &lt;div&gt;index: &lt;/div&gt;      &lt;div&gt;id: &lt;/div&gt;      &lt;div&gt;name: &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  data: {    members: [      {id: 'rubisco', name: '루비스코' },      {id: 'spot', name: '스팟'}    ]  }}).$mount('#app')중요한 부분은 key 속성을 바인딩 했다는 것입니다. key는 primary key를 바인딩하여 각각의 요소들에 대한 순서에 대하여 힌트를 줄 수 있도록 합니다.출력 결과",
        "url": "/vue/vue-default-directive-1"
    }
    ,
    
    "vue-vue-instance": {
        "title": "Vue.js: Instance 생성",
            "author": "rubisco",
            "category": "",
            "content": "Vue란?Vue.js는 웹 어플리케이션을 개발하기위한 프로그레시브 자바스크립트 프레임워크입니다. MVVM(Model-View-ViewModel) 패턴을 사용하지만, 코어 라이브러리는 ViewModel에 집중되어 있습니다.주로 ECMAScript 6(ES6) 문법을 사용하는 React.js와 달리 웹컴포넌트(WebComponent)를 기반으로 하는 컴포넌트 개발 방식을 지원하기때문에 다른 프레임워크로 제작된 웹 애플리케이션 프로젝트에 Vue 컴포넌트를 점진적으로 통합시킬 수 있다는 장점이 있습니다.Vue는 Google Creative Laps에서 근무하던 중국 출신의 에반 유(Evan You)에 의해 개발되었습니다. 에반 유는 구글의 Angular.js를 이용한 프로젝트를 진행하면서 Angular.js의 양방향 데이터 바이딩에 매료되었고, 해당 기능을 가지면서 조금 더 가벼운 프레임워크를 만들고자 했습니다. 조금씩 자신의 프로젝트에 자신이 만든 경량화 라이브러리를 적용하였고, 2013년에 이르러 해당 라이브러리를 Vue.js라고 명명했습니다. 2014년 Hacker News 등을 통해 세상에 공개된 이후 개발자들의 뜨거운 관심을 받아 최근에는 React.js에 이어 2번째로 대중적인 자바스크립트 프레임워크가 되었습니다.프론트엔드 개발의 대규모화 추세에 따라 2020년 Vue 3.0 One Piece가 공개되었지만, 여기서는 2.7 Naruto 버전을 기준으로 예제를 작성하도록 하겠습니다.MVVM 패턴Vue는 MVVM 패턴을 사용하며, 코어의 경우 ViewModel 레이어에 해당하는 라이브러리 입니다.MVVM 패턴은 모델(Model), 뷰(View), 뷰모델(ViewModel)로 구성된 디자인 패턴입니다.사용자의 입력(Input)이 컨트롤러(Controller)로 전달되는 MVC 패턴과 달리 MVP 패턴과 같이 모든 사용자의 입력은 뷰(View)로 전달됩니다.View와 Presenter의 의존성이 강한 MVP 패턴과 달리 MVVM 패턴은 View와 ViewModel 사이의 의존성도 고려하여 각 구성요소를 독립적으로 작성할 수 있습니다. View와 ViewModel은 커맨드 패턴 또는 데이터 바인딩을 통해 통신함으로써 의존성을 제거할 수 있게 됩니다.ViewModel뷰모델(ViewModel)은 Model과 View를 동기화시키는 객체입니다. Vue.js에서 모든 Vue 인스턴스(Instance)는 뷰모델에 해당합니다.Vue 인스턴스는 아래와 같이 생성할 수 있습니다.Vue 인스턴스 생성new Vue();View뷰(View)는 Vue 인스턴스에 의해 관리되는 DOM 입니다.ViewModel은 HTML을 기반으로 하는 템플릿(Template) 구문을 통해 선언적으로 렌더링된 DOM에 데이터를 바인딩 할 수 있으며, $el라는 내부 프로퍼티를 통해 View를 관리할 수 있습니다.View binding&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt;  const vm = new Vue({el: '#app'});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Model모델(Model)은 일반적인 자바스크립트 객체입니다.모델이 Vue 인스턴스의 data로 사용되면 내부적으로 모델 속성이 getter와 setter로 전환되며, 해당 로직을 통해 데이터의 변경이나 접근을 감지하는 observe 기능이 활성화됩니다. 즉, 데이터가 변경되면 notify 기능을 통해 해당 데이터를 바인딩(binding)한 뷰(View)를 찾아 update 함으로써 뷰와 모델을 동기화시킬 수 있습니다. 더티 체크가 필요하지 않으며, 뷰를 업데이트하기 위한 명시적인 신호를 보낼 필요도 없습니다.모델(Model) 선언const model = {    message: 'hello'}const vm = new Vue({    data: model});ViewModel에서 $data 프로퍼티를 통해 모델에 접근 가능하며, ViewModel은 관찰하는 모델의 모든 속성을 프록시(proxy) 하고 있으므로 viewModel을 통해 모델에 접근해도 동일한 데이터에 접근할 수 있습니다.콘솔창을 통해 위와 같이 확인하면 vm.$data.message와 vm.message가 동일한 데이터를 참조한다는 사실을 알 수 있습니다.Vue 인스턴스 생성Vue는 주로 node.js 환경에서 vue-cli을 통해 개발하지만 cdn을 통해 모듈 형식으로 개발할 수도 있습니다. 이번 글에서는 후자를 통해 개발하겠습니다.워크스페이스(work space)에 vue 폴더를 만들고 해당 폴더에 index.html 파일을 생성한 후 다음 코드를 작성합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;이제 main.js 파일을 만들어서 Vue 인스턴스를 생성하고, id가 app인 element에 연결하도록 하겠습니다.다음 코드와 같이 el 옵션에 css 선택자를 value로 입력하면 됩니다.main.jsconst mv = new Vue({  el: '#app'})index.html 파일을 열고 콘솔창에 mv를 입력하면 Vue 인스턴스가 생성되어 있습니다.연결된 element의 DOM에 접근하고 싶다면 $el 프로퍼티를 참조합니다.Vue 인스턴스의 $mount 메소드를 통해서 동적으로 element에 연결할 수도 있습니다.main.jsconst mv = new Vue();mv.$mount('#app');데이터 바인딩data 옵션data 옵션은 Vue 인스턴스가 관리하는 데이터 즉, Model을 설정합니다. Vue 인스턴스가 생성될 때 설정된 Model의 속성은 ViewModel에 의해 관리되며, 속성이 변경되면 ViewModel이 이를 감지하여 해당 속성이 바인딩된 View를 업데이트합니다.data 옵션은 다음과 같이 JSON 타입으로 줄 수 있습니다.main.jsconst mv = new Vue({  data: {    message: 'Hello, world!'  }}).$mount('#app')JSON 타입을 리턴하는 함수로 작성할 수도 있습니다.main.jsconst mv = new Vue({  data() {    return {      message: 'Hello, world!'    }  }}).$mount('#app')다음에 설명할 Component의 경우 하나의 코드를 재사용하게 되는데, 이때 JSON 타입으로 data를 설정한다면 동일한 컴포넌트를 사용하는 Vue 인스턴스에서는 동일한 Model 데이터를 공유하게 되어 의도하지 않은 결과가 나올 수 있습니다. 함수형태로 작성한다면 참조값을 반환하는 것이 아니라 새로운 데이터 객체를 생성하여 반환하므로 서로 다른 모델 데이터를 가질 수 있게 됩니다.텍스트 보간Vue 인스턴스에 선언된 데이터를 View에 바인딩(binding)하기 위해서는 보간법을 사용합니다. 기본적으로 Mustache 구문을 사용하여 데이터를 바인딩합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt; {{ message }} &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;delimiters 옵션을 설정하면 {{ ... }} 기호 대신에 사용자가 정의한 기호를 설정할 수도 있습니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;[[ message ]]&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;main.jsconst mv = new Vue({  delimiters: ['[[', ']]'],  data: {    message: 'Hello, world!'  }}).$mount('#app')디렉티브(directive)를 통해 데이터를 바인딩 할 수도 있습니다. 디렉티브는 HTML 템플릿 구문에서 v- 접두사가 붙은 속성을 말하며, 텍스트 보간에 대해서는 v-text 속성을 사용합니다.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;  &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;title&gt;Vue 연습&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\" v-text=\"message\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;View에 바인딩된 모델 속성을 변경하면 ViewModel이 이를 감지하여 View를 업데이트시킵니다.콘솔창에 mv.message = 'wellcome!'이라고 입력하면 View가 업데이트 되는 것을 확인할 수 있습니다.",
        "url": "/vue/vue-instance"
    }
    ,
    
    "java-maven-project": {
        "title": "이클립스 메이븐 프로젝트",
            "author": "rubisco",
            "category": "",
            "content": "학원에서 열심히 스프링 부트를 중심으로 JPA를 연마했건만 현업에서는 부트가 쓰이지 않는다고 합니다.심지어 에디터 조차도 대부분 이클립스를 사용한다고 하는데, 최근까지 지원하던 STS3을 더이상 지원하지 않아 이클립스 최신버전에서는 레거시 프로젝트조차 만들수 없는 상황이 왔습니다.이번 글에서는 연습삼아서 이클립스를 통해 메이븐 프로젝트를 생성하고, 스프링 mvc를 구성해보도록 하겠습니다.이클립스 / JDK 11 / Tomcat9 다운로드우선 이클립스를 다운받도록 하겠습니다.https://www.eclipse.org/downloads/packages/로 들어갑니다.인스톨러를 다운받아도 되지만 패키지 파일을 받도록 하겠습니다. 웹어플리케이션을 개발할 것이니 Eclipse IDE for Enterprise Java and Web Developers를 다운로드 합니다.JDK와 톰캣은 레거시 프로젝트때 다운받은 것을 사용하겠습니다.  oracle JDK 11  Tomcat 9이클립스 패키지를 적당한곳에 압축을 풀고 작업공간을 만들어줍시다. 저는 eclipse-ws라고 만들었습니다.eclipse 폴더에 들어가서 eclipse.exe를 실행합니다. 작업공간을 지정해주고 Launch를 클릭하면 이클립스가 실행됩니다.환경설정 설정STS3이 이클립스 기반이기 때문에 환경설정의 경우 STS3과 동일하게 설정하면 됩니다.상단에 Window &gt; Preferences를 클릭합니다.General &gt; Content Types에 들어가서 Text를 선택하고 하단에 Default encoding에 utf-8을 입력후 Update 버튼을 누르세요.General &gt; Workspace에서 Text file encoding 또한 UTF-8로 번경 후 Apply 버튼을 누르세요Web &gt; CSS Files, Web &gt; HTML Files, Web &gt; JSP Files, XML &gt; XML Files, JSON &gt; JSON Files 또한 Encoding을 UTF-8로 변경후 Apply 버튼을 누르세요.이클립스 역시 기존 JDK 버전을 17로 사용하고 있어서 환경변수가 17 버전으로 되어 있습니다. JAVA &gt; Compiler에서 JDK Compiler compliance level을 11로 변경하고, JAVA &gt; Installed JREs에서 JDK 11버전 경로를 추가한 후 Apply를 클릭하세요.톰캣 서버 생성STS와 동일합니다.상단에 window &gt; Show View &gt; Servers를 클릭하여 서버창을 엽니다.왼쪽 하단에 링크를 클릭하여 서버를 추가합시다.Tomcat v9.0 Server를 선택후 Next 버튼을 클릭합니다.Browse... 버튼을 클릭하여 설치한 톰캣 폴더를 디렉토리로 지정한후 Finish를 클릭하세요.메이븐 프로젝트 생성메이븐(Maven)은 빌드도구로, pom.xml 파일을 통해 프로젝트 의존성을 관리해줍니다. pom은 Project Object Model의 약자입니다. 스프링 레거시 프로젝트를 만들때 기본 빌드도구로 메이븐을 사용했었습니다. 참고로 스프링 부트 프로젝트의 경우 gradle을 기본 빌드도구로 사용합니다.우선 상단메뉴에서 File &gt; New &gt; Maven Project를 클릭합니다.Next를 클릭합니다.maven-archetype-webapp 아티팩트(Artifact)를 검색하여 그룹id가 org.apache.maven.archetype인 아티팩트를 선택하고 Next를 클릭합니다.그룹id와 아티팩트id를 입력하고 Finish를 눌러 프로젝트를 생성합니다.하단 콘솔창에 프로젝트를 생성할 것인지 확인하는 문구가 뜹니다. y를 입력하고 엔터를 눌러 프로젝트를 생성합니다.프로젝트가 생성되는데 오류마커가 뜹니다. 마커창을 확인하면 우선 JRE 버전이 달라서 문제가 발생했습니다.좌측에 프로젝트 폴더를 선택후 상단메뉴의 Project &gt; Properties를 클릭합니다.Project Facets에서 Java 버전을 11로 설정후 Apply and Close를 눌러 자바버전을 변경합니다.JSP 관련 오류도 발생했는데 이것은 의존성이 없기때문입니다. 메이븐 레포지토리를 참고하여 javax.servlet-api, javax.servlet.jsp-api를 의존성으로 추가합니다. jstl도 같이 추가해줍시다.pom.xml...        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.3.3&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;...index.jsp에 다음 헤더를 입력하고 저장하면 모든 오류가 제거됩니다./src/main/webapp/index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;아직 web.xml 파일을 설정하지 않아서 루트경로는 /src/main/webapp입니다. 톰캣에 프로젝트를 추가하여 실행시켜보겠습니다.톰캣서버에 마우스 오른쪽 클릭하고 Add and Remove...를 클릭합니다.왼쪽에 있는 프로젝트를 선택후 Add &gt;를 클릭하여 오른쪽으로 이동시킨 후 Finish를 눌러 프로젝트를 톰캣서버에 설정합니다.톰캣서버를 클릭후 단축키 Ctrl + Alt + R을 누르면 톰캣서버가 실행됩니다. default 경로는 프로젝트 이름이고, default 포트는 8080입니다.http://localhost:8080/work로 이동하면 톰캣서버가 잘 작동한다는 사실을 알 수 있습니다.스프링 프레임워크 의존성 추가이제 스프링 프레임워크를 의존성 추가해주세요.프로퍼티로 자바 버전을 설정하고 spring-core와 spring-webmvc를 추가하겠습니다.pom.xml...    &lt;properties&gt;        ...        &lt;org.springframework-version&gt;5.3.23&lt;/org.springframework-version&gt;    &lt;/properties&gt;...        &lt;!-- 스프링 프레임워크 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;${org.springframework-version}&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${org.springframework-version}&lt;/version&gt;        &lt;/dependency&gt;...웹어플리케이션 설정web.xml 설정web.xml 파일은 클라이언트의 요청 경로와 요청을 처리하는 서블릿 사이의 매핑을 정의합니다.요청 경로와 서블릿을 매핑하기 sevlet 태그로 서블릿을 선언하고 servlet-mapping 태그에 매핑할 경로를 정의합니다.예제로 다음과 같이 작성해보겠습니다./src/main/webapp/WEB-INF/web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.1\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"               xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"&gt;    &lt;display-name&gt;Mission Web Application&lt;/display-name&gt;      &lt;servlet&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;kr.kro.rubisco.work.TestServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;기본적으로 web-app 버전이 2.3으로 설정되어 있는데, 2.3은 el 사용이 안되므로 의존성에 추가한 3.1버전으로 바꿔줍시다.hello라는 이름의 서블릿을 정의하는데, 해당 서블릿의 타입(클래스)는 kr.kro.rubisco.work.TestServlet 입니다. hello 서블릿은 /hello라는 클라이언트의 요청에 매핑됩니다.이제 kr.kro.rubisco.work 패키지에 TestServlet 이라는 서블릿 클래스를 작성하면 됩니다.처음에는 소스 경로가 없는데, /src/main 폴더에 java 폴더를 생성하면 소스경로가 생깁니다.해당 소스경로에 오른쪽 클릭을 하여 패키지를 생성합니다.해당 패키지에 TestServlet 클래스를 생성하여 다음과 같이 작성합니다./kr.kro.rubisco.TestServlet.javapackage kr.kro.rubisco.work;import java.io.IOException;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;public class TestServlet extends HttpServlet {        private static final long serialVersionUID = 1L;    public void init(ServletConfig config) throws ServletException {        System.out.println(\"init() 실행됨!\");    }    public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {        System.out.println(\"service() 실행됨!\");    }}서블릿이기때문에 웹요청에 대한 서블릿인 HttpServlet을 상속받아 구현합니다.http://localhost:8080/work/hello 경로로 이동하면 hello 서블릿으로 매핑되어 서비스 처리를 하는 것을 볼 수 있습니다.init 메소드는 톰캣서버가 실행될 때 최초 한번 실행되는 초기화 메소드이며, service 메소드는 클라이언트 요청이 있을때마다 호출되는 메소드입니다.HttpServlet에 다양한 메소드가 있는데 일단 생략하겠습니다.스프링 프레임워크의 DispatcherServlet 역시 HttpServlet을 상속받은 서블릿입니다. 즉, 모든 요청에 대하여 DispatcherServlet에 매핑되도록 하면 스프링 컨테이너를 통해 클라이언트 요청을 제어할 수 있게 됩니다.다음과 같이 web.xml을 작성해주세요./src/main/webapp/WEB-INF/web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.1\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"               xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"&gt;    &lt;display-name&gt;Mission Web Application&lt;/display-name&gt;    &lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;        &lt;filter&gt;        &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;    &lt;/filter&gt;        &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;        &lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;        &lt;!-- Processes application requests --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;/web-app&gt;레거시 프로젝트에서 그대로 가져왔습니다.display-name 태그는 어플리케이션의 이름을 나타냅니다.context-param은 전역변수에 해당하는 Root WebApplicationContext를 설정합니다. 컨텍스트는 쉽게 말하자면 빈(bean)이 담겨있는 컨테이너라고 보시면 됩니다. ServletContext는 크게 2가지로 형태로 존재하는데, 그 중 하나가 전역변수에 해당하는 Root WebApplicationContext 입니다.서블릿이 로드될 때 아래에서 설명할 ContextLoaderListener에 의하여 Root WebApplicationContext가 생성되는데, 이때 ContextLoaderListener는 context-param의 contextConfigLocation 파라미터에 지정된 설정파일에 따라 빈을 로드하여 컨텍스트를 생성하고 ServletContext에 저장합니다. contextConfigLocation이 설정되지 않으면 기본값으로 /WEB-INF/applicationContext.xml 경로파일을 찾으며, 해당 컨텍스트 파일에는 보통 Service나 DAO 객체가 정의됩니다.fliter는 지난번 글에서 자세히 설명했으므로 생략합니다. 인코딩 필터와 히든 메소드 필터를 추가합니다.listener는 특정 이벤트에 대하여 호출되어 처리하는 객체입니다. ContextLoaderListener의 경우 웹서비스가 시작되거나 종료될 때 호출되며, 이때 전역변수에 해당하는 Root WebApplicationContext를 생성하거나 제거하는 역할을 합니다. 위에서 말한것과 같이 리스너에 의해 생성된 Root WebApplicationContext는 ServletContext에 저장됩니다.servlet 태그 아래 init-param 태그는 지역변수에 해당하는 Child WebApplicationContext를 설정합니다. 서블릿에 의해 생성되며, 루트 컨텍스트와 마찬가지로 contextConfigLocation 파라미터에 지정된 설정파일에 따라 빈을 로드하여 컨텍스트를 생성하고 ServletContext에 저장합니다. contextConfigLocation이 설정되지 않으면 기본값으로 /WEB-INF/[서블릿 이름]-servlet.xml 경로파일을 찾으며, 해당 컨텍스트 파일에는 보통 Controller나 ViewResorver 객체가 정의됩니다.Child WebApplicationContext에서는 ContextLoaderListener에 의해 생성된 Root WebApplicationContext에 접근이 가능합니다. 하지만 그 반대는 불가합니다. 즉, Controller 또는 ViewResolver에서는 Service나 DAO를 참조할 수 있지만, Service에서 Controller는 참조하지 못합니다. SevletContext에 저장된 빈들은 ServletConfig의  getinitParameter 메소드를 통해 불러올 수 있습니다. 위에서 작성한 TestServlet의 init 메소드를 참고하세요.마지막으로 load-on-startup 태그는 톰캣서버가 실행될 때 DispatcherServlet의 초기화 여부와 순서를 나타냅니다. 서블릿은 최초 클라이언트의 요청에 대하여 한번 초기화되는데, 그렇기때문에 최초 요청에 대하여 처리속도가 느릴 수 있습니다. 이때 해당 태그를 양수로 입력하면 클라이언트의 최초 요청이 아니라 톰캣서버가 실행되는 시점에서 서블릿이 초기화되며, 숫자는 초기화되는 우선순위를 나타냅니다.root-context.xml 설정root-context.xml 파일은 context-param에서 정의되는 Root WebApplicationContext의 설정파일입니다. 위에서 말했듯이 해당 컨텍스트는 전역변수와 같아서 모든 ServletContext에서 참조가능합니다./src/main/webapp/WEB-INF/spring/root-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt;        &lt;context:component-scan base-package=\"kr.kro.rubisco.work.service\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;DAO나 Service 등 모든 서블릿에서 접근가능한 빈이 등록되는데 DB연결은 나중에 하도록 하고 우선 context 네임스페이스의 component-scan을 설정합니다. 속성으로 base-package를 입력하는데, 해당 값에 등록된 패키지를 스캔하여 @Component 어노테이션이 붙은 클래스를 자동으로 빈(bean)으로 등록하는 역할을 합니다. kr.kro.rubisco.work.service 패키지에 서비스를 작성할 예정이므로 미리 해당 패키지를 생성해둡시다.servlet-context.xml 설정servlet-context.xml 파일은 servlet의 init-param에서 정의되는 Child WebApplicationContext의 설정파일입니다. 위에서 말했듯이 해당 컨텍스트는 지역변수와 같아서 해당 ServletContext에서만 참조가능합니다./src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure --&gt;        &lt;!-- Enables the Spring MVC @Controller programming model --&gt;    &lt;annotation-driven /&gt;    &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory --&gt;    &lt;resources mapping=\"/**\" location=\"/WEB-INF/resources/\" /&gt;    &lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;    &lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt;        &lt;beans:property name=\"suffix\" value=\".jsp\" /&gt;    &lt;/beans:bean&gt;    &lt;context:component-scan base-package=\"kr.kro.rubisco.work.controller\" /&gt;    &lt;/beans:beans&gt;네임스페이스로 mvc, context, beans를 설정하고, 빈으로 InternalResourceViewResolver을 등록했습니다. 해당 resolver는 DispatcherServlet의 기본 뷰 리졸버로, JSP를 뷰로 사용할 때 쓰입니다. 프로퍼티로 prefix와 suffix를 가지며, 클라이언트의 요청으로부터 접두어(prefix)와 접미어(suffix)를 붙여 실제 리소스 경로를 찾을수 있도록 돕습니다. 즉, /hello 라는 ViewName을 통해 /WEB-INF/views/hello.jsp 파일을 찾게 됩니다. prefix를 변경했기때문에 기존에 생성되어있던 index.jsp 파일을 /WEB-INF/views 경로로 이동시켜주세요.서비스와 마찬가지로 context 네임스페이스의 component-scan을 설정하여 kr.kro.rubisco.work.controller 패키지를 스캔하도록 합니다. 해당 패키지에는 컨트롤러를 작성할 예정이므로 미리 패키지를 생성해둡시다.annotation-driven 태그는 어노테이션을 통해 Controller 호출이나 bean 객체 등록 등의 매핑작업을 편리하게 할 수 있도록 해줍니다.resources 태그는 정적 자원의 경로를 설정합니다. 클라이언트가 /resources/** 경로로 요청하면 /resources/ 경로에서 정적 자원을 가져옵니다.Controller 작성스프링 MVC의 설정은 끝이며, 여기서부터는 기존 레거시 프로젝트와 동일하게 진행하면 됩니다. 톰캣서버에서 루트 경로를 /으로 변경하고 다음 컨트롤러와 뷰를 작성 후 http://localhost:8080/hello으로 이동해보세요./kr/kro/rubisco/controller/WorkController.javapackage kr.kro.rubisco.work;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class WorkController {    @GetMapping(\"/hello\")    public void getHelloView() {}}/src/main/webapp/WEB-INF/views/hello.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;안녕하세요?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;이클립스를 통한 스프링 MVC 설정&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;오라클 DB이번 프로젝트에서는 오라클 클라우드가 아닌 오라클DB를 직접 설치하고 연결해보도록 하겠습니다. 11버전을 다운받겠습니다.설치우선 아래 링크로 들어가서 오라클을 다운로드 합니다.  : https://www.oracle.com/database/technologies/xe-prior-release-downloads.html라이센스 동의에 체크한 후 다운로드 버튼을 클릭합니다.압축파일을 풀고 setup.exe를 실행시켜 오라클을 설치할 수 있습니다.권한설정이제 오라클DB를 사용하기위한 계정을 만들고 권한을 부여해보겠습니다. 먼저 단축키 Ctrl + R을 눌러 실행창을 열고 powershell 또는 cmd를 입력후 터미널을 실행시켜줍니다.명령프롬프트에서 sqlplus 라고 입력하면 DB에 접속됩니다. 유저네임과 패스워드를 입력하라고 뜨는데, 시스템 계정으로 접속합니다. 유저네임은 system, 패스워드는 오라클을 설치할때 입력한 암호입니다.다음 쿼리문을 통해 계정을 생성합니다.계정 생성 쿼리문create user [아이디] identified by [비밀번호];생성된 계정에 권한을 부여하겠습니다.권한 부여 쿼리문grant connect, resource to [아이디];connect는 DB에 접속하기 위한 기본적인 시스템 권한을, resource는 객체(테이블, 뷰, 인덱스) 생성에 필요한 시스템 권한을 설정합니다. DBA는 DB 관리자 권한을 부여하여 모든 권한을 가지게 됩니다.DB 연결이제 DB에 연결해보겠습니다. 오라클DB의 연결 정보는 보통 tnsnames.ora 파일에 저장되어 있습니다. 만약 해당 파일이 있다면 IP 주소나 SID 또는 Service Name을 직접 입력하지 않아도 바로 DB와 연결할 수 있습니다.오라클을 설치하면 해당 파일이 하나 생성됩니다. 해당 파일은 $ORACLE_HOME/network/admin/에 위치하며, 위에 과정을 따라왔다면 C:/oraclexe/app/oracle/product/11.2.0/server/network/ADMIN 경로에 존재합니다.맨 앞에 XE는 별칭(alias)입니다. 요한 부분은 HOST, PORT, SERVICE_NAME 입니다.3개의 정보를 가지고 DB 연결 주소를 직접 작성할 수도 있습니다.  jdbc:oracle:thin@localhost:1521:XE하지만 tnsnames.ora 파일이 있다면 연결정보를 직접 작성하지 않아도 됩니다. DBever를 통해 연결해보겠습니다. DBever를 열고 상단메뉴에 새 데이터베이스 연결을 클릭합니다.오라클을 선택 후 Connection Type에서 TNS 탭을 클릭하여 alias와 tnsnames.ora 파일이 있는 경로를 설정해줍니다. 유저네임과 패스워드를 입력후 Client를 선택하는데 오라클을 설치할 때 XE라는 이름으로 하나 생성되어 있습니다. 완료를 누르면 오라클DB에 바로 연결됩니다.Mybatis 연동이제 웹어플리케이션에 DB를 연결해보겠습니다. DB에 연결하기 위해서는 JDBC가 필요하며, Mybatis를 통해 쿼리를 매핑할 것입니다. 의존성으로 spring-jdbc, mybatis, mybatis-spring, ojdbc를 추가합니다. 오라클 11.2의 경우 ojdbc6를 사용합니다.pom.xml...        &lt;!-- Spring JDBC --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${org.springframework-version}&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.2&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc6 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;            &lt;version&gt;11.2.0.4&lt;/version&gt;        &lt;/dependency&gt;...다음으로 db 연결정보를 가지는 dataSource와 쿼리를 만들어내는 sqlSessionFactory, 쿼리를 담고있는 sqlSession을 빈으로 추가해야합니다. DAO에 해당하므로 Root WebApplicationContext에 추가합니다./src/main/webapp/WEB-INF/spring/root-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt;        &lt;!-- Root Context: defines shared resources visible to all other web components --&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;          &lt;property value=\"oracle.jdbc.driver.OracleDriver\" name=\"driverClassName\"/&gt;          &lt;property value=\"[연결경로]\" name=\"url\"/&gt;          &lt;property value=\"[아이디]\" name=\"username\"/&gt;          &lt;property value=\"[패스워드]\" name=\"password\"/&gt;    &lt;/bean&gt;             &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;          &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\"&gt;&lt;/property&gt;                &lt;/bean&gt;    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt;        &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;context:component-scan base-package=\"kr.kro.rubisco.work.service\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;dataSource에서 연결 경로는 위해서 설명했듯이 jdbc:oracle:thin@HOST:PORT:SERVICE_NAME 형태로 작성합니다.mybatis의 설정파일은 classpath에 존재합니다. 레거시와 동일하게 /src/main 경로 아래에 resources 폴더를 만들고 해당 폴더를 classpath로 설정해주겠습니다. 폴더를 생성한 후 오른쪽 클릭하여 Build Path &gt; Use as Source Folder를 클릭하면 classpath로 설정됩니다.resources 폴더 아래에 mybatis의 설정파일을 작성합니다./src/main/resources/mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;        &lt;setting name=\"callSettersOnNulls\" value=\"true\"/&gt;        &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;    &lt;/settings&gt;        &lt;typeAliases&gt;        &lt;package name=\"kr.kro.rubisco.work.dto\"/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;레거시에서 설명했기에 생략합니다. dto의 alias가 패키지에 해당하므로 해당 패키지 폴더를 생성해주세요. 또한 resources 폴더 아래 매퍼를 작성하기 위한 mappers 패키지 폴더를 만들어주세요.DBever를 통해 테이블을 먼저 만들겠습니다.테이블 생성 쿼리CREATE TABLE mission (    idx         NUMBER(10) PRIMARY KEY,    id          VARCHAR2(50) UNIQUE NOT NULL,    name        VARCHAR2(50) NOT NULL,    gender      CHAR(1) NOT NULL,    nation      VARCHAR2(50) NOT NULL,    city        VARCHAR2(50) NOT NULL,    create_date DATE NOT NULL);CREATE  SEQUENCE mission_idx_seq        INCREMENT BY 1        START WITH 1        MINVALUE 1        MAXVALUE 9999999999        NOCYCLE        NOCACHE        NOORDER;해당 테이블을 기준으로 DTO를 작성하겠습니다./kr/kro/rubisco/work/dto/MissionDTO.javapackage kr.kro.rubisco.work.dto;import java.util.Date;public class MissionDTO {        private Long idx;    private String id;    private String name;    private String gender;    private String nation;    private String city;    private Date date;        public Long getIdx() {        return idx;    }    public void setIdx(Long idx) {        this.idx = idx;    }    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public String getNation() {        return nation;    }    public void setNation(String nation) {        this.nation = nation;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }        public Date getDate() {        return date;    }    public void setDate(Date date) {        this.date = date;    }}롬복을 사용하지 않았습니다. 멤버변수만 정의하고 단축키 Alt + S, R을 누르면 제네레이터창이 뜹니다. 해당 제네레이터를 통해 getter와 setter를 만들었습니다.다음으로 DAO 인터페이스를 작성하겠습니다. DAO는 Mapper에 의하여 구현됩니다./kr/kro/rubisco/work/dao/MissionDAO.javapackage kr.kro.rubisco.work.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kr.kro.rubisco.work.dto.MissionDTO;@Mapperpublic interface MissionDAO {    public void create(MissionDTO mission) throws Exception;        public List&lt;MissionDTO&gt; listAll() throws Exception;        public void update(MissionDTO mission) throws Exception;    public void delete(MissionDTO mission) throws Exception;}이제 mapper를 작성합니다./src/main/resources/mappers/missionMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kr.kro.rubisco.work.dao.MissionDAO\"&gt;&lt;insert id=\"create\"&gt;insert into mission (idx, id, name, gender, nation, city, create_date)values (mission_idx_seq.NEXTVAL, #{id}, #{name}, #{gender}, #{nation}, #{city}, #{date})&lt;/insert&gt;&lt;select id=\"listAll\" resultType=\"MissionDTO\"&gt;select * from mission&lt;/select&gt;&lt;update id=\"update\"&gt;update missionset id=#{id},    name=#{name},    gender=#{gender},    nation=#{nation},    city=#{city}where idx = #{idx}&lt;/update&gt;&lt;delete id=\"delete\"&gt;delete from mission where idx = #{idx}&lt;/delete&gt;&lt;/mapper&gt;서비스를 만드세요./kr/kro/rubisco/work/service/MissionService.javapackage kr.kro.rubisco.work.service;import java.util.List;import kr.kro.rubisco.work.dto.MissionDTO;public interface MissionService {    public void insertMission(MissionDTO mission) throws Exception;        public List&lt;MissionDTO&gt; getMissionList() throws Exception;        public void updateMission(MissionDTO mission) throws Exception;        public void deleteMission(MissionDTO mission) throws Exception;}/kr/kro/rubisco/work/service/impl/MissionServiceImpl.javapackage kr.kro.rubisco.work.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kr.kro.rubisco.work.dao.MissionDAO;import kr.kro.rubisco.work.dto.MissionDTO;import kr.kro.rubisco.work.service.MissionService;@Service@Transactional(readOnly = true)public class MissionServiceImpl implements MissionService {    private final MissionDAO missionDAO;        public MissionServiceImpl(SqlSession sqlSession) {        this.missionDAO = sqlSession.getMapper(MissionDAO.class);    }        @Override    public void insertMission(MissionDTO mission) throws Exception {        missionDAO.create(mission);    }    @Override    public List&lt;MissionDTO&gt; getMissionList() throws Exception {        return missionDAO.listAll();    }    @Override    public void updateMission(MissionDTO mission) throws Exception {        missionDAO.update(mission);    }    @Override    public void deleteMission(MissionDTO mission) throws Exception {        missionDAO.delete(mission);    }}기본적인 CRUD만 구현했습니다. 이제 컨트롤러를 작성합니다./kr/kro/rubisco/work/controller/MissionRestController.javapackage kr.kro.rubisco.work.controller;import java.util.List;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import kr.kro.rubisco.work.dto.MissionDTO;import kr.kro.rubisco.work.service.MissionService;@RestController@RequestMapping(\"/mission\")public class MissionRestController {    private final MissionService missionService;        public MissionRestController(MissionService missionService) {        this.missionService = missionService;    }        @GetMapping()    public ResponseEntity&lt;List&lt;MissionDTO&gt;&gt; getMissionList() throws Exception {        return ResponseEntity.ok(missionService.getMissionList());    }        @PostMapping()    public ResponseEntity&lt;MissionDTO&gt; insertMission(@RequestBody MissionDTO mission) throws Exception {        missionService.insertMission(mission);        return ResponseEntity.ok(mission);    }        @PutMapping()    public ResponseEntity&lt;MissionDTO&gt; updateMission(@RequestBody MissionDTO mission)throws Exception {        missionService.updateMission(mission);        return ResponseEntity.ok(mission);    }        @DeleteMapping()    public ResponseEntity&lt;MissionDTO&gt; deleteMission(@RequestBody MissionDTO mission)throws Exception {        missionService.deleteMission(mission);        return ResponseEntity.ok(mission);    }}빠른 확인을 위해 RestController를 작성했습니다. json 객체를 binding 하기 위해서는 jackson-databind를 의존성 추가해야합니다.pom.xml...        &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.13.3&lt;/version&gt;        &lt;/dependency&gt;...localhost:8080으로 이동하여 크롬 개발자도구를 열고 fetch를 통해 비동기 요청으로 insert를 해보세요.POST 요청fetch(\"/mission\", {    method: \"POST\",    headers: {\"Content-type\": \"application/json\"},    body: JSON.stringify({        id:\"id1\",         name: \"루비스코\",         gender: \"M\",         nation: \"한국\",        city: \"천안\",        date: \"2022-11-19\"    })}).then(res=&gt;res.json()).then(data=&gt;console.log(data));get요청을 보내면 리스트가 출력됩니다.GET 요청fetch(\"/mission\")    .then(res=&gt;res.json())    .then(data=&gt;console.log(data));insert가 잘 되어있습니다. 이번에는 PUT 요청으로 업데이트를 합니다.PUT 요청fetch(\"/mission\", {    method: \"PUT\",    headers: {\"Content-type\": \"application/json\"},    body: JSON.stringify({        idx: 1,        id:\"id2\",         name: \"루비스코\",         gender: \"M\",         nation: \"한국\",        city: \"천안\",        date: \"2022-11-19\"    })}).then(res=&gt;res.json()).then(data=&gt;console.log(data));id를 변경했습니다. get요청으로 다시 확인하면 id가 바뀐것을 확인할 수 있습니다.마지막으로 delete 요청을 하고 get요청으로 확인하면 삭제가 된 것을 확인할 수 있습니다.DELETE 요청fetch(\"/mission\", {    method: \"DELETE\",    headers: {\"Content-type\": \"application/json\"},    body: JSON.stringify({idx: 1})}).then(res=&gt;res.json()).then(data=&gt;console.log(data));",
        "url": "/java/maven-project"
    }
    ,
    
    "java-spring-legacy-security": {
        "title": "스프링 레거시(Spring legacy) - 시큐리티 적용",
            "author": "rubisco",
            "category": "",
            "content": "스프링 시큐리티(Spring Security)지난번 글에서 작성한 것처럼 로그인 인증(Authentication)과 권한 인가(Authorization) 로직은 서블릿 필터나 스프링 인터셉터를 통해서 구현할 수 있습니다.스프링은 인증과 인가 등의 애플리케이션 보안과 관련된 기능들을 모은 스프링 시큐리티(Spring Security) 프로젝트를 제공합니다.스프링 시큐리티의 기본 아키텍처는 다음과 같습니다.스프링 시큐리티는 서블릿 필터를 기반으로 합니다. 서블릿 필터는 스프링 컨테이너에서 생성된 빈이 아니기 때문에 스프링 빈을 주입받을 수 없습니다. 그렇기때문에 스프링 시큐리티에서는 서블릿 필터에 프록시를 등록하고, 해당 프록시를 통해 스프링 컨테이너에서 서블릿을 처리할 수 있도록 해줍니다.이번 글에서는 스프링 시큐리티를 통해 인증 및 인가 기능을 구현해보도록 하겠습니다.의존성 추가우선 메이븐 레포지토리를 참고하여 spring-security-web와 spring-security-config를 의존성 추가합니다. 글 작성 기준으로 가장 사용률이 높은 5.7.3버전을 추가하겠습니다.pom.xml...        &lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;            &lt;version&gt;5.7.3&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-config --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;            &lt;version&gt;5.7.3&lt;/version&gt;        &lt;/dependency&gt;...필터 추가다음으로 서블릿 필터를 추가하도록 하겠습니다. 스프링 시큐리티에서 제공하는 서블릿 필터는 DelegatingFilterProxy 입니다. 지난번에 등록한 loginCheckFilter를 제거하고 해당 필터를 필터체인에 등록합니다./src/main/webapp/WEB-INF/web.xml...    &lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            /WEB-INF/spring/root-context.xml            /WEB-INF/spring/security-context.xml        &lt;/param-value&gt;    &lt;/context-param&gt;...    &lt;filter&gt;        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;/filter&gt;...    &lt;filter-mapping&gt;        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;...springSecurityFilterChain이라는 이름으로 org.springframework.web.filter.DelegatingFilterProxy 클래스를 필터로 등록하고, 전체 경로에 매핑해줍니다. 이 경우 클라이언트의 모든 요청이 해당 필터를 거치게 됩니다.DelegatingFilterProxy는 서블릿 필터이므로 스프링 컨테이너의 제어를 받지 않습니다. 대신에 스프링에서 지원하는 특수 필터인 FilterChainProxy를 감싸고 있어서 해당 필터가 하는 일을 대신하게 됩니다. FilterChainProxy는 스프링 빈이므로, 스프링 컨테이너의 제어를 받아서 의존성 빈을 주입할 수 있습니다. 시큐리티에서는 springSecurityFilterChain이라는 이름의 객체가 FilterChainProxy를 구현하여 스프링 빈으로 등록되어 있으며, DelegatingFilterProxy가 해당 빈을 대리자로 등록하기 위해서는 필터이름을 빈의 이름과 동일하게 설정하면 됩니다. 이러한 이유로 filter-name을 springSecurityFilterChain로 등록합니다.시큐리티 필터springSecurityFilterChain은 많은 필터 리스트로 구성되어 체인을 형성하며, 순서대로 실행됩니다. 일부 필터의 기능은 다음과 같습니다.            필터      기능                  WebAsyncManagerIntegrationFilter      비동기 기능을 사용할때 시큐리티 컨텍스트를 사용할 수 있도록 해주는 필터              SecurityContextPersistenceFilter      Authentication 객체를 보관하는 시큐리티 컨텍스트를 생성하는 필터              HeaderWriterFilter      응답(Response)에 시큐리티와 관련된 헤더를 설정하는 필터              CorsFilter      허가된 사이트나 클라이언트의 요청인지 검사하는 필터              CsrfFilter      CSRF 공격을 방어하는 필터              LogoutFilter      로그아웃 요청을 처리하는 필터              UsernamePasswordAuthenticationFilter      username, password를 사용하는 form 기반 인증을 처리하는 필터              ConcurrentSessionFilter      동시세션을 제어하는 필터              BearerTokenAuthenticationFilter      JWT 인증 필터              BasicAuthenticationFilter      Basic 인증 필터              RequestCacheAwareFilter      캐시요청을 처리하는 필터              SecurityContextHolderAwareRequestFilter      보안 관련 Servlet 3 스펙을 지원하기 위한 필터              RememberMeAuthenticationFilter      RememberMe 쿠키를 검사하여 인증하는 필터              AnonymousAuthenticationFilter      익명사용자의 요청을 처리하는 필터              SessionManagementFilter      세션을 제어하는 필터              ExcpetionTranslationFilter      예외 처리 필터              FilterSecurityInterceptor      인가를 결정하는 필터      시큐리티 컨텍스트시큐리티 컨텍스트는 단독으로 설정되어야 하므로 root-context.xml과는 별도의 xml 파일을 작성해야합니다. security-context.xml 파일을 새로 만들고 시큐리티 컨텍스트를 설정하겠습니다. 해당 파일을 스프링 컨테이너의 설정파일로 등록해야 하므로 위에서 작성한 web.xml 파일에는 contextConfigLocation의 파라미터 값으로 /WEB-INF/spring/security-context.xml을 추가했습니다.이제 각종 필터들을 통해 체인을 설정해야하는데 필터의 종류가 많고 복잡하기때문에 기회가 되면 시큐리티에 대해서 글을 따로 작성해보도록 하겠습니다. 이 글에서는 인증에 사용되는 필터체인을 구성해보겠습니다.아키텍처인증의 아키텍처는 다음과 같습니다.  클라이언트의 요청(Request)이 오면 AuthenticationFilter를 거칩니다.  유저자격을 기반으로 인증토큰(AuthenticationToken) 객체를 생성합니다.  인증 필터를 통해 AuthenticationToken 객체를 AuthenticationManager 인터페이스에 위임합니다. ProviderManager는 AuthenticationManager의 구현체입니다.  AuthenticationProvider를 통해 인증을 시도합니다.  UserDetailsService를 통해 username을 기반으로 userDetails를 검색합니다.  UserDetails를 통해 User 객체를 검색합니다.  UserDetails가 User 객체를 UserDetailsService에 전달합니다.  인증에 성공하면 인증정보를 리턴하고, 실패하면 AuthenticationException을 던집니다.  AuthenticationManager는 완전한 인증 객체를 AuthenticationFilter에 반환합니다.  SecuriryContext에 인증 객체를 저장합니다.설정파일 작성아래와 같이 시큐리티 컨텍스트의 설정파일을 작성합니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http auto-config=\"true\" use-expressions=\"false\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"ROLE_USER\"/&gt;    &lt;/http&gt;    &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;네임스페이스를 security로 설정하여 security 스키마를 기본 태그로 사용합니다.http 태그는 경로를 매핑하여 필터체인의 실행여부를 설정합니다. auto-config 속성을 true로 설정하면 필터체인의 default 값이 설정됩니다. use-expressions 속성은 spEL 문법의 사용여부를 설정하는데 지금은 필요없으므로 false로 설정합니다.하위 태그로 intercept-url을 입력했는데, 예상하듯이 pattern에 해당하는 경로에 대한 인터셉터 역할을 합니다. access 속성은 인가권한을 나타냅니다.authentication-manager 태그는 AuthenticationManager를 설정합니다. 하위태그인 authentication-provider는 AuthenticationProvider를 설정합니다. UsernamePasswordAuthenticationFilter에서는 기본 프로바이더로 DaoAuthenticationProvider를 사용합니다. ref 속성을 통해 커스텀 프로바이더를 설정할 수도 있습니다.다음으로 UserDetailsService를 설정해야하는데, 위와 같이 user-service 태그를 설정하여 인메모리 방식으로 UserDetails를 가져올 수 있습니다. 나중에는 DB를 통해 인증을 할 예정이지만, 지금은 간단하게 테스트하기 위해 인메모리 방식으로 admin과 user라는 아이디를 통해 인증을 하도록 하겠습니다.스프링 시큐리티 4버전 이후로는 비밀번호를 암호화해야합니다. 하지만 user 태그의 password 속성에서 앞에 {noop}를 추가하면 암호화 과정을 생략하고 로그인을 테스트할 수 있습니다.저장후 톰캣을 재시작하고 localhost:8080/board에 접속하면 다음과 같이 스프링 시큐리티에서 제공하는 기본 로그인화면이 출력되는 것을 확인할 수 있습니다.admin 계정으로 로그인하면 403 에러가 발생하는 것을 확인할 수 있습니다.이유는 /board/** 경로에 대한 access 권한을 ROLE_USER로 설정했기 때문에 ROLE_ADMIN 권한을 가진 admin 계정은 해당 경로에 대한 인가를 받지 못했기 때문입니다.user 계정으로 접속하면 정상적으로 게시판이 출력되는 것을 확인할 수 있습니다. 로그아웃을 하려면 localhost:8080/logout에 접속하면 됩니다.권한 설정access 권한은 spEL 문법을 사용하여 설정할 수도 있습니다.            spEL      설명                  hasRole(‘ROLE_USER’)      ROLE_USER 권한을 가진 유저만 접근 가능              hasAnyRole(‘ROLE_USER’, ‘ROLE_ADMIN’)      ROLE_USER 또는 ROLE_ADMIN 권한을 가진 유저만 접근 가능              permitAll      모두 접근 가능              denyAll      모두 접근 불가              isAnonymous()      인증하지 않은 유저만 접근 가능              isRememberMe()      자동로그인 기능을 사용한 유저만 접근 가능              isAuthenticated()      인증한 유저만 접근 가능              isFullyAuthenticated()      인증을 하고, 자동 로그인 기능을 사용하지 않은 유저만 접근 가능      아래 코드와 같이 use-expressions 속성을 true로 설정하고 /board/** 경로에 대한 access를 isAuthenticated()로 설정하세요./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http auto-config=\"true\" use-expressions=\"true\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;    &lt;/http&gt;    &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;인증 설정다음과 같이 http 태그의 security 속성에 none 값을 설정하여 인증 예외 경로를 설정함으로써 인증을 하지 않을 수도 있습니다.이때 체인은 위에서 아래로 진행되기 때문에 인증 예외 경로를 제외한 나머지 경로는 가장 아래 필터가 적용됩니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/login\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/*/**\" access=\"isAuthenticated()\"/&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;basic authentication을 사용하려면 &lt;http-basic /&gt; 태그를 추가하면 됩니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/login\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/*/**\" access=\"isAuthenticated()\"/&gt;        &lt;http-basic /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;로그인 페이지시큐리티에서 제공하는 기본 로그인 페이지가 아니라 사용자가 구현한 로그인 페이지를 사용하려면 form-login 태그를 추가하면 됩니다. 해당 태그에도 다양한 속성이 존재합니다.            속성      설명                  username-parameter      username에 대한 파라미터명 설정 (기본값: username)              password-parameter      password에 대한 파라미터명 설정 (기본값: password)              login-page      로그인 페이지 url 설정              login-processing-url      로그인 처리 url 설정 (기본값: /login)              default-target-url      로그인 성공시 이동할 url 설정              authentication-failure-url      로그인 실패시 이동할 url 설정 (기본값: /login?error=1)              authentication-success-handler-ref      로그인 성공시 호출할 핸들러 이름 설정              authentication-failure-handler-ref      로그인 실패시 호출할 핸들러 이름 설정              always-use-default-target      로그인 성공시 항상 default-target-url로 이동할지 설정      표를 참고하여 로그인폼을 설정하겠습니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;        &lt;form-login            login-page=\"/login\"            login-processing-url=\"/login\"            username-parameter=\"email\"            password-parameter=\"password\" /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin@test.com\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user@test.com\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;지난번에 추가한 로그인폼을 사용하겠습니다. username이 이메일 형식이므로 user 태그의 name을 이메일형식으로 변경했습니다.LoginController를 수정해줍시다./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructorpublic class LoginController {        @GetMapping(\"/login\")    public void getLoginView() {}        @GetMapping(\"/logout\")    public String logout(HttpServletRequest request) {        HttpSession session = request.getSession(false);        if (session != null) {            session.invalidate();        }        return \"redirect:/\";    }}스프링에서 제공하는 로그인 로직을 사용하므로 /login 경로로 PostMapping되던 login 메소드를 제거했습니다.로그인 뷰에 csrf 토큰도 설정해야합니다. 폼태그 아래 다음 input 태그를 넣어주세요./src/main/webapp/WEB-INF/views/login.jsp...&lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\" /&gt;...로그아웃 설정시큐리티에서는 로그인 뿐만 아니라 로그아웃 기능 역시 제공합니다. 설정을 위해서는 logout 태그를 추가하며, 다음과 같은 속성을 설정할 수 있습니다.            속성      설명                  logout-url      로그아웃 페이지 url 설정              logout-success-url      로그아웃 성공시 이동할 url 설정 (기본값: /login?logout)              invalidate-session      로그아웃 성공시 세션의 연결을 끊을지 설정 (기본값: true)              delete-cookie      로그아웃 성공시 삭제할 쿠키 이름 설정              success-handler-ref      로그아웃 성공시 호출할 핸들러 이름 설정      표를 참고하여 로그아웃폼도 설정합니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;        &lt;form-login            login-page=\"/login\"            login-processing-url=\"/login\"            username-parameter=\"email\"            password-parameter=\"password\" /&gt;                    &lt;logout            logout-url=\"/logout\"            logout-success-url=\"/\"            delete-cookies=\"JSESSIONID\" /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;user-service&gt;                &lt;user name=\"admin@test.com\" password=\"{noop}admin\" authorities=\"ROLE_ADMIN\" /&gt;                &lt;user name=\"user@test.com\" password=\"{noop}user\" authorities=\"ROLE_USER\" /&gt;            &lt;/user-service&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;컨트롤러에서 logout 메소드를 지워주세요./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class LoginController {        @GetMapping(\"/login\")    public void getLoginView() {}}csrf의 disabled 기본값이 false 이므로 로그아웃 요청도 post로 해야하고 csrf 토큰도 설정해야합니다. getBoardList.jsp에 로그아웃 폼을 추가해주세요./src/main/webapp/WEB-INF/views/board/getBoardList.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp\"&gt;&lt;/script&gt;    &lt;%@ include file=\"./include/tailwindcss.jsp\" %&gt;    &lt;title&gt;게시글 목록&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;main&gt;    &lt;h1&gt;게시글 목록&lt;/h1&gt;    &lt;form method=\"post\" action=\"/logout\"&gt;        &lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\" /&gt;        &lt;input class=\"flex mr-auto mb-3 text-white text-sm sm:text-base bg-rose-500 border-0 py-1 px-3             sm:py-2 sm:px-6 focus:outline-none hover:bg-rose-600 rounded cursor-pointer\"            type=\"submit\" value=\"로그아웃\" /&gt;    &lt;/form&gt;    &lt;article&gt;    &lt;table&gt;        &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;&lt;/th&gt;                &lt;th scope=\"col\"&gt;카테고리&lt;/th&gt;                &lt;th scope=\"col\" class=\"w-full\"&gt;제목&lt;/th&gt;                &lt;th scope=\"col\"&gt;작성자&lt;/th&gt;                &lt;th scope=\"col\"&gt;등록일&lt;/th&gt;                &lt;th scope=\"col\"&gt;조회수&lt;/th&gt;        &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;            &lt;c:forEach items=\"${pageInfo.contentList}\" var=\"board\" step=\"1\" varStatus=\"status\"&gt;        &lt;tr&gt;            &lt;td&gt;${pageInfo.totalSize - pageInfo.first - status.index + 1}&lt;/td&gt;            &lt;td&gt;${board.category.category}&lt;/td&gt;            &lt;td&gt;&lt;a href=\"/board/${board.documentId}\"&gt;${board.title}&lt;/a&gt;&lt;/td&gt;            &lt;td&gt;${board.member.nickName}&lt;/td&gt;            &lt;td&gt;&lt;fmt:formatDate value=\"${board.createDate}\" pattern=\"yyyy-MM-dd\"/&gt;&lt;/td&gt;            &lt;td&gt;${board.readCount}&lt;/td&gt;        &lt;/tr&gt;        &lt;/c:forEach&gt;        &lt;/tbody&gt;    &lt;/table&gt;    &lt;/article&gt;    &lt;div class=\"flex mt-2 sm:mt-4 lg:w-2/3 w-full mx-auto\"&gt;    &lt;button class=\"write\" onClick=\"window.location='/board?act=write'\"&gt;쓰기&lt;/button&gt;    &lt;/div&gt;    &lt;%@ include file=\"./include/pageNav.jsp\" %&gt;&lt;/main&gt;&lt;/body&gt;&lt;/html&gt;로그인후 상단에 로그아웃을 클릭하면 로그아웃 처리가 되고 메인페이지로 이동하는 것을 확인할 수 있습니다.DB 연결이번에는 인메모리 방식의 로그인이 아니라 DB를 조회하여 로그인 처리를 해보겠습니다.authentication-provider 태그 아래 jdbc-user-service 태그를 추가합니다. 해당태그에서 data-source-ref, users-by-username-query, authorities-by-username-query 속성을 설정해야합니다.data-source-ref 속성은 DB의 데이터소스의 id를 입력합니다. 데이터소스는 root-context.xml 파일에 dataSource라는 id로 빈을 생성했습니다.users-by-username-query 속성은 유저의 정보를 가져오는 쿼리를 설정합니다. username, password, enabled를 하나의 튜플로 하여 유저정보를 가져옵니다.authorities-by-username-query 속성은 유저의 권한을 가져오는 쿼리를 설정합니다. username, authority를 하나의 튜플로 하여 권한정보를 가져옵니다.password를 암호화하는 인코더를 추가할 필요도 있습니다. 스프링에서 제공하는 BCryptPasswordEncoder를 빈으로 추가하고 authentication-provider 태그 아래 password-encoder 태그를 추가합니다. 해당 태그의 ref 속성값으로 인코더 이름을 입력합니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;beans:bean id =\"bcryptPasswordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"/&gt;        &lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;    &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;    &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;    &lt;form-login        login-page=\"/login\"        login-processing-url=\"/login\"        username-parameter=\"email\"        password-parameter=\"password\" /&gt;            &lt;logout        logout-url=\"/logout\"        logout-success-url=\"/\"        delete-cookies=\"JSESSIONID\" /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider&gt;            &lt;jdbc-user-service                 data-source-ref=\"dataSource\"                 users-by-username-query=\"select email, password, 1 enabled from member where email=?\"                authorities-by-username-query=\"select m.email, g.group_name from member m join member_group g on m.group_id = g.group_id where m.email=?\" /&gt;            &lt;password-encoder ref=\"bcryptPasswordEncoder\"/&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;암호화된 비밀번호를 비교하기때문에 현재 DB에 저장되어 있는 계정으로는 로그인할 수 없습니다. 새로운 계정을 만들도록 하겠습니다. 그전에 우선 MemberServiceImpl 객체에서 regist 메소드를 수정하도록 하겠습니다./kro/rubisco/service/impl/MemberServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.MemberDAO;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;@Service@Transactional(readOnly = true)public class MemberServiceImpl implements MemberService {    private final MemberDAO memberDAO;    private final PasswordEncoder bcryptPasswordEncoder;    public MemberServiceImpl(SqlSession sqlSession, PasswordEncoder bcryptPasswordEncoder) {        this.memberDAO = sqlSession.getMapper(MemberDAO.class);        this.bcryptPasswordEncoder = bcryptPasswordEncoder;    }        @Override    public void regist(MemberDTO member) throws Exception {        member.setPassword(bcryptPasswordEncoder.encode(member.getPassword()));        memberDAO.create(member);    }    @Override    public MemberDTO read(Long memberId) throws Exception {        return memberDAO.read(memberId);    }        @Override    public MemberDTO read(String email) throws Exception {        return memberDAO.getMemberByEmail(email);    }    @Override    public void modify(MemberDTO member) throws Exception {        memberDAO.update(member);    }    @Override    public void remove(Long memberId) throws Exception {        memberDAO.delete(memberId);    }    @Override    public List&lt;MemberDTO&gt; listAll() throws Exception {        return memberDAO.listAll();    }    @Override    public MemberDTO login(LoginDTO loginForm) throws Exception {        return memberDAO.login(loginForm);    }}bcryptPasswordEncoder를 생성자 주입하고 계정을 등록할 때 password를 암호화하여 등록하도록 수정했습니다.회원가입폼에 scrf 토큰도 입력해주고 톰캣을 재부팅합니다./src/main/webapp/WEB-INF/views/member/signUpForm.jsp...&lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\" /&gt;...이제 새로 계정을 만들어 로그인하면 됩니다.시큐리티 컨텍스트 사용스프링 시큐리티를 통해 로그인하면 JSP에서 security taglib을 사용하여 로그인 인증을 확인하거나 세션 정보를 활용할 수 있습니다.우선 spring-security-taglibs를 의존성 추가합니다.pom.xml...    &lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-taglibs --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;        &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;        &lt;version&gt;5.7.3&lt;/version&gt;    &lt;/dependency&gt;...jsp 파일에 다음 태그립을 추가함하면 해당 시큐리티 태그를 사용할 수 있습니다. 메인페이지에 인증을 확인하고 세션에서 사용자 정보를 가져와보겠습니다. 그전에 security-context.xml 파일에서 메인페이지 경로에서 시큐리티를 사용하도록 해당 코드를 제거합니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;http pattern=\"/\" security=\"none\"&gt;&lt;/http&gt;메인 페이지 뷰를 다음과 같이 수정합니다./src/main/webapp/WEB-INF/views/board/getBoardList.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    Hello world!  &lt;/h1&gt;&lt;sec:authorize access=\"isAuthenticated()\"&gt;    &lt;sec:authentication property=\"principal\" var=\"principal\" /&gt;    &lt;P&gt;${principal}&lt;/P&gt;    &lt;form action=\"&lt;c:url value='/logout' /&gt;\" method=\"post\"&gt;        &lt;sec:csrfInput/&gt;        &lt;button type=\"submit\"&gt;로그아웃&lt;/button&gt;    &lt;/form&gt;&lt;/sec:authorize&gt;&lt;/body&gt;&lt;/html&gt;헤더에 시큐리티 taglib을 추가하면 authorize 태그를 통해 인증여부를 확인할 수 있습니다. access 속성은 spEL 문법을 사용하며, 위에서 설명한 내용과 같습니다.authentication 태그를 통해서는 유저정보를 담은 principal 객체를 가져올 수 있습니다.해당 principal 객체는 시큐리티에서 제공하는 UserDetails 인터페이스의 구현체입니다. 시큐리티에서 기본적으로 제공하는 principal 객체로는 제한적인 정보만 가져올 수 있습니다. 아이디, 패스워드, 권한 이외에 다른 정보를 가져오고 싶다면 UserDetailsServices 인터페이스를 구현하여 참조하는 방식을 사용하면 됩니다.UserDetailsService 인터페이스 구현우선 UserDetails 인터페이스를 구현해야합니다. 모든 기능을 구현하지 않고 시큐리티에서 구현한 User 객체를 상속받고 MemberDTO를 멤버변수로 추가하겠습니다./kro/rubisco/auth/CustomUser.javapackage kro.rubisco.auth;import java.util.ArrayList;import java.util.Arrays;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import kro.rubisco.dto.MemberDTO;import lombok.Getter;public class CustomUser extends User {        @Getter    private MemberDTO member;        public CustomUser(MemberDTO member) {        super(            member.getEmail(),             member.getPassword(),             new ArrayList&lt;GrantedAuthority&gt;(                Arrays.asList(                    new SimpleGrantedAuthority(member.getGroup().getGroupName())                )            )        );        this.member = member;    }}다음으로 UserDetailsService 인터페이스를 구현합니다. username을 매개변수로 받는 loadUserByUsername 메소드를 구현하면 됩니다. 해당 메소드는 UserDetails 객체를 반환합니다. 그러므로 username을 통해 DB에서 유저정보를 가져오고, 해당 정보를 CustomUser에 주입하여 으로써 시큐리티 컨텍스트로 member 객체를 전달할 수 있습니다./kro/rubisco/auth/CustomUserDetailsService.javapackage kro.rubisco.auth;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.Setter;public class CustomUserDetailsService implements UserDetailsService {    @Setter(onMethod_ = @Autowired)    private MemberService memberService;        @Override    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {        try {            MemberDTO member = memberService.read(email);            return member == null ? null : new CustomUser(member);        } catch (Exception e) {            e.printStackTrace();            return null;        }     }}@Setter를 통해 memberService의 setter를 생성하고 해당 setter가 @Autowired를 통해 memberService를 setter주입하도록 선언합니다. 주입받은 memberService를 통해 member 객체를 가져올 수 있으며, 해당 객체를 주입하여 CustomUser 객체를 생성할 수 있습니다. 이 객체는 UserDetails 인터페이스의 구현체이므로 자동으로 캐스팅되어 리턴이 가능합니다.이제 시큐리티 컨텍스트를 수정해주겠습니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;beans:bean id =\"bcryptPasswordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\" /&gt;    &lt;beans:bean id=\"customUserDetailsService\" class=\"kro.rubisco.auth.CustomUserDetailsService\" /&gt;        &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;        &lt;form-login            login-page=\"/login\"            login-processing-url=\"/login\"            username-parameter=\"email\"            password-parameter=\"password\" /&gt;                    &lt;logout            logout-url=\"/logout\"            logout-success-url=\"/\"            delete-cookies=\"JSESSIONID\" /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider user-service-ref=\"customUserDetailsService\"&gt;            &lt;password-encoder ref=\"bcryptPasswordEncoder\"/&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;customUserDetailsService라는 이름으로 빈을 설정하여 authentication-provider의 user-service-ref 속성값으로 입력해줍니다.JSP에서 member 객체에 접근하려면 principal.member로 접근하면 됩니다./src/main/webapp/WEB-INF/views/home.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    Hello world!  &lt;/h1&gt;&lt;sec:authorize access=\"isAuthenticated()\"&gt;    &lt;sec:authentication property=\"principal.member\" var=\"member\" /&gt;    &lt;P&gt;${member.nickName}님, 환영합니다.&lt;/P&gt;    &lt;form action=\"&lt;c:url value='/logout' /&gt;\" method=\"post\"&gt;        &lt;sec:csrfInput/&gt;        &lt;button type=\"submit\"&gt;로그아웃&lt;/button&gt;    &lt;/form&gt;&lt;/sec:authorize&gt;&lt;/body&gt;&lt;/html&gt;remember-me 구현마지막으로 로그인상태를 유지하는 remember-me 기능을 구현해보겠습니다.remember-me는 토큰을 생성하여 DB에 저장하고, 클라이언트의 쿠키를 통해 이를 검증하는 방식으로 진행됩니다.기능구현을 위해서는 RememberMeAuthenticationFilter, TokenBasedRememberMeServices, RememberMeAuthenticationProvider의 구현이 필요하며, 시큐리티는 해당 구현체를 기본적으로 제공하고 있습니다.RememberMeAuthenticationFilter는 클라이언트 요청에서 remember-me 쿠키가 있는지 확인하고, TokenBasedRememberMeServices는 PersistentTokenRepository를 통해 토큰을 조회하여 RememberMeAuthenticationProvider를 통해 인증을 수행합니다.기능구현을 위해서는 우선 DBeaver를 통해 테이블 생성이 필요합니다.CREATE TABLE persistent_logins (    username varchar(64) not null,    series varchar(64) not null,    token varchar(64) not null,    last_used timestamp not null,    PRIMARY KEY (series));해당 테이블에서 PersistentTokenRepository를 통해 토큰을 조회합니다.이제 시큐리티 컨텍스트에서 remember-me 태그를 통해 RememberMeAuthenticationFilter를 설정하면 됩니다.remember-me-cookie 속성으로 쿠키이름을 설정할 수 있고, remember-me-parameter 속성으로 파라미터명을 설정할 수 있습니다.token-repository-ref 속성은 PersistentTokenRepository 구현체를, services-ref 속성은 RememberMeServices 구현체를 설정합니다.token-validity-seconds는 쿠키가 지속되는 시간을, data-source-ref는 DataSource를 설정합니다./src/main/webapp/WEB-INF/spring/security-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/security\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/security     http://www.springframework.org/schema/security/spring-security.xsd\"&gt;        &lt;beans:bean id =\"bcryptPasswordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\" /&gt;    &lt;beans:bean id=\"customUserDetailsService\" class=\"kro.rubisco.auth.CustomUserDetailsService\" /&gt;        &lt;http pattern=\"/resources/**\" security=\"none\"&gt;&lt;/http&gt;    &lt;http auto-config=\"true\"&gt;        &lt;intercept-url pattern=\"/board/**\" access=\"isAuthenticated()\"/&gt;        &lt;form-login            login-page=\"/login\"            login-processing-url=\"/login\"            username-parameter=\"email\"            password-parameter=\"password\" /&gt;                    &lt;logout            logout-url=\"/logout\"            logout-success-url=\"/\"            delete-cookies=\"JSESSIONID, remember-me\" /&gt;                    &lt;remember-me             token-validity-seconds=\"604800\"             data-source-ref=\"dataSource\" /&gt;    &lt;/http&gt;        &lt;authentication-manager&gt;        &lt;authentication-provider user-service-ref=\"customUserDetailsService\"&gt;            &lt;password-encoder ref=\"bcryptPasswordEncoder\"/&gt;        &lt;/authentication-provider&gt;    &lt;/authentication-manager&gt;&lt;/beans:beans&gt;이제 로그인시 remember-me를 체크하여 로그인하면 브라우저를 껏다가 다시 켜도 로그인 상태를 유지하는 것을 확인할 수 있습니다.소스코드  security.zip",
        "url": "/java/spring-legacy-security"
    }
    ,
    
    "java-spring-legacy-filter-and-interceptor": {
        "title": "스프링 레거시(Spring legacy) - 필터와 인터셉터",
            "author": "rubisco",
            "category": "",
            "content": "공통관심사(Cross-cutting Concerns)이전에 스프링의 특징으로 AOP에 대해서 설명한 적이 있습니다. 객체 지향 프로그래밍(Object Oriented Programming, OOP)을 하다보면 단일 책임 원칙(Single Responsibility Principle, SRP)에 따라 클래스를 분리하게 되지만, 클래스를 설계하다보면 공통적인 부분이 존재하게 됩니다. 예를 로그인 기능을 구현한다면 컨트롤러마다 로그인 기능을 작성하게 됩니다. 이렇게 중복되는 코드를 공통 관심사(Cross-cutting Concerns)라고 합니다.스프링에는 이러한 공통 관심사를 처리하기 위한 AOP를 제공하지만, 웹어플리케이션의 경우 AOP 보다는 Filter 또는 Interceptor에서 공통 관심사를 처리합니다.3개의 인터페이스는 공통관심사를 처리한다는 점에서 같은 역할을 하지만, 약간의 차이점이 존재합니다.Filter는 Servlet Container 에 존재하며 DispatcherServlet의 호출 전후로 실행됩니다.Interceptor는 Spring Container에 존재하며, Controller의 호출 전후로 실행됩니다.AOP는 Interceptor와 마찬가지로 Spring Container에서 실행되지만 Servlet에서 실행되는 Filter, Interceptor와 달리 AOP는 Proxy를 통해 실행됩니다.정리하면 클라이언트 요청이 들어오면 Filter -&gt; Interceptor -&gt; AOP -&gt; Interceptor -&gt; Filter 순서로 실행됩니다.서블릿 필터(Servlet Filter)필터는 Filter 인터페이스를 상속받아 구현하고 web.xml 파일에 등록하여 적용할 수 있습니다.Filter 인터페이스는 다음과 같습니다.javax.servlet.Filterpublic interface Filter {    public void init(FilterConfig filterConfig) throws ServletException;    public void doFilter ( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException;    public void destroy();}init는 필터를 초기화하는 메소드 입니다. 서블릿 컨테이너가 생성될 때 호출됩니다. FilterConfig 객체를 통해 초기 파라미터를 설정할 수 있습니다.doFilter는 클라이언트의 요청마다 호출됩니다. ServletRequest와 ServletResponse를 매개변수로 받으며, HTTP 요청에 처리가 필요하다면 HttpServletRequest와 HttpServletResponse로 캐스팅하여 처리하면 됩니다.destroy는 서블릿 컨테이너가 종료될 때 호출됩니다.로그인 필터를 다음과 같이 구현해보겠습니다./kro/rubisco/filter/LoginCheckFilter.javapackage kro.rubisco.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginCheckFilter implements Filter {    @Override    public void init(FilterConfig filterConfig) throws ServletException {}    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)            throws IOException, ServletException {                HttpServletRequest httpRequest = (HttpServletRequest) request;        HttpServletResponse httpResponse = (HttpServletResponse) response;                HttpSession session = httpRequest.getSession(false);                if(session == null || session.getAttribute(\"member\") == null) {            httpResponse.sendRedirect(\"/login\");            return;        }                chain.doFilter(request, response);            }    @Override    public void destroy() {}}클라이언트 요청(request)에서 세션을 조회하여 member 객체가 있는지 확인하고 없다면 HttpServletResponse 객체의  sendRedirect 메소드를 통해 /login 경로로 리다이렉트 하도록 응답(response)을 보냅니다. 인증된 상태라면 세션에 member 객체가 있어서 필터를 통과하게 될 것이고, FilterChain 객체의 doFilter 메소드를 통해 다음 필터를 실행할 수 있도록 합니다.구현한 로그인 필터를 web.xml 파일에 등록하도록 하겠습니다. 이전에 컨트롤러를 작성할 때, 인코딩과 관련하여 필터를 등록한 적이 있습니다.src/main/webapp/WEB-INF/web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;\t&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;\t&lt;context-param&gt;\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\t\t&lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;\t&lt;/context-param&gt;\t\t&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;\t&lt;listener&gt;\t\t&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\t&lt;/listener&gt;\t&lt;!-- Processes application requests --&gt;\t&lt;servlet&gt;\t\t&lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;\t\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\t\t&lt;init-param&gt;\t\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\t\t\t&lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;\t\t&lt;/init-param&gt;\t\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\t&lt;/servlet&gt;\t\t\t&lt;servlet-mapping&gt;\t\t&lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;\t\t&lt;url-pattern&gt;/&lt;/url-pattern&gt;\t&lt;/servlet-mapping&gt;\t\t&lt;filter&gt;\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\t\t&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\t\t&lt;init-param&gt;\t\t\t&lt;param-name&gt;encoding&lt;/param-name&gt;\t\t\t&lt;param-value&gt;UTF-8&lt;/param-value&gt;\t\t&lt;/init-param&gt;\t&lt;/filter&gt;\t&lt;filter&gt;\t\t&lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;\t\t&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;\t&lt;/filter&gt;\t&lt;filter&gt;\t\t&lt;filter-name&gt;loginCheckFilter&lt;/filter-name&gt;\t\t&lt;filter-class&gt;kro.rubisco.filter.LoginCheckFilter&lt;/filter-class&gt;\t&lt;/filter&gt;\t&lt;filter-mapping&gt;\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\t\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\t&lt;/filter-mapping&gt;\t&lt;filter-mapping&gt;\t\t&lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;\t\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\t&lt;/filter-mapping&gt;\t&lt;filter-mapping&gt;\t\t&lt;filter-name&gt;loginCheckFilter&lt;/filter-name&gt;\t\t&lt;url-pattern&gt;/board/*&lt;/url-pattern&gt;\t&lt;/filter-mapping&gt;&lt;/web-app&gt;loginCheckFilter를 추가하고 /board/* 패턴에 매핑했습니다.localhost:8080/board에 접속하면 필터를 통해 로그인 페이지로 이동하는 것을 확인할 수 있습니다. 로그인을 한 후 다시 /board에 접속하면 정상적으로 게시판이 출력됩니다.스프링 인터셉터(Spring Interceptor)이번에는 인터셉터를 통해 로그인 인증을 해보겠습니다. web.xml에 등록한 필터를 지워서 원래 상태로 되돌려주세요.Interceptor 인터페이스는 다음과 같습니다.org.springframework.web.servlet.HandlerInterceptorpublic interface HandlerInterceptor {    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\t\t\tthrows Exception {\t\treturn true;\t}    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\t}    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\t\t\t@Nullable Exception ex) throws Exception {\t}}서블릿 필터와 달리 스프링 인터셉터는 호출시점이 3개로 분리되어 있습니다.preHandle 메소드는 컨트롤러 호출전에 호출되고, postHandle 메소드는 컨트롤러 호출후에 호출됩니다.afterCompletion 메소드는 뷰가 렌더링 된 이후에 호출됩니다.이제 HandlerInterceptor 인터페이스를 상속받은 LoginInterceptor를 구현해 보겠습니다./kro/rubisco/interceptor/LoginInterceptor.javapackage kro.rubisco.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;@Componentpublic class LoginInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(        HttpServletRequest request,         HttpServletResponse response,         Object handler    ) throws Exception {                HttpSession session = request.getSession(false);                if(session == null || session.getAttribute(\"member\") == null) {            response.sendRedirect(\"/login\");            return false;        }                return true;    }}@Component 어노테이션을 통해 빈으로 등록될 수 있도록 하고, preHandle 메소드를 Override하여 로그인 인증을 구현합니다. 필터와 동일하게 클라이언트의 요청으로부터 세션을 조회하여 member 객체가 있는지 확인한 후 없다면 HttpServletResponse 객체의  sendRedirect 메소드를 통해 /login 경로로 리다이렉트 하도록 응답(response)을 작성합니다. 또한 false를 리턴하여 컨트롤러를 호출하지 않고 클라이언트로 응답을 보내어 /login 경로로 리다이렉트되도록 합니다.이제 servlet-context.xml 파일에 interceptor 패키지를 스캔할 수 있도록 등록하고, @Component 어노테이션을 통해 등록된 loginInterceptor 객체를 /board/** 경로에 매핑해주도록 합니다./src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/mvc\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:beans=\"http://www.springframework.org/schema/beans\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txsi:schemaLocation=\"http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\t\thttp://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\t\thttp://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;\t&lt;!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure --&gt;\t\t&lt;!-- Enables the Spring MVC @Controller programming model --&gt;\t&lt;annotation-driven /&gt;\t&lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory --&gt;\t&lt;resources mapping=\"/resources/**\" location=\"/resources/\" /&gt;\t&lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;\t&lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\t\t&lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt;\t\t&lt;beans:property name=\"suffix\" value=\".jsp\" /&gt;\t&lt;/beans:bean&gt;\t\t&lt;beans:bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;\t\t&lt;beans:property name=\"exceptionMappings\"&gt;\t\t\t&lt;beans:props&gt;\t\t\t\t&lt;beans:prop key=\"TestException\"&gt;error/testException&lt;/beans:prop&gt;\t\t\t&lt;/beans:props&gt;\t\t&lt;/beans:property&gt;\t\t&lt;beans:property name=\"defaultErrorView\" value=\"error/error\" /&gt;\t&lt;/beans:bean&gt;\t&lt;context:component-scan base-package=\"kro.rubisco.controller\" /&gt;\t&lt;context:component-scan base-package=\"kro.rubisco.interceptor\" /&gt;\t\t&lt;interceptors&gt;\t\t&lt;interceptor&gt;\t\t\t&lt;mapping path=\"/board/**\" /&gt;\t\t\t&lt;beans:ref bean=\"loginInterceptor\" /&gt;\t\t&lt;/interceptor&gt;\t&lt;/interceptors&gt;\t&lt;/beans:beans&gt;localhost:8080/board에 접속하면 인터셉터를 통해 로그인 페이지로 이동하는 것을 확인할 수 있습니다. 로그인을 한 후 다시 /board에 접속하면 정상적으로 게시판이 출력됩니다.",
        "url": "/java/spring-legacy-filter-and-interceptor"
    }
    ,
    
    "programmers-programmers-133499": {
        "title": "[1단계][133499] 옹알이(2)",
            "author": "rubisco",
            "category": "",
            "content": "문제풀이정규식과 filter를 조합하여 발음가능한 단어를 걸러내고, 그 개수를 출력하면 됩니다.function solution(babbling) {    return babbling.filter(s=&gt;{        const arr = s.match(/(aya|ye|woo|ma)(?!\\/\\1)+/g);        if(!arr || arr.join('') !== s) return false;        for(let i = 0, length = arr.length; i &lt; length; i++) {            if(i &amp;&amp; arr[i] === arr[i-1]) return false;        }        return true;    }).length;}우선 단어 s에서 match를 통해 발음가능한 단어의 배열을 추출합니다. 해당 배열을 join을 통해 합쳤을 경우 처음 단어 s와 동일하다면 해당 단어는 발음가능한 단어로 구성됩니다. 그러므로 동일하지 않는 경우 false를 반환하여 걸러냅니다.s와 동일하더라도 동일한 단어를 연속해서 발음하지 못하므로, for문을 통해 i와 i-1번째 단어를 비교하여 동일한 경우 false를 반환하여 걸러내도록 합니다.해당 필터를 통과한 경우 true를 반환하여 배열에 넣어줍니다.필터를 거친 배열에서 요소의 개수가 정답이 됩니다.",
        "url": "/programmers/programmers-133499"
    }
    ,
    
    "java-spring-legacy-cookie-and-session": {
        "title": "스프링 레거시(Spring legacy) - 쿠키와 세션",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 로그인 기능을 구현하기에 앞서 쿠키와 세션에 대하여 알아보겠습니다.HTTP 특징HTTP 프로토콜의 경우 서버가 클라이언트의 요청(request)을 받으면클라이언트로 응답(response)를 보낸 후 연결을 끊어버립니다.이러한 비연결지향적 특성으로 인하여 서버는 클라이언트의 이전 요청을 알지 못하며, 클라이언트의 상태정보를 유지하기 위해서는 요청을 보낼때마다 인증과정을 거쳐야합니다.쿠키와 세션은 이러한 단점을 보완하여 클라이언트의 상태를 유지하기위해 사용됩니다.쿠키(Cookie)쿠키는 클라이언트의 로컬에 저장되는 key와 value로 이루어진 작은 데이터 파일입니다. 서버가 Set-Cookie 응답 헤더를 통해 클라이언트의 쿠키 저장소에 쿠키를 저장하고, 클라이언트는 해당 서버에 요청을 보낼때 쿠키 저장소에서 쿠키를 조회하여 Cookie 요청 헤더를 통해 서버에 쿠키 데이터를 전달합니다.쿠키의 종류쿠키에는 영속 쿠키와 세션 쿠키가 있습니다.영속 쿠키의 경우 만료 날짜를 입력하여 해당 날짜까지 쿠키를 유지하고, 세션 쿠키의 경우 만료 날짜를 생략하여 브라우저 종료시까지만 쿠키를 유지합니다.쿠키의 생성과 조회로그인시 서버에서 닉네임 쿠키를 생성해보도록 하겠습니다.우선 로그인 기능을 위해 memberMapper에 login 쿼리를 추가합니다. 이메일과 패스워드가 동일한 튜플을 가져옵니다.memberMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.MemberDAO\"&gt;&lt;resultMap id=\"getMember\" type=\"MemberDTO\"&gt;    &lt;association property=\"group\" column=\"group_id\" select=\"getGroup\" /&gt;&lt;/resultMap&gt;&lt;insert id=\"create\"&gt;insert into member (password, email, name, nick_name, group_id)values (#{password}, #{email}, #{name}, #{nickName}, #{groupId})&lt;/insert&gt;&lt;select id=\"read\" resultMap=\"getMember\"&gt;select * from member where member_id = #{memberId}&lt;/select&gt;&lt;select id=\"getMemberByEmail\" resultMap=\"getMember\"&gt;select * from member where email = #{email}&lt;/select&gt;&lt;select id=\"getGroup\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id=#{groupId}&lt;/select&gt;&lt;update id=\"update\"&gt;update member set password=#{password},    email=#{email},     name=#{name},     nick_name= #{nickName},where member_id = #{memberId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from member where member_id = #{memberId} &lt;/delete&gt;&lt;select id=\"listAll\" resultMap=\"getMember\"&gt;&lt;![CDATA[ select * from member where m.member_id &gt; 0 order by m.member_id desc ]]&gt;&lt;/select&gt;&lt;select id=\"login\" resultMap=\"getMember\"&gt;select * from member where email = #{email} and password = #{password}&lt;/select&gt;&lt;/mapper&gt;memberDAO에 login 메소드를 추가합니다./kro/rubisco/dao/MemberDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;@Mapperpublic interface MemberDAO {    public void create(MemberDTO member) throws Exception;        public MemberDTO read(Long memberId) throws Exception;        public MemberDTO getMemberByEmail(String email) throws Exception;    public void update(MemberDTO member) throws Exception;    public void delete(Long memberId) throws Exception;    public List&lt;MemberDTO&gt; listAll() throws Exception;        public MemberDTO login(LoginDTO loginForm) throws Exception;}서비스에 login 메소드를 추가하고 구현합니다./kro/rubisco/service/MemberService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;public interface MemberService {          public void regist(MemberDTO member) throws Exception;      public MemberDTO read(Long memberId) throws Exception;            public MemberDTO read(String email) throws Exception;      public void modify(MemberDTO member) throws Exception;      public void remove(Long memberId) throws Exception;      public List&lt;MemberDTO&gt; listAll() throws Exception;            public MemberDTO login(LoginDTO loginForm) throws Exception;}/kro/rubisco/service/impl/MemberServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.MemberDAO;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;@Service@Transactional(readOnly = true)public class MemberServiceImpl implements MemberService {    private final MemberDAO memberDAO;        @Autowired    public MemberServiceImpl(SqlSession sqlSession) {        this.memberDAO = sqlSession.getMapper(MemberDAO.class);    }        @Override    public void regist(MemberDTO member) throws Exception {        memberDAO.create(member);    }    @Override    public MemberDTO read(Long memberId) throws Exception {        return memberDAO.read(memberId);    }        @Override    public MemberDTO read(String email) throws Exception {        return memberDAO.getMemberByEmail(email);    }    @Override    public void modify(MemberDTO member) throws Exception {        memberDAO.update(member);    }    @Override    public void remove(Long memberId) throws Exception {        memberDAO.delete(memberId);    }    @Override    public List&lt;MemberDTO&gt; listAll() throws Exception {        return memberDAO.listAll();    }    @Override    public MemberDTO login(LoginDTO loginForm) throws Exception {        return memberDAO.login(loginForm);    }}로그인 정보를 전달하기위한 LoginDTO를 작성합니다./kro/rubisco/dto/LoginDTO.javapackage kro.rubisco.dto;import javax.validation.constraints.NotBlank;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class LoginDTO {    @NotBlank(message = \"이메일을 입력하세요.\")    private String email;        @NotBlank(message = \"패스워드를 입력하세요.\")    private String password;}로그인 요청을 매핑하기위한 LoginController를 작성합니다./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import java.util.Locale;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import javax.validation.Valid;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/login\")public class LoginController {        private final MessageSource messageSource;    private final MemberService memberService;        @GetMapping()    public void getLoginView() {}    @PostMapping()    public String login(        @Valid @ModelAttribute LoginDTO loginForm,        BindingResult bindingResult,        Locale locale,        HttpServletResponse response    ) throws Exception {                MemberDTO member = memberService.login(loginForm);                if(member == null) {            bindingResult.reject(\"loginFail\", \"아이디 또는 비밀번호가 일치하지 않습니다.\");        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"login\", messageSource, locale);        }                if(member != null) {            Cookie nickNameCookie = new Cookie(\"nickName\", member.getNickName());            response.addCookie(nickNameCookie);        }                return \"redirect:/\";    }}검증에 대한 설명은 지난번 글을 참고하고, 검증을 통과하면 Cookie 객체를 생성하여 HttpServletResponse 객체의 addCookie 메소드를 통해 응답 헤더에 Set-Cookie를 추가해줍니다.이제 로그인폼 템플릿을 추가해주세요./src/main/webapp/WEB-INF/views/login.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp\"&gt;&lt;/script&gt;    &lt;title&gt;게시글 목록&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;main&gt;    &lt;div class=\"flex min-h-full items-center justify-center py-12 px-4 sm:px-6 lg:px-8\"&gt;        &lt;div class=\"w-full max-w-md space-y-8\"&gt;            &lt;div&gt;                  &lt;img class=\"mx-auto h-12 w-auto\" src=\"https://tailwindui.com/img/logos/mark.svg?color=indigo&amp;shade=600\" alt=\"Your Company\"&gt;                  &lt;h2 class=\"mt-6 text-center text-3xl font-bold tracking-tight text-gray-900\"&gt;로그인&lt;/h2&gt;                  &lt;p class=\"mt-2 text-center text-sm text-gray-600 text-rose-500\"&gt;                    ${errors.globalMessage}                  &lt;/p&gt;            &lt;/div&gt;            &lt;form class=\"mt-8 space-y-6\" action=\"#\" method=\"POST\"&gt;                  &lt;input type=\"hidden\" name=\"remember\" value=\"true\"&gt;                  &lt;div class=\"-space-y-px rounded-md shadow-sm\"&gt;                    &lt;div&gt;                          &lt;label for=\"email\" class=\"sr-only\"&gt;Email address&lt;/label&gt;                          &lt;input id=\"email\" name=\"email\" type=\"email\" autocomplete=\"email\" required class=\"relative block w-full appearance-none rounded-none rounded-t-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:z-10 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm\" placeholder=\"Email\"&gt;                    &lt;/div&gt;                    &lt;div&gt;                          &lt;label for=\"password\" class=\"sr-only\"&gt;Password&lt;/label&gt;                          &lt;input id=\"password\" name=\"password\" type=\"password\" autocomplete=\"current-password\" required class=\"relative block w-full appearance-none rounded-none rounded-b-md border border-gray-300 px-3 py-2 text-gray-900 placeholder-gray-500 focus:z-10 focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm\" placeholder=\"Password\"&gt;                    &lt;/div&gt;                  &lt;/div&gt;                      &lt;div class=\"flex items-center justify-between\"&gt;                    &lt;div class=\"flex items-center\"&gt;                          &lt;input id=\"remember-me\" name=\"remember-me\" type=\"checkbox\" class=\"h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500\"&gt;                          &lt;label for=\"remember-me\" class=\"ml-2 block text-sm text-gray-900\"&gt;Remember me&lt;/label&gt;                    &lt;/div&gt;                        &lt;div class=\"text-sm\"&gt;                          &lt;a href=\"#\" class=\"font-medium text-indigo-600 hover:text-indigo-500\"&gt;Forgot your password?&lt;/a&gt;                    &lt;/div&gt;                  &lt;/div&gt;                      &lt;div&gt;                    &lt;button type=\"submit\" class=\"group relative flex w-full justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2\"&gt;                          &lt;span class=\"absolute inset-y-0 left-0 flex items-center pl-3\"&gt;                            &lt;!-- Heroicon name: mini/lock-closed --&gt;                            &lt;svg class=\"h-5 w-5 text-indigo-500 group-hover:text-indigo-400\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\"&gt;                                  &lt;path fill-rule=\"evenodd\" d=\"M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z\" clip-rule=\"evenodd\" /&gt;                            &lt;/svg&gt;                          &lt;/span&gt;                          로그인                    &lt;/button&gt;                  &lt;/div&gt;            &lt;/form&gt;          &lt;/div&gt;    &lt;/div&gt;&lt;/main&gt;&lt;/body&gt;&lt;/html&gt;이제 쿠키 정보를 조회하기위해 HomeController를 추가해주세요. HttpServletRequest 객체의 getCookies 메소드를 통해 쿠키를 조회할 수도 있지만, @CookieValue 어노테이션을 통해 간단하게 쿠키를 조회할 수 있습니다./kro/rubisco/controller/HomeController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HomeController {    @RequestMapping()    public String home(@CookieValue(name = \"nickName\", required = false) String nickName, Model model) {        model.addAttribute(\"nickName\", nickName);        return \"home\";    }}쿠키를 조회할 템플릿을 작성합니다./src/main/webapp/WEB-INF/views/home.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    Hello world!  &lt;/h1&gt;&lt;P&gt;&lt;c:if test=\"${nickName ne null}\"&gt;${nickName}님, 환영합니다.&lt;/c:if&gt;&lt;/P&gt;&lt;/body&gt;&lt;/html&gt;localhost:8080/login 으로 이동하면 로그인폼이 출력되고, 정상적으로 로그인되면 메인페이지로 리다이렉트되어 닉네임이 출력되는 것을 확인할 수 있습니다.이 경우 만료 날짜를 입력하지 않았으므로 세션 쿠키가 되므로, 브라우저를 닫았다가 다시 열게 되면 쿠기가 존재하지 않습니다. 영속 쿠키로 만들기 위해서는 쿠키에 setMaxAge 메소드를 통해 만료 날짜를 입력해줍니다. 매개변수는 초단위를 기준으로 입력합니다. 예를 들어 아래 코드의 경우 일주일간 쿠키를 유지합니다./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import java.util.Locale;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import javax.validation.Valid;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/login\")public class LoginController {        private final MessageSource messageSource;    private final MemberService memberService;        @GetMapping()    public void getLoginView() {}    @PostMapping()    public String login(        @Valid @ModelAttribute LoginDTO loginForm,        BindingResult bindingResult,        Locale locale,        HttpServletResponse response    ) throws Exception {                MemberDTO member = memberService.login(loginForm);                if(member == null) {            bindingResult.reject(\"loginFail\", \"아이디 또는 비밀번호가 일치하지 않습니다.\");        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"login\", messageSource, locale);        }                if(member != null) {            Cookie nickNameCookie = new Cookie(\"nickName\", member.getNickName());            nickNameCookie.setMaxAge(60*60*24*7);            response.addCookie(nickNameCookie);        }                return \"redirect:/\";    }}브라우저를 껏다가 다시 켜도 쿠키가 유지됨을 확인할 수 있습니다. 쿠키를 삭제하려면 만료 날짜를 0으로 설정하여 응답 헤더에 추가하게 되면 쿠키를 바로 만료시켜 삭제할 수 있게 됩니다.우선 LoginController에 logout 메소드를 추가합니다./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import java.util.Locale;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import javax.validation.Valid;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructorpublic class LoginController {        private final MessageSource messageSource;    private final MemberService memberService;        @GetMapping(\"/login\")    public void getLoginView() {}    @PostMapping(\"/login\")    public String login(        @Valid @ModelAttribute LoginDTO loginForm,        BindingResult bindingResult,        Locale locale,        HttpServletResponse response    ) throws Exception {                MemberDTO member = memberService.login(loginForm);                if(member == null) {            bindingResult.reject(\"loginFail\", \"아이디 또는 비밀번호가 일치하지 않습니다.\");        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"login\", messageSource, locale);        }                if(member != null) {            Cookie nickNameCookie = new Cookie(\"nickName\", member.getNickName());            nickNameCookie.setMaxAge(60*60*24*7);            response.addCookie(nickNameCookie);        }                return \"redirect:/\";    }        @GetMapping(\"/logout\")    public String logout(HttpServletResponse response) {        Cookie nickNameCookie = new Cookie(\"nickName\", null);        nickNameCookie.setMaxAge(0);        response.addCookie(nickNameCookie);        return \"redirect:/\";    }}메인 템플릿도 다음과 같이 수정합니다./src/main/webapp/WEB-INF/views/home.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    Hello world!  &lt;/h1&gt;&lt;c:if test=\"${nickName ne null}\"&gt;&lt;P&gt;${nickName}님, 환영합니다.&lt;/P&gt;&lt;a href=\"/logout\"&gt;로그아웃&lt;/a&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;로그아웃 링크를 클릭하면 쿠키가 삭제되어 닉네임이 출력되지 않는 것을 확인할 수 있습니다.세션(Session)쿠키의 경우 클라이언트에서 값을 임의로 변경할 수 있고, 쿠키에 보관된 정보를 타인이 훔쳐갈 수 있기때문에 보안상 문제가 있습니다. 이런 문제점을 해결하기 위해서는 정보를 클라이언트가 아니라 서버에서 관리하고 외부로 노출되지 않도록 해야합니다.세션은 서버가 임의의 토큰값을 쿠키에 저장하고 해당 토큰값을 매핑하여 클라이언트의 상태를 유지할 수 있습니다.즉, 세션을 사용하면 클라이언트에서 정보를 저장하지 않고 쿠키를 통해 추정 불가능한 세션 아이디를 주고 받기 때문에 보안상 안전해집니다.세션을 관리하기 위한 매니저 객체를 만들어야 하지만, 스프링에서는 세션을 관리하는 HttpSession 객체를 제공합니다. HttpServletRequest 객체의 getSession 메소드를 통해 세션을 가져올 수 있습니다.세션 메소드스프링에서 제공하는 세션 객체의 메소드는 다음과 같습니다.            리턴타입      메소드      기능                  long      getCreationTime()      세션이 지속된 시간을 ms 단위로 반환              int      getMaxInactiveInterval()      세션의 유지시간을 초단위로 반환              String      getId()      세션의 식별자 ID를 반환              void      setAttribute(String name, Object value)      세션에 객체 저장              Object      getAttribute(String name)      키값에 해당하는 객체 반환              void      removeAttribute(String name)      키값에 해당하는 객체 삭제              void      setMaxInteractiveInterval()      세션의 유지시간 설정              boolean      isNew()      새로 생성된 세션인지 확인              void      invalidate()      세션 제거      세션의 생성과 조회LoginController의 login 메소드를 수정하겠습니다./kro/rubisco/controller/LoginController.javapackage kro.rubisco.controller;import java.util.Locale;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import javax.validation.Valid;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.LoginDTO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructorpublic class LoginController {        private final MessageSource messageSource;    private final MemberService memberService;        @GetMapping(\"/login\")    public void getLoginView() {}    @PostMapping(\"/login\")    public String login(        @Valid @ModelAttribute LoginDTO loginForm,        BindingResult bindingResult,        Locale locale,        HttpServletRequest request    ) throws Exception {                MemberDTO member = memberService.login(loginForm);                if(member == null) {            bindingResult.reject(\"loginFail\", \"아이디 또는 비밀번호가 일치하지 않습니다.\");        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"login\", messageSource, locale);        }                if(member != null) {            HttpSession session = request.getSession();            session.setAttribute(\"member\", member);        }                return \"redirect:/\";    }        @GetMapping(\"/logout\")    public String logout(HttpServletRequest request) {        HttpSession session = request.getSession(false);        if (session != null) {            session.invalidate();        }        return \"redirect:/\";    }}로그인에 성공하면 세션을 가져오고, 해당 세션에 member 정보를 저장합니다.HttpServletRequest 객체의 getSession 메소드에 매개변수로 false를 준다면 세션이 있는 경우 세션을 반환, 세션이 없는 경우 null을 반환합니다. 기본값은 true로 세션이 없으면 새로운 세션을 생성하여 반환합니다.로그아웃시 세션의 invalidate 메소드를 통해 세션의 연결을 끊어주면 됩니다.세션이 저장되었는지 확인하기 위해 HomeController를 수정합니다. 세션에 저장된 데이터는 세션의 getAttribute 메소드를 통해 가져올 수 있습니다./kro/rubisco/controller/HomeController.javapackage kro.rubisco.controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.dto.MemberDTO;@Controllerpublic class HomeController {    @RequestMapping()    public String home(HttpServletRequest request, Model model) {                HttpSession session = request.getSession(false);                if(session != null) {            MemberDTO member =(MemberDTO) session.getAttribute(\"member\");            model.addAttribute(\"nickName\", member.getNickName());        }        return \"home\";    }}@SessionAttribute 어노테이션을 통해서도 간단하게 세션 데이터를 가져올 수 있습니다./kro/rubisco/controller/HomeController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttribute;import kro.rubisco.dto.MemberDTO;@Controllerpublic class HomeController {\t@RequestMapping()\tpublic String home(\t    @SessionAttribute(name = \"member\", required = false) MemberDTO member, \t    Model model\t) {\t    if(member != null) {\t        model.addAttribute(\"nickName\", member.getNickName());\t    }\t\treturn \"home\";\t}}",
        "url": "/java/spring-legacy-cookie-and-session"
    }
    ,
    
    "java-spring-legacy-sign-up": {
        "title": "스프링 레거시(Spring legacy) - 회원가입",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 bean validation을 통해 회원가입을 구현하겠습니다.회원가입폼 작성우선 회원가입폼을 작성하겠습니다./src/main/webapp/WEB-INF/views/member/include/signUpFormCSS.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;style type=\"text/tailwindcss\"&gt;    main {@apply text-gray-600 container px-5 py-16 mx-auto}    article {@apply lg:w-2/3 w-full mx-auto overflow-auto}    form {@apply flex flex-col max-w-2xl mx-auto pb-2 gap-3 xl:gap-6 before:text-lg before:xl:text-2xl before:font-bold before:text-gray-600 before:text-center}    form &gt; label {@apply flex flex-col w-full text-sm sm:text-base}    form &gt; label &gt; font {@apply before:font-medium before:text-gray-600 before:mr-4}    form &gt; button[type=submit] {@apply relative flex justify-center rounded-md border border-transparent bg-slate-600 py-2 px-4 mt-4 text-sm font-medium text-white         hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2}    form input {@apply mt-1 w-full px-3 py-2 bg-white border border-violet-300 rounded-md text-sm shadow-sm placeholder-slate-400        focus:outline-none focus:border-violet-500 focus:ring-1 focus:ring-violet-500 disabled:bg-slate-50 disabled:text-slate-500         disabled:border-slate-200 disabled:shadow-none}&lt;/style&gt;/src/main/webapp/WEB-INF/views/member/signUpForm.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp\"&gt;&lt;/script&gt;    &lt;%@ include file=\"./include/signUpFormCSS.jsp\" %&gt;    &lt;title&gt;게시글 목록&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;main&gt;    &lt;article&gt;        &lt;form class=\"before:content-['회원가입']\" action=\"/member\" method=\"post\" onsubmit=\"return false\"&gt;            &lt;input type=\"hidden\" name=\"act\" value=\"signUp\" /&gt;            &lt;label&gt;                &lt;font class=\"before:content-['이메일']\" color=\"red\"&gt;                    &lt;c:if test=\"${errors.hasFieldErrors('email')}\"&gt;* ${errors.getMessage('email')}&lt;/c:if&gt;                &lt;/font&gt;                &lt;c:choose&gt;                    &lt;c:when test=\"${!errors.hasFieldErrors('email')}\"&gt;                        &lt;c:set var=\"value\" value=\"${errors.getFieldValue('email')}\" /&gt;                    &lt;/c:when&gt;                    &lt;c:otherwise&gt;&lt;c:remove var=\"value\" /&gt;&lt;/c:otherwise&gt;                &lt;/c:choose&gt;                &lt;input type=\"email\" name=\"email\" required placeholder=\"Email\" value=\"${value}\" /&gt;            &lt;/label&gt;            &lt;label&gt;                &lt;font class=\"before:content-['비밀번호']\" color=\"red\"&gt;                    &lt;c:if test=\"${errors.hasFieldErrors('password')}\"&gt;* ${errors.getMessage('password')}&lt;/c:if&gt;                &lt;/font&gt;                &lt;input type=\"password\" name=\"password\" minlength=\"8\" maxlength=\"20\" required placeholder=\"Password\" /&gt;            &lt;/label&gt;            &lt;label&gt;                &lt;font class=\"before:content-['비밀번호_확인']\" color=\"red\"&gt;                    &lt;c:if test=\"${errors.hasFieldErrors('rePassword')}\"&gt;* ${errors.getMessage('rePassword')}&lt;/c:if&gt;                &lt;/font&gt;                &lt;input type=\"password\" name=\"rePassword\" minlength=\"8\" maxlength=\"20\" required placeholder=\"Password\" /&gt;            &lt;/label&gt;            &lt;label&gt;                &lt;font class=\"before:content-['이름']\" color=\"red\"&gt;                    &lt;c:if test=\"${errors.hasFieldErrors('name')}\"&gt;* ${errors.getMessage('name')}&lt;/c:if&gt;                &lt;/font&gt;                &lt;c:choose&gt;                    &lt;c:when test=\"${!errors.hasFieldErrors('name')}\"&gt;                        &lt;c:set var=\"value\" value=\"${errors.getFieldValue('name')}\" /&gt;                    &lt;/c:when&gt;                    &lt;c:otherwise&gt;&lt;c:remove var=\"value\" /&gt;&lt;/c:otherwise&gt;                &lt;/c:choose&gt;                &lt;input type=\"text\" name=\"name\" required placeholder=\"Name\" value=\"${value}\" /&gt;            &lt;/label&gt;            &lt;label&gt;                &lt;font class=\"before:content-['닉네임']\" color=\"red\"&gt;                    &lt;c:if test=\"${errors.hasFieldErrors('nickName')}\"&gt;* ${errors.getMessage('nickName')}&lt;/c:if&gt;                &lt;/font&gt;                &lt;c:choose&gt;                    &lt;c:when test=\"${!errors.hasFieldErrors('nickName')}\"&gt;                        &lt;c:set var=\"value\" value=\"${errors.getFieldValue('nickName')}\" /&gt;                    &lt;/c:when&gt;                    &lt;c:otherwise&gt;&lt;c:remove var=\"value\" /&gt;&lt;/c:otherwise&gt;                &lt;/c:choose&gt;                &lt;input type=\"text\" name=\"nickName\" required placeholder=\"Nickname\" value=\"${value}\" /&gt;            &lt;/label&gt;            &lt;button type=\"submit\" class=\"before:content-['회원가입']\"&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/article&gt;&lt;/main&gt;&lt;script&gt;document.querySelector('button[type=submit]').addEventListener('click', function() {    if(document.querySelector('input[name=password]').value != document.querySelector('input[name=rePassword]').value) {        return document.querySelector('input[name=rePassword]').setCustomValidity(\"패스워드가 일치하지 않습니다.\");    }    document.querySelector('form').submit();});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;tailwindcss를 통해 클래스로 스타일을 작성했으며, HTML5의 폼검증 API를 통해 클라이언트에서 1차적으로 검증을 하도록 작성했습니다.Mapper, DAO, Service 수정이메일이 중복되었는지 확인하기 위해 MemberDAO에 getMemberByEmail 메소드를 추가합니다./kro/rubisco/dao/MemberDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.MemberDTO;@Mapperpublic interface MemberDAO {    public void create(MemberDTO member) throws Exception;        public MemberDTO read(Long memberId) throws Exception;        public MemberDTO getMemberByEmail(String email) throws Exception;    public void update(MemberDTO member) throws Exception;    public void delete(Long memberId) throws Exception;    public List&lt;MemberDTO&gt; listAll() throws Exception;}memberMapper.xml 파일에 getMemberByEmail라는 id를 가지는 select 쿼리문을 작성하여 MemberDAO의 getMemberByEmail 메소드에 매핑하도록 하겠습니다.memberMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.MemberDAO\"&gt;&lt;resultMap id=\"getMember\" type=\"MemberDTO\"&gt;    &lt;association property=\"group\" column=\"group_id\" select=\"getGroup\" /&gt;&lt;/resultMap&gt;&lt;insert id=\"create\"&gt;insert into member (password, email, name, nick_name, group_id)values (#{password}, #{email}, #{name}, #{nickName}, #{groupId})&lt;/insert&gt;&lt;select id=\"read\" resultMap=\"getMember\"&gt;select * from member where member_id = #{memberId}&lt;/select&gt;&lt;select id=\"getMemberByEmail\" resultMap=\"getMember\"&gt;select * from member where email = #{email}&lt;/select&gt;&lt;select id=\"getGroup\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id=#{groupId}&lt;/select&gt;&lt;update id=\"update\"&gt;update member set password=#{password},    email=#{email},     name=#{name},     nick_name= #{nickName},where member_id = #{memberId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from member where member_id = #{memberId} &lt;/delete&gt;&lt;select id=\"listAll\" resultMap=\"getMember\"&gt;&lt;![CDATA[ select * from member where m.member_id &gt; 0 order by m.member_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;MemberService 인터페이스에 email을 매개변수로 받는 read 메소드를 오버로드하여 작성합니다./kro/rubisco/service/MemberService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.MemberDTO;public interface MemberService {          public void regist(MemberDTO member) throws Exception;      public MemberDTO read(Long memberId) throws Exception;            public MemberDTO read(String email) throws Exception;      public void modify(MemberDTO member) throws Exception;      public void remove(Long memberId) throws Exception;      public List&lt;MemberDTO&gt; listAll() throws Exception;}해당 인터페이스의 구현체를 작성합니다./kro/rubisco/service/impl/MemberServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.MemberDAO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;@Service@Transactional(readOnly = true)public class MemberServiceImpl implements MemberService {    private final MemberDAO memberDAO;        @Autowired    public MemberServiceImpl(SqlSession sqlSession) {        this.memberDAO = sqlSession.getMapper(MemberDAO.class);    }        @Override    public void regist(MemberDTO member) throws Exception {        memberDAO.create(member);    }    @Override    public MemberDTO read(Long memberId) throws Exception {        return memberDAO.read(memberId);    }        @Override    public MemberDTO read(String email) throws Exception {        return memberDAO.getMemberByEmail(email);    }    @Override    public void modify(MemberDTO member) throws Exception {        memberDAO.update(member);    }    @Override    public void remove(Long memberId) throws Exception {        memberDAO.delete(memberId);    }    @Override    public List&lt;MemberDTO&gt; listAll() throws Exception {        return memberDAO.listAll();    }}DTO, Controller 수정1차적으로 스크립트를 통해 클라이언트에서 유효성 검사를 하게 되지만, 클라이언트에서는 스크립트 수정을 통해 서버로 부정적인 접근을 할 수 있습니다. 그렇기때문에 컨트롤러에서 2차인 유효성검사를 하게 됩니다.bean validation을 위해 MemberDTO에 다음과 같이 어노테이션을 붙여줍니다./kro/rubisco/dto/MemberDTO.javapackage kro.rubisco.dto;import java.util.Date;import javax.validation.constraints.Email;import javax.validation.constraints.NotBlank;import javax.validation.constraints.Size;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class MemberDTO {        private Long memberId;        @NotBlank(message = \"패스워드를 입력하세요.\")    @Size(min = 8, max = 20, message = \"패스워드는 8글자 이상 20글자 이하로 입력하세요.\")    private String password;        @NotBlank(message = \"이메일을 입력하세요.\")    @Email    private String email;        @NotBlank(message = \"이름을 입력하세요.\")    private String name;        @NotBlank(message = \"닉네임을 입력하세요.\")    private String nickName;        private Long groupId;    private GroupDTO group;    private Date createDate;    private Date lastLogin;}마지막으로 MemberController의 insertMember 메소드를 수정해주세요./kro/rubisco/controller/MemberController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/member\")public class MemberController {    private final MessageSource messageSource;    private final MemberService memberService;        @GetMapping()    public String getMemberInfo() {        return \"member/getMemberInfo\";    }        @GetMapping(params=\"act=signUp\")    public String getSignUpView() throws Exception {        return \"member/signUpForm\";    }        @PostMapping()    public String insertMember(        @Validated @ModelAttribute(\"member\") MemberDTO member,         BindingResult bindingResult,         @RequestParam(\"rePassword\") String rePassword,        Locale locale    ) throws Exception {                if(!member.getPassword().equals(rePassword)) {            bindingResult.addError(new FieldError(\"java.lang.String\", \"rePassword\", \"패스워드가 일치하지 않습니다.\"));        }        if(memberService.read(member.getEmail()) != null) {            bindingResult.rejectValue(\"email\", \"overlap.email\", \"동일한 이메일이 존재합니다.\");        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"member/signUpForm\", messageSource, locale);        }                member.setGroupId(1L);        memberService.regist(member);                return \"redirect:/\";    }        @PatchMapping()    public String updateMember(MemberDTO member) throws Exception {        memberService.modify(member);        return \"redirect:/member\";    }        @DeleteMapping()    public String deleteMember() throws Exception {        return \"redirect:/\";    }}검증기를 따로 작성하지 않고 메소드 자체에 패스워드와 이메일 중복 검증 로직을 작성했습니다. 아직 그룹을 생성하는 폼이 없으므로, 이전에 DB에 입력한 Admin 그룹의 groupId인 1L을 주입하여 회원가입이 되도록 했습니다.아래 화면은 이메일을 중복하여 가입했을 경우 나타나는 화면입니다.",
        "url": "/java/spring-legacy-sign-up"
    }
    ,
    
    "java-spring-legacy-bean-validation": {
        "title": "스프링 레거시(Spring legacy) - Bean Validation",
            "author": "rubisco",
            "category": "",
            "content": "Validator지난번 글에서는 컨트롤러에서 BindingResult 객체를 통해 검증하고 오류가 있으면 예외를 던져 메시지 출력 처리를 했습니다. 하지만 조금더 객체지향적인 프로그래밍을 하기 위해서는 컨트롤러에서 검증 로직을 분리하여 별도의 클래스로 관리하는 것이 코드를 유지보수하기에 좋을 수 있습니다.스프링에서는 검증 로직을 위한 Validator 검증기 인터페이스를 지원합니다. validator 패키지 폴더를 생성하고 그 아래에 검증기 클래스를 작성하도록 하겠습니다. 검증기를 빈으로 등록하기 위해 우선 어플리케이션 컨텍스트에 validator 폴더를 스캔할 수 있도록 component-scan을 추가합니다./src/main/webapp/WEB-INF/spring/root-context.xml...&lt;context:component-scan base-package=\"kro.rubisco.validator\"&gt;&lt;/context:component-scan&gt;...validator 패키지 아래에 ProductValidator 클래스를 작성해주세요./kro/rubisco/validator/ProductValidator.javapackage kro.rubisco.validator;import org.springframework.stereotype.Component;import org.springframework.validation.Errors;import org.springframework.validation.Validator;import kro.rubisco.dto.ProductDTO;@Componentpublic class ProductValidator implements Validator {    @Override    public boolean supports(Class&lt;?&gt; clazz) {        return ProductDTO.class.isAssignableFrom(clazz);    }    @Override    public void validate(Object target, Errors errors) {                ProductDTO product = (ProductDTO) target;                if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            errors.rejectValue(\"count\", \"range\", new Object[] {10L, 100L}, null);        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            errors.rejectValue(\"price\", \"range\", new Object[] {100L, 10_000_000L}, null);        }                if(product.getCount() != null &amp;&amp; product.getPrice() != null) {                        Long total = product.getCount() * product.getPrice();                        if(total &gt; 100_000_000) {                errors.reject(\"totalPriceMax\", new Object[] {100_000_000L, total}, null);            }        }    }}@Component 어노테이션을 통해 컨테이너에 빈으로 등록하고, Validator 인터페이스를 상속받아 supports 메소드와 validate 메소드를 구현해야합니다.supports는 해당 검증기가 검증하려는 객체를 지원하는지 확인하기 위한 메소드이고, validate는 검증을 수행하는 메소드 입니다.supports에는 매개변수로 클래스가 주입되므로, 검증 객체의 타입인 ProductDTO와 동일한 클래스인지 확인하면 됩니다.validate에는 컨트롤러에서 작성한 검증 로직을 그대로 가져오면 됩니다. 참고로 Errors는 BindingResult의 상위 인터페이스입니다.이제 컨트롤러를 다음과 같이 수정해주세요./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import kro.rubisco.validator.ProductValidator;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    private final ProductValidator productValidator;        @InitBinder    public void init(WebDataBinder dataBinder) {        dataBinder.addValidators(productValidator);    }    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @Validated @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}ProductValidator를 생성자로 주입하고, @InitBinder 어노테이션을 통해 WebDataBinder를 초기화 해줍니다. WebDataBinder는 사용자의 요청을 객체에 바인딩 해주는 역할을 하며, 검증 기능도 내부에 포함되어 있습니다. addValidators를 통해 주입받은 ProductValidator를 추가합니다.getTestView 메소드에는 ProductDTO 앞에 @Validated 어노테이션이 추가되었습니다. 해당 어노테이션이 추가되면 webDateBinder에 등록한 검증기를 찾아서 validate 메소드를 호출합니다. 이때 어떤 검증기가 호출될지는 supports 메소드를 통해 확인됩니다.ProductDTO.class를 매개변수로 주고, true가 리턴되는 검증기에서 validate 를 호출합니다. 이때 ProductDTO와 BindingResult가 주입되어 검증을 수행합니다. 즉, 컨트롤러에서 수행한 검증 로직을 검증기에서 하게 된 것입니다.컨트롤러에서는 BindingResult에 오류가 있는지 확인 후 오류가 있다면 예외를 던져줍니다.Bean Validation이번에는 Bean Validation에 대해 알아보겠습니다. Bean Validation은 특정 구현체가 아닌 Bean VAlidation 2.0(JSR-380)이라는 검증에 대한 표준을 정의한 인터페이스 모음입니다. 해당 인터페이스를 구현한 대표적인 구현체로 hibernate-validator가 있습니다.Bean Validation을 사용하면 어노테이션을 통해 간단하게 검증을 수행할 수 있습니다. 우선 pom.xml에 maven repository를 참고하여 사용률이 높은 의존성을 추가해주도록 하겠습니다. 스프링 버전도 높이겠습니다.pom.xml...    &lt;properties&gt;        &lt;java-version&gt;1.8&lt;/java-version&gt;        &lt;org.springframework-version&gt;5.3.23&lt;/org.springframework-version&gt;        &lt;org.aspectj-version&gt;1.6.10&lt;/org.aspectj-version&gt;        &lt;org.slf4j-version&gt;1.6.6&lt;/org.slf4j-version&gt;    &lt;/properties&gt;...    &lt;dependencies&gt;    ...        &lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.validation&lt;/groupId&gt;            &lt;artifactId&gt;validation-api&lt;/artifactId&gt;            &lt;version&gt;2.0.1.Final&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;6.2.0.Final&lt;/version&gt;        &lt;/dependency&gt;    ...    &lt;/dependencies&gt;에러 코드아래는 에러코드에 대응되는 어노테이션을 나타냅니다.            어노테이션      내용                  @AssertTrue@AssertFalse      값이 true 또는 false인지 검사              @DecimalMax@DecimalMin      지정값보다 크거나 같은지 또는 작거나 같은지 검사              @Max@Min      지정값보다 크거나 같은지 또는 작거나 같은지 검사              @Digits      자리수 검사              @Size      배열이나 컬렉션의 크기가 범위내에 있는지 검사              @range      범위 내에 값이 존재하는지 검사              @Null@NotNull      null인지 또는 null이 아닌지 검사              @Positive@PositiveOrZero      양수인지 검사              @Negative@NegativeOrZero      음수인지 검사              @Email      이메일 형식에 맞는지 검사              @Future@FutureOrPresent      미래의 시간인지 검사              @Past@PastOrPresent      과거의 시간인지 검사              @Pattern      정규식 검사      ProductDTO를 수정하겠습니다./kro/rubisco/dto/ProductDTO.javapackage kro.rubisco.dto;import javax.validation.constraints.NotNull;import org.hibernate.validator.constraints.Range;import lombok.Data;@Datapublic class ProductDTO {        @NotNull @Range(min = 10, max = 100)    private Long count;        @NotNull @Range(min = 100, max = 10_000_000)    private Long price;}확인을 위해 error.properties 파일에 메시지를 지우고 컨트롤러를 다음과 같이 수정합니다./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @Validated @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}검증기를 지웠습니다. 유효성 검사를 위해서는 ProductDTO 앞에 @Validated 또는 @Valid 어노테이션을 붙이면 ProductDTO의 어노테이션을 기준으로 검증이 수행됩니다.@Validated와 @Valid는 기능이 동일하며, @Valid는 자바 표준, @Validated는 스프링 표준입니다. @Validated의 경우 그룹 기능을 사용할 수 있습니다.Bean Validation을 사용하면 메시지 기본값이 자동으로 설정되며, message 인수를 통해 지정해 줄수도 있습니다./kro/rubisco/dto/ProductDTO.javapackage kro.rubisco.dto;import javax.validation.constraints.NotNull;import org.hibernate.validator.constraints.Range;import lombok.Data;@Datapublic class ProductDTO {        @NotNull @Range(min = 10, max = 100, message = \"제품의 수량은 10개 이상 100개 이하로 입력할 수 있습니다.\")    private Long count;        @NotNull @Range(min = 100, max = 10_000_000, message = \"제품의 가격은 100원 이상 10,000,000원 이하로 입력할 수 있습니다\")    private Long price;}다국어 지원을 위해서는 dataSource에 입력하는 것을 권장합니다. 인수의 경우, {0}은 필드명이고, {1} 부터는 인수의 이름을 오름차순한 순서로 주입됩니다. 에러코드는 어노테이션 이름과 동일합니다. 메시지를 다음과 같이 작성해주세요./src/main/webapp/WEB-INF/message/error.propertiesRange.product.count = 제품의 수량은 {2}개 이상 {1}개 이하로 입력할 수 있습니다. Range.product.price = 제품의 가격은 {2}원 이상 {1}원 이하로 입력할 수 있습니다.totalPriceMax = 최대 예산은 {0}원 입니다. (현재 총액: {1}원)max가 min보다 알파벳 순서상 앞서므로, max = {1}, min = {2}가 됩니다.객체 검사객체 검사의 경우 @ScriptAssert 어노테이션을 사용하면 됩니다./kro/rubisco/dto/ProductDTO.javapackage kro.rubisco.dto;import javax.validation.constraints.NotNull;import org.hibernate.validator.constraints.Range;import org.hibernate.validator.constraints.ScriptAssert;import lombok.Data;@Data@ScriptAssert(lang=\"javascript\", script = \"_this.count * _this.price &lt; 100000000\")public class ProductDTO {        @NotNull     @Range(min = 10, max = 100)    private Long count;        @NotNull @Range(min = 100, max = 10_000_000)    private Long price;}에러코드는 ScriptAssert.product 또는 ScriptAssert가 됩니다. 그러나 제약사항이 많고 복잡하므로, 객체 검사의 경우 검증기를 사용할 것을 권장합니다.groups 기능객체의 필드를 메소드마다 다르게 검사해야할 경우가 있습니다. 예를 들어 게시글을 입력할때는 documentId가 필수적이지 않지만, 게시글을 수정하거나 삭제할때는 documentId가 필수값이 됩니다. 이러한 이유들로 DB의 결과 데이터를 담을 Entity와 사용자의 요청을 담을 DTO를 구분합니다. Entity는 변화가 거의 없고, DTO는 변화가 빈번하기 때문입니다.DTO를 따로 작성하지 않더라도 필드 검증을 다르게 적용할 수 있는데, 바로 groups 기능입니다. 이 기능은 @Validated 어노테이션에서 사용가능합니다. 앞서 설명했듯이 이 어노테이션은 클래스를 비교하여 검증기를 선택할 수 있도록 합니다.count는 update에만, price는 update와 insert를 할 때 검증이 된다고 가정합시다. 아래와 같이 DTO를 수정해주세요./kro/rubisco/dto/ProductDTO.javapackage kro.rubisco.dto;import javax.validation.constraints.NotNull;import org.hibernate.validator.constraints.Range;import kro.rubisco.validator.ProductInsertValidator;import kro.rubisco.validator.ProductUpdateValidator;import lombok.Data;@Datapublic class ProductDTO {        @NotNull(groups = ProductUpdateValidator.class)    @Range(min = 10, max = 100, groups = ProductUpdateValidator.class)    private Long count;        @NotNull(groups = {ProductUpdateValidator.class, ProductInsertValidator.class})    @Range(        min = 100, max = 10_000_000,         groups = {ProductUpdateValidator.class, ProductInsertValidator.class})    private Long price;}ProductUpdateValidator와 ProductInsertValidator는 비어있는 인터페이스로, 단지 구분을 위해 껍데기를 생성해주었을 뿐입니다.컨트롤러의 @Validated 어노테이션에는 다음과 같이 ProductInsertValidator.class를 입력해주세요./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import kro.rubisco.validator.ProductInsertValidator;import kro.rubisco.validator.ProductValidator;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    private final ProductValidator productValidator;        @InitBinder    public void init(WebDataBinder dataBinder) {        dataBinder.addValidators(productValidator);    }    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @Validated(ProductInsertValidator.class) @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}실행시켜보면 count는 검증하지 않고 price 필드만 검증하는 것을 볼 수 있습니다. 하지만 메소드가 많을수록 코드가 복잡해지므로 Entity와 DTO를 분리하여 작성하는 것을 권장합니다.",
        "url": "/java/spring-legacy-bean-validation"
    }
    ,
    
    "java-spring-legacy-validation": {
        "title": "스프링 레거시(Spring legacy) - 유효성 검사",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 예외처리에 대한 보충설명과 유효성 검사에 대하여 알아보겠습니다.에러(error)와 예외(exception)프로그램의 예외상황은 크게 에러(error)와 예외(exception)로 나눌 수 있습니다. 에러는 시스템 자체에서 비정상적인 상황이 발생하여 프로그램이 계속 실행될 수 없는 경우를 말하며, 예외는 내부적 처리를 통해 프로그램을 계속 실행가능한 상태로 만들 수 있는 경우를 말합니다.자바에서는 이런 예외상황을 처리하기 위해 Throwable 인터페이스를 만들어두었습니다. 에러를 처리하는 Error 클래스와 예외를 처리하는 Exception 클래스는 Throwable 인터페이스를 상속받습니다.에러는 대응할 방법이 없기때문에 Error 클래스는 주로 JVM에서 사용하며, 어플리케이션에서 사용하지는 않습니다. 대표적인 에러로는 스택의 공간이 부족한 경우 발생되는 StackOverflowError가 있습니다.예외(exception)의 분류예외에는 예외 처리가 필요한 Checked Exception과 예외 처리가 불필요한 Unchecked Exception이 있습니다.Checked Exception은 컴파일 시점에서 예외가 발생할 가능성이 있기 때문에 반드시 예외처리를 해야합니다. 대표적으로 파일을 불러올 때 파일이 없을 경인 FileNotFoundException이 있습니다.Unchecked Exception은 런타임 시점에서 예외가 발생할 가능성이 있는 경우이며, 예외처리를 하지 않아도 됩니다. Exception 클래스의 하위 클래스인 RuntimeException 클래스를 상속받은 클래스는 Unchecked Exception이 됩니다.예외(exception)의 처리자바에서 예외처리는 try-catch문을 통해 이루어질 수 있습니다.throw 키워드를 통해 예외를 던질 수 있으며, throw된 예외는 catch문을 통해 받을 수 있습니다. 즉, Checked Exception이 throw 된다면 해당 메소드를 호출한 곳에서는 try-catch문을 통해 던져진 예외를 처리해야 합니다.만약 메소드에 throws 키워드를 붙인다면 throw된 예외를 처리하지 않고 해당 메소드를 호출한 곳으로 다시 예외를 throw 할 수도 있습니다.SimpleMappingExceptionResolver이제 Exception을 통해 예외가 발생하면 에러 페이지를 response 할 수 있도록 코드를 작성해보겠습니다.지난번 글에서 설명했듯이 스프링 프레임워크에서는 ExceptionHandlerExceptionResolver를 통해 @ExceptionHandler 어노테이션이 붙은 메소드를 호출하여 예외를 처리하고, ResponseStatusExceptionResolver를 통해 상태코드를 설정하며, ExceptionHandlerExceptionResolver에서 처리되지 않은 예외는 DefaultHandlerExceptionResolver가 처리하게 됩니다.스프링 프레임워크는 컨테이너에 기본적으로 등록되지는 않지만 간단하게 적용할 수 있는 SimpleMappingExceptionResolver가 있습니다. 이름 그대로 간단하게 예외를 매핑할 수 있는 ExceptionResolver입니다. 서블릿 컨테이너에서 web.xml에 error-page를 등록하여 에러페이지를 매핑한 것과 같이 SimpleMappingExceptionResolver의 프로퍼티를 설정하여 스프링 컨테이너의 예외를 예외 페이지 뷰와 매핑할 수 있습니다.빈(bean)을 생성해야 하는데 레거시를 사용하고 있으니 xml 파일을 통해 빈(bean)을 생성하겠습니다. dispatcherServlet의 컨텍스트에 SimpleMappingExceptionResolver 빈을 등록하겠습니다./src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml...    &lt;beans:bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;        &lt;beans:property name=\"exceptionMappings\"&gt;            &lt;beans:props&gt;                &lt;beans:prop key=\"TestException\"&gt;error/testException&lt;/beans:prop&gt;            &lt;/beans:props&gt;        &lt;/beans:property&gt;        &lt;beans:property name=\"defaultErrorView\" value=\"error/error\" /&gt;    &lt;/beans:bean&gt;...SimpleMappingExceptionResolver를 빈으로 등록하고 exceptionMappings의 프로퍼티를 설정해주면 됩니다. 해당 프로퍼티는 key가 예외객체 이름이고 value가 뷰 이름인 맵으로 되어있습니다. 예외객체 이름은 패키지명을 입력하지 않아도 자동으로 매핑됩니다.검증(validation)클라이언트의 요청이 올바르지 않다면 예외처리를 통해 올바른 요청을 하도록 유도해야합니다. 이러한 과정을 검증(validation)이라고 합니다. 웹 애플리케이션에서 검증은 중요한 과정입니다.검증과정을 알아보기위해 임시로 count와 price로 구성된 ProductDTO를 작성해보겠습니다./kro/rubisco/dto/ProductDTO.javapackage kro.rubisco.dto;import lombok.Data;@Datapublic class ProductDTO {    private Long count;    private Long price;}검증과 관련된 객체에는 BindingResult, FieldError, ObjectError가 있습니다.FieldError 추가BindingResult는 FieldError를 보관하는 객체입니다. FieldError는 필드의 타입에 맞지 않는 경우 스프링 컨테이너에 의하여 자동으로 생성되어 BindingResult에 저장되는데, 필요한 경우 검증을 통해 FieldError를 직접 생성하여 BindingResult에 넣어줄 수 있습니다.FieldError의 생성자는 2개가 있습니다./kro/rubisco/dto/ProductDTO.javapublic FieldError(String objectName, String field, String defaultMessage);public FieldError(String objectName, String field, @Nullable Object rejectedValue, boolean bindingFailure, @Nullable String[] codes, @Nullable Object[] arguments, @Nullable String defaultMessage)objectName은 오류가 발생한 객체의 이름이며, field는 오류가 발생한 필드의 이름입니다. rejectedValue는 바인딩에 실패한 오류인지 검증에 실패한 오류인지를 나타내고, codes는 메시지 코드를, arguments는 메시지에서 사용할 인자를, defaultMessage는 기본 오류 메시지를 나타냅니다.우선 1번째 생성자를 통해 defaultMessage를 지정하여 예외처리를 해보겠습니다.컨트롤러를 작성하기 전에 BindException을 상속받은 BindExceptionWithViewName을 작성하겠습니다. BindException을 던져줄 때 뷰 이름도 같이 던지기 위함입니다./kro/rubisco/config/BindExceptionWithViewName.javapackage kro.rubisco.config;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;public class BindExceptionWithViewName extends BindException {    private final String viewName;        public BindExceptionWithViewName(BindingResult bindingResult, String viewName) {        super(bindingResult);        this.viewName = viewName;    }        public String getViewName() {        return viewName;    }    }이제 컨트롤러를 작성하세요./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;@Controller@RequestMapping(\"/test\")public class TestController {    @GetMapping()    public void getTestView() {    }        @PostMapping()    public String getTestView(ProductDTO product, BindingResult bindingResult) throws BindException {        if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            bindingResult.addError(new FieldError(\"product\", \"count\", \"수량은 10 이상 100 이하 입니다.\"));        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            bindingResult.addError(new FieldError(\"product\", \"price\", \"가격은 100원 이상 10,000,000원 이하 입니다.\"));        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\");        }        return \"redirect:/test\";    }}TestController를 만들고 /test에 매핑합니다. post 요청의 경우 ProductDTO를 주입받아 처리하도록 합니다. ProductDTO 뒤에 BindingResult를 주입했는데, 해당 객체가 없는 경우 모델에 대하여 binding이 실패하면 컨트롤러를 호출하지 않고 BindException을 던져 컨테이너가 자동으로 예외처리를 해버립니다. 하지만 객체 뒤에 BindingResult가 있으면 예외를 던지지 않고 우선 컨트롤러에 진입하게 됩니다.이제 if문을 통해 검증을 하고, 예외상황인 경우 FieldError를 만들어서 bindingResult에 추가해주면 됩니다. 위에 코드에서는 count가 10 미만이거나 100 초과인 경우 count에 대하여 에러를 추가하고, price가 100 미만이거나 10,000,000 초과인 경우 price에 대하여 에러를 추가합니다.bindingResult에 FieldError가 있는 경우 BindException을 던져줍니다. BindException은 bindingResult를 가지고 있으며, 이를 상속받아 작성한 BindExceptionWithViewName으로 뷰의 이름도 같이 전달해줍시다. 예외가 없다면 컨트롤러 로직을 수행하고 PRG 패턴을 사용하여 get 방식으로 redirect 합니다.이제 예외컨트롤러를 작성하겠습니다. @ControllerAdvice 어노테이션을 통해 전역적인 예외처리를 해주는 ExceptionHandlingController를 작성합니다./kro/rubisco/controller/ExceptionHandlingController.javapackage kro.rubisco.controller;import org.springframework.ui.Model;import org.springframework.validation.Errors;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import kro.rubisco.config.BindExceptionWithViewName;@ControllerAdvicepublic class ExceptionHandlingController {    @ExceptionHandler(BindExceptionWithViewName.class)    protected String handleBadRequest(BindExceptionWithViewName e, Model model) {        model.addAttribute(\"errors\", e);        return e.getViewName();    }}@ExceptionHandler 어노테이션을 통해 BindExceptionWithViewName에 handleBadRequest 메소드를 매핑시킵니다. 해당 메소드에서는 모델에 Errors 객체를 추가하고, BindExceptionWithViewName을 통해 전달받은 뷰 이름을 반환합니다.이제 뷰 템플릿을 작성하겠습니다./src/main/webapp/WEB-INF/views/test.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"POST\" action=\"/test\"&gt;    &lt;c:forTokens var=\"field\" items=\"count,price\" delims=\",\"&gt;        &lt;label&gt;            &lt;c:choose&gt;                &lt;c:when test=\"${field eq 'count'}\"&gt;수량&lt;/c:when&gt;                &lt;c:when test=\"${field eq 'price'}\"&gt;가격&lt;/c:when&gt;            &lt;/c:choose&gt;            &lt;input type=\"text\" name=\"${field}\" value=\"${errors.getFieldValue(field)}\" /&gt;            &lt;c:if test=\"${errors.hasFieldErrors(field)}\"&gt;                &lt;font color=\"red\"&gt;${errors.getFieldError(attr).defaultMessage}&lt;/font&gt;            &lt;/c:if&gt;        &lt;/label&gt;        &lt;br&gt;    &lt;/c:forTokens&gt;    &lt;br&gt;    &lt;input type=\"submit\" value=\"제출\" /&gt;&lt;/form&gt;&lt;c:if test=\"${errors.hasErrors()}\"&gt;&lt;script&gt;[...document.forms[0].querySelectorAll(\"[name]\")].filter(e=&gt;!e.value)[0].focus();&lt;/script&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;JSP에서 EL의 경우 해당 변수가 null이라면 출력되지 않게 됩니다. errors 객체에서 getFieldValue 메소드는 해당 프로퍼티에 에러가 있으면 null값이 되어 출력되지 않고 그렇지 않으면 클라이언트에서 전송한 값을 출력합니다. 그러므로 검증을 통과하지 못한 필드는 빈값이 되고 에러 메시지가 출력됩니다.에러코드를 통한 메시지 출력이번에는 에러코드를 통해 메시지를 출력해보겠습니다. 방금 작성한 코드처럼 하드코딩으로 defaultMessage를 직접 작성해도 되지만, 메시지를 따로 관리하여 메시지를 코드를 통해 간접적으로 메시지를 출력할 수도 있습니다.우선 메시지를 관리하기위한 messageSource를 컨테이너에 빈으로 추가합니다. 다국어 처리가 가능한 ReloadableResourceBundleMessageSource를 메시지 소스로 사용하도록 하겠습니다./src/main/webapp/WEB-INF/spring/root-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt;        &lt;!-- Root Context: defines shared resources visible to all other web components --&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;          &lt;property value=\"oracle.jdbc.driver.OracleDriver\" name=\"driverClassName\"/&gt;          &lt;property value=\"[DB 주소]\" name=\"url\"/&gt;          &lt;property value=\"[DB 아이디]\" name=\"username\"/&gt;          &lt;property value=\"[DB 암호]\" name=\"password\"/&gt;    &lt;/bean&gt;             &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;          &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\"&gt;&lt;/property&gt;                &lt;/bean&gt;    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt;        &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;        &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt;                &lt;!-- Encoding 설정 --&gt;        &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt;                &lt;!-- Reload Cache 설정 --&gt;        &lt;property name=\"cacheSeconds\" value=\"5\" /&gt;                &lt;!-- BaseName 설정 --&gt;        &lt;property name=\"basenames\"&gt;            &lt;list&gt;                &lt;value&gt;/WEB-INF/message/error&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;            &lt;/bean&gt;        &lt;context:component-scan base-package=\"kro.rubisco.service\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;basenames을 기준으로 [basenames]_[언어코드]_[국가코드].properties 형식으로 메시지 파일을 작성해야합니다. 예를 들어 한국어 메시지의 경우 error_ko_KR.properties 파일에, 영어 메시지의 경우 error_en_US.properties 파일에 작성하면 됩니다. 기본파일은 basename인 error.properties에 작성합니다./src/main/webapp/WEB-INF/message/error.propertiesrange.product.count = 제품의 수량은 {0}개 이상 {1}개 이하로 입력할 수 있습니다. range.product.price = 제품의 가격은 {0}원 이상 {1}원 이하로 입력할 수 있습니다.{0}, {1}은 DataSource에서 전달되는 인수입니다.BindExceptionWithViewName이 생성자를 통해 DataSource를 주입받도록 수정하고, 해당 객체를 통해 메시지를 출력할 수 있도록 getMessage 메소드를 추가하겠습니다./kro/rubisco/config/BindExceptionWithViewName.javapackage kro.rubisco.config;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;public class BindExceptionWithViewName extends BindException {    private final String viewName;    private final MessageSource messageSource;    private final Locale locale;        public BindExceptionWithViewName(        BindingResult bindingResult,         String viewName,         MessageSource messageSource,        Locale locale    ) {        super(bindingResult);        this.viewName = viewName;        this.messageSource = messageSource;        this.locale = locale;    }        public String getViewName() {        return viewName;    }        public String getMessage(String field) {       return messageSource.getMessage(getFieldError(field), locale);    }}TestController도 다음과 같이 FieldError의 생성자에 인수를 추가하고, BindExceptionWithViewName에 DataSource와 Locale을 주입해주도록 합시다./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(ProductDTO product, BindingResult bindingResult, Locale locale) throws BindException {        if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            bindingResult.addError(                new FieldError(                    \"product\", \"count\", product.getCount(), false, new String[]{\"range.product.count\"},                     new Object[] {10L, 100L}, null                )            );        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            bindingResult.addError(                new FieldError(                    \"product\", \"price\", product.getPrice(), false, new String[]{\"range.product.price\"},                     new Object[] {100L, 10_000_000L}, null                )            );        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}FieldError의 생성자 매개변수가 늘어났습니다. 1번째, 2번째 매개변수는 객체이름, 필드이름이고, 3번째 매개변수는 클라이언트가 요청한 필드값입니다.4번째 매개변수는 binding 오류인지 검증 오류인지 판단하기 위한 인수인데, 검증 오류이므로 false를 입력합니다.5번째 매개변수는 에러코드를 String 배열로 입력합니다. DataSource에 입력돤 key값과 매칭하여 일치하는 코드들 중에 첫번째 코드를 에러코드로 사용하게 됩니다.6번째 매개변수는 DataSource로 전달될 인수를 객체 배열로 생성하여 입력합니다. 인수가 필요없다면 null값을 주어도 됩니다. 범위 오류를 출력하는 경우와 같이 문구가 반복되고 값만 변한다면 동일한 코드에 인수만 전달하여 범용적으로 사용할 수 있습니다.7번째 매개변수는 오류메시지의 기본값으로, 일치하는 코드가 없다면 해당 값을 오류 메시지로 사용합니다. 위에 코드에서는 null값을 주었습니다.이제 뷰 템플릿을 수정합니다./src/main/webapp/WEB-INF/views/test.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"POST\" action=\"/test\"&gt;    &lt;c:forTokens var=\"field\" items=\"count,price\" delims=\",\"&gt;        &lt;label&gt;            &lt;c:choose&gt;                &lt;c:when test=\"${field eq 'count'}\"&gt;수량&lt;/c:when&gt;                &lt;c:when test=\"${field eq 'price'}\"&gt;가격&lt;/c:when&gt;            &lt;/c:choose&gt;            &lt;c:choose&gt;                &lt;c:when test=\"${!errors.hasFieldErrors(field)}\"&gt;                    &lt;c:set var=\"value\" value=\"${errors.getFieldValue(field)}\" /&gt;                &lt;/c:when&gt;                &lt;c:otherwise&gt;&lt;c:remove var=\"value\" /&gt;&lt;/c:otherwise&gt;            &lt;/c:choose&gt;            &lt;input type=\"text\" name=\"${field}\" value=\"${value}\" /&gt;            &lt;c:if test=\"${errors.hasFieldErrors(field)}\"&gt;                &lt;font color=\"red\"&gt;${errors.getMessage(field)}&lt;/font&gt;            &lt;/c:if&gt;        &lt;/label&gt;        &lt;br&gt;    &lt;/c:forTokens&gt;    &lt;br&gt;    &lt;input type=\"submit\" value=\"제출\" /&gt;&lt;/form&gt;&lt;c:if test=\"${errors.hasErrors()}\"&gt;&lt;script&gt;[...document.forms[0].querySelectorAll(\"[name]\")].filter(e=&gt;!e.value)[0].focus();&lt;/script&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;메시지를 출력하는 부분의 코드를 errors 객체의 getMessage 메소드를 통해 출력하도록 변경했습니다.rejectValue 메소드 사용FieldError를 직접 생성할 수도 있지만 BindingResult에서는 FieldError를 간단하게 생성할 수 있는 rejectValue 메소드가 있습니다. 아래와 같이 TestController를 수정해보세요./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            bindingResult.rejectValue(\"count\", \"range\", new Object[] {10L, 100L}, null);        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            bindingResult.rejectValue(\"price\", \"range\", new Object[] {100L, 10_000_000L}, null);        }                if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}FieldError를 직접 생성하는 것이 아니라 rejectValue 메소드를 호출하여 FieldError를 생성했습니다. BindingResult는 검증할 객체 바로 다음에 주입되는 성질을 이용한 것입니다.첫번째 변수는 필드명, 두번째 변수는 에러코드 입니다.에러코드는 직접 FieldError를 생성할 때랑 차이가 있는데 MessageSource에 입력되는 키값은 {에러코드}.{오브젝트명}.{필드명} 형식으로 작성하고, 매개변수에는 에러코드 부분만 입력하면 됩니다. 예를 들어 MessageSource에 입력된 메시지 키값이 range.product.cost라면 range만 입력합니다.오브젝트명은 검증할 객체의 타입으로 자동 설정되는데, 오브젝트명을 변경하려면 @ModelAttribute 어노테이션을 붙여 키값을 설정해주어야 합니다. 위에 예시 코드에서는 검증 객체의 이름이 productDTO이므로, @ModelAttribute(\"product\") 어노테이션을 붙여 객체이름을 product로 변경해 주었습니다. 물론 MessageSource에 키값을 range.productDTO.cost라고 변경해도 됩니다.이렇게 에러코드를 입력해두면 내부 로직에서는 MessageCodesResolver 객체를 통해 \"{에러코드}.{오브젝트명}.{필드명}\", \"{에러코드}.{필드명}\", \"{에러코드}.{필드타입}\", \"{에러코드}\" 라는 4개의 에러코드를 생성하며, 여기에서 MessageSource에 존재하는 코드 중 첫번째 코드를 에러코드로 사용합니다. 예를 들어 위에 예시코드의 경우 {\"range.product.cost\", \"range.cost\", \"range.java.lang.Long\", \"range\"} 순서로 에러코드가 생성되고, MessageSource에 존재하는 range.product.cost가 에러코드로 적용됩니다.세번째 변수는 DataSource로 전달될 인수의 배열이고, 네번째 변수는 오류메시지 기본값으로 null을 입력했습니다.ObjectError 추가FieldError 객체가 필드값의 오류를 나타낸다면 ObjectError는 객체의 오류를 나타냅니다. 예를 들어 총액이 100,000,000원 이하가 되도록 범위를 정하려면 FieldError 만으로는 오류를 나타낼 수 없고 ObjectError를 통해 객체 자체에 오류가 있음을 나타내야 합니다./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.validation.ObjectError;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            bindingResult.rejectValue(\"count\", \"range\", new Object[] {10L, 100L}, null);        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            bindingResult.rejectValue(\"price\", \"range\", new Object[] {100L, 10_000_000L}, null);        }                if(product.getCount() != null &amp;&amp; product.getPrice() != null) {                        Long total = product.getCount() * product.getPrice();                        if(total &gt; 100_000_000) {                bindingResult.addError(                    new ObjectError(\"product\", new String[] {\"totalPriceMax\"}, new Object[] {100_000_000L, total}, null)                );            }        }        if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}ObjectError의 생성자는 4개의 매개변수가 필요합니다. 첫번째 매개변수는 객체이름, 두번째 매개변수는 에러코드, 세번째 매개변수는 DataSource로 전달될 인수의 배열, 네번째 매개변수는 오류메시지 기본값 입니다.BindExceptionWithViewName 클래스에 글로벌 오류에 대한 메시지를 받을 getGlobalMessage 메소드를 추가합니다./kro/rubisco/config/BindExceptionWithViewName.javapackage kro.rubisco.config;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;public class BindExceptionWithViewName extends BindException {    private final String viewName;    private final MessageSource messageSource;    private final Locale locale;        public BindExceptionWithViewName(        BindingResult bindingResult,         String viewName,         MessageSource messageSource,        Locale locale    ) {        super(bindingResult);        this.viewName = viewName;        this.messageSource = messageSource;        this.locale = locale;    }        public String getViewName() {        return viewName;    }        public String getMessage(String field) {       return messageSource.getMessage(getFieldError(field), locale);    }        public String getGlobalMessage() {       return messageSource.getMessage(getGlobalError(), locale);    }}메시지도 다음과 같이 추가해줍니다./src/main/webapp/WEB-INF/message/error.propertiesrange.product.count = 제품의 수량은 {0}개 이상 {1}개 이하로 입력할 수 있습니다. range.product.price = 제품의 가격은 {0}원 이상 {1}원 이하로 입력할 수 있습니다.totalPriceMax = 최대 예산은 {0}원 입니다. (현재 총액: {1}원)뷰 템플릿을 다음과 같이 수정합니다./src/main/webapp/WEB-INF/views/test.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"POST\" action=\"/test\"&gt;    &lt;c:forTokens var=\"field\" items=\"count,price\" delims=\",\"&gt;        &lt;label&gt;            &lt;c:choose&gt;                &lt;c:when test=\"${field eq 'count'}\"&gt;수량&lt;/c:when&gt;                &lt;c:when test=\"${field eq 'price'}\"&gt;가격&lt;/c:when&gt;            &lt;/c:choose&gt;            &lt;c:choose&gt;                &lt;c:when test=\"${!errors.hasFieldErrors(field)}\"&gt;                    &lt;c:set var=\"value\" value=\"${errors.getFieldValue(field)}\" /&gt;                &lt;/c:when&gt;                &lt;c:otherwise&gt;&lt;c:remove var=\"value\" /&gt;&lt;/c:otherwise&gt;            &lt;/c:choose&gt;            &lt;input type=\"text\" name=\"${field}\" value=\"${value}\" /&gt;            &lt;c:if test=\"${errors.hasFieldErrors(field)}\"&gt;                &lt;font color=\"red\"&gt;${errors.getMessage(field)}&lt;/font&gt;            &lt;/c:if&gt;        &lt;/label&gt;        &lt;br&gt;    &lt;/c:forTokens&gt;    &lt;c:if test=\"${!error.hasFieldErrors() and errors.hasGlobalErrors()}\"&gt;        &lt;p&gt;&lt;font color=\"red\"&gt;${errors.globalMessage}&lt;/font&gt;&lt;/p&gt;    &lt;/c:if&gt;    &lt;br&gt;    &lt;input type=\"submit\" value=\"제출\" /&gt;&lt;/form&gt;&lt;c:if test=\"${errors.hasErrors()}\"&gt;&lt;script&gt;[...document.forms[0].querySelectorAll(\"[name]\")].filter(e=&gt;!e.value)[0].focus();&lt;/script&gt;&lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt;FieldError와 마찬가지로 BindingResult의 reject 메소드를 통해서 간편하게 생성할 수 있습니다./kro/rubisco/controller/TestController.javapackage kro.rubisco.controller;import java.util.Locale;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.validation.BindException;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.config.BindExceptionWithViewName;import kro.rubisco.dto.ProductDTO;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/test\")public class TestController {        private final MessageSource messageSource;    @GetMapping()    public void getTestView() {}        @PostMapping()    public String getTestView(        @ModelAttribute(\"product\") ProductDTO product,         BindingResult bindingResult,         Locale locale    ) throws BindException {        if(product.getCount() == null || product.getCount() &lt; 10 || product.getCount() &gt; 100){            bindingResult.rejectValue(\"count\", \"range\", new Object[] {10L, 100L}, null);        }                if(product.getPrice() == null || product.getPrice() &lt; 100 || product.getPrice() &gt; 10_000_000){            bindingResult.rejectValue(\"price\", \"range\", new Object[] {100L, 10_000_000L}, null);        }                if(product.getCount() != null &amp;&amp; product.getPrice() != null) {                        Long total = product.getCount() * product.getPrice();                        if(total &gt; 100_000_000) {                bindingResult.reject(\"totalPriceMax\", new Object[] {100_000_000L, total}, null);            }        }        if(bindingResult.hasErrors()) {            throw new BindExceptionWithViewName(bindingResult, \"/test\", messageSource, locale);        }        return \"redirect:/test\";    }}reject 메소드의 1번째 매개변수는 에러코드, 두번째 매개변수는 DataSource로 전달될 인수의 배열, 세번째 매개변수는 오류메시지 기본값 입니다.",
        "url": "/java/spring-legacy-validation"
    }
    ,
    
    "java-spring-legacy-exception": {
        "title": "스프링 레거시(Spring legacy) - 예외처리",
            "author": "rubisco",
            "category": "",
            "content": "이번 글에서는 클라이언트 요청에 대한 예외 처리를 해보겠습니다.예외처리예외(exception)은 크게 서블릿 컨테이너에서 발생하는 예외와 스프링 컨테이너에서 발생하는 예외로 나눌 수 있습니다.스프링MCV에서 예외의 대부분은 스프링 컨테이너 내부에서 발생합니다. 스프링 컨테이너에서 발생하는 예외는 HandlerExceptionResolver를 통해 처리되며 다양한 방식으로 접근할 수 있습니다.웹 어플리케이션 레벨 예외 처리클라이언트의 요청을 DispatcherServlet에서 처리하기 전에 예외가 발생하면 HandlerExceptionResolver가 예외처리를 하지 못합니다. 이 경우 Web Application 레벨에서 예외를 처리해야합니다.필터를 통한 예외 처리우선 필터를 통해서 예외처리를 할 수 있습니다. HandlerExceptionResolver를 주입받아 필터에서 발생하는 예외를 HandlerExceptionResolver로 보내서 처리하면 됩니다. 스프링 시큐리티에서 예외처리를 하는 방법입니다. 필터에 대하여 알아야하기 때문에 생략하겠습니다.web.xml 에서 에러페이지 설정다음으로 web.xml에 에러페이지를 설정하여 예외처리를 할 수 있습니다.우선 에러페이지 템플릿을 작성하도록 합시다./src/main/webapp/WEB-INF/views/error/error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;오류발생&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;오류 발생&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;이제 web.xml 파일에 에러페이지를 설정해주면 됩니다. 예외타입 또는 HTTP Status 코드별로 에러페이지를 설정할 수 있습니다.먼저 HTTP Status 코드에 따른 에러페이지를 설정해보겠습니다. 아래 코드와 같이 error-page 태그를 추가합니다.src/main/webapp/WEB-INF/web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;    &lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- Processes application requests --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;            &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;        &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter&gt;        &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;        &lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;/WEB-INF/views/error/error.jsp&lt;/location&gt;    &lt;/error-page&gt;&lt;/web-app&gt;매핑되지 않는 주소(localhost:8080/abcd)로 접속하면 404 에러가 발생하므로, 위에서 설정한 에러 페이지를 출력하게 됩니다.이번에는 예외타입을 통해 에러 페이지를 설정해보겠습니다. 위에 error-page 하위 태그인 error-code를 exception-type 으로 변경하세요.src/main/webapp/WEB-INF/web.xml...    &lt;error-page&gt;        &lt;exception-type&gt;kro.rubisco.config.TestException&lt;/exception-type&gt;        &lt;location&gt;/WEB-INF/views/error/error.jsp&lt;/location&gt;    &lt;/error-page&gt;...TestException이 던져지면 설정한 에러 페이지를 출력하게 됩니다. 위에 작성한 예외 타입은 임시로 작성한 예외타입입니다./kro/rubisco/config/TestException.javapackage kro.rubisco.config;import lombok.NoArgsConstructor;@NoArgsConstructorpublic class TestException extends Exception {    public TestException(String msg) {        super(msg);    }}BoardController의 getBoardListView 메소드를 아래와 같이 수정하고 localhost:8080/board 로 접속하면 동일한 에러 페이지가 출력됩니다./kro/rubisco/controller/BoardController.java...    @GetMapping()    public Model getBoardListView(        PageDTO&lt;BoardDTO&gt; boardPage,         SearchDTO search,        Model model    ) throws Exception {        throw new TestException();    }...DispatcherServlet의 예외 처리처음 설명한 것과 같이 스프링 컨테이너의 경우 DispatcherServlet에서 발생하는 예외는 HandlerExceptionResolver가 처리합니다.스프링에서 기본적으로 ExceptionHandlerExceptionResolver, ResponseStatusExceptionResolver, DefaultHandlerExceptionResolver를 제공하고 있으며, 순서대로 우선순위를 가집니다.ExceptionHandlerExceptionResolver해당 resolver는 컨트롤러 레벨에서 @ExceptionHandler 어노테이션이 붙은 메소드를 호출하여 예외처리를 합니다.위에서 web.xml에 작성한 error-page 태그를 지우고 BoardController에 다음 메소드를 작성해보세요./kro/rubisco/controller/BoardController.java...    @ExceptionHandler(TestException.class)    public ModelAndView testExceptionHandler(Exception e) {        ModelAndView mv = new ModelAndView();        mv.setStatus(HttpStatus.BAD_REQUEST);        mv.setViewName(\"/error/error\");        return mv;    }...BoardController에 매핑되는 request에서 TestException 타입의 예외가 발생하면 testExceptionHandler 메소드가 호출됩니다. 해당 메소드는 상태코드를 400으로 설정하여 위에서 작성한 에러 페이지를 response 합니다.만약 컨트롤러 레벨이 아니라 전역 레벨에서 예외처리를 하고자 한다면 @ControllerAdvice 어노테이션이 붙은 클래스를 작성하면 됩니다./kro/rubisco/controller/ExceptionHandlingController.javapackage kro.rubisco.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class ExceptionHandlingController {    @ResponseStatus(HttpStatus.BAD_REQUEST)    @ExceptionHandler(Exception.class)    protected ModelAndView handleBadRequest(HttpServletRequest req, Exception e) {        ModelAndView mv = new ModelAndView();        mv.addObject(\"exception\", e);        mv.setViewName(\"error/error\");        return mv;    }}ResponseStatusExceptionResolver해당 resolver는 예외에 따라 HTTP State Code를 지정해줍니다. 위에서 작성한 ExceptionHandlingController의 handleBadRequest 메소드에 보면 @ResponseStatus 어노테이션을 통해 상태코드를 설정해 주었습니다.DefaultHandlerExceptionResolver해당 resolver는 스프링 컨테이너 내부에서 발생되는 기본적인 예외들을 처리합니다. 즉, 예외처리를 따로 해주지 않아도 제공되는 해당 resolver에 의하여 예외처리가 됩니다. 예를 들어 파라미터 타입이 일치하지 않은 경우 TypeMismatchException이 발생하는데, DispatcherServlet에서 발생한 오류이므로 상태코드는 500이 됩니다. 하지만 DefaultHandlerExceptionResolver가 상태코드를 400으로 설정하여 에러페이지를 response 하므로 클라이언트에서는 400 코드를 받게 됩니다.",
        "url": "/java/spring-legacy-exception"
    }
    ,
    
    "java-spring-legacy-search": {
        "title": "스프링 레거시(Spring legacy) - 검색기능",
            "author": "rubisco",
            "category": "",
            "content": "이번에는 게시글에 검색기능을 넣어보도록 하겠습니다. 스프링 부트에서는 QueryDSL을 통해 동적으로 쿼리문을 생성할 수 있었는데 레거시에서는 매퍼에서 다양한 태그를 통해 쿼리를 동적으로 작성할 수 있습니다.DTO 작성우선 검색 기능을 위한 SearchDTO를 작성하도록 하겠습니다./kro/rubisco/dto/SearchDTO.javapackage kro.rubisco.dto;import lombok.Getter;import lombok.Setter;@Setter@Getterpublic class SearchDTO {    public static enum Target {        titleAndContent, title, content, nickName    }        private Target target;    private String keyword;}검색 기준이 되는 target과 검색어인 keyword로 구성된 객체입니다. target의 경우 enum 객체로 검색범위를 지정했습니다.DAO 수정매개변수가 하나인 경우 매퍼에서 파라미터가 해당 객체의 프로퍼티의 이름으로 자동 매핑되지만, 2개 이상이면 파라미터가 map 타입으로 매핑됩니다. 이 경우 param1, param2 ... 순서로 객체에 접근할 수 있는데, 아래에 수정한 코드와 같이 @Param 어노테이션을 사용하면 파라미터에 변수명을 지정하여 해당 변수명으로 접근할 수 있게 해줍니다.BoardDAO의 listAll 메소드와 getCount 메소드가 SearchDTO를 매개변수로 주입받을 수 있도록 수정해줍시다./kro/rubisco/dao/BoardDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;import kro.rubisco.dto.SearchDTO;@Mapperpublic interface BoardDAO {        public void create(BoardDTO board) throws Exception;        public BoardDTO read(Long documentId) throws Exception;    public void update(BoardDTO board) throws Exception;    public void delete(Long documentId) throws Exception;    public List&lt;BoardDTO&gt; listAll(        @Param(\"board\") PageDTO&lt;BoardDTO&gt; boardPage,         @Param(\"search\") SearchDTO search    ) throws Exception;        public long getCount(SearchDTO search) throws Exception;}서비스 수정DAO를 수정했으므로, 이를 사용하는 BoardService의 구현체도 수정해야 합니다. listAll 메소드에 SearchDTO를 주입받아 BoardDAO의 listAll 메소드와 getCount 메소드를 호출합니다./kro/rubisco/service/impl/BoardServiceImpl.javapackage kro.rubisco.service.impl;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.BoardDAO;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;import kro.rubisco.dto.SearchDTO;import kro.rubisco.service.BoardService;@Service@Transactional(readOnly = true)public class BoardServiceImpl implements BoardService {        private final BoardDAO boardDAO;        @Autowired    public BoardServiceImpl(SqlSession sqlSession) {        this.boardDAO = sqlSession.getMapper(BoardDAO.class);    }        @Override    public void regist(BoardDTO board) throws Exception {        boardDAO.create(board);    }    @Override    public BoardDTO read(Long documentId) throws Exception {        return boardDAO.read(documentId);    }    @Override    public void modify(BoardDTO board) throws Exception {        boardDAO.update(board);    }    @Override    public void remove(Long documentId) throws Exception {        boardDAO.delete(documentId);    }    @Override    public PageDTO&lt;BoardDTO&gt; listAll(PageDTO&lt;BoardDTO&gt; boardPage, SearchDTO search) throws Exception {        boardPage.setContentList(boardDAO.listAll(boardPage, search));        boardPage.setTotalSize(boardDAO.getCount(search));        return boardPage;    }   }매퍼 수정boardMapper의 listAll select문을 다음과 같이 수정합니다.boardMapper.xml...&lt;select id=\"listAll\" resultMap=\"getBoardList\"&gt;&lt;![CDATA[select * from (    select rownum num, b.*    from (        select b.* from board b        inner join member m on b.member_id = m.member_id]]&gt;&lt;if test=\"search.target neq null and search.keyword neq null\"&gt;    &lt;where&gt;        &lt;choose&gt;            &lt;when test=\"search.target.toString() eq 'title'\"&gt;                &lt;![CDATA[                     and b.title like '%'||#{search.keyword}||'%'                ]]&gt;            &lt;/when&gt;            &lt;when test=\"search.target.toString() eq 'content'\"&gt;                &lt;![CDATA[                     and b.content like '%'||#{search.keyword}||'%'                ]]&gt;            &lt;/when&gt;            &lt;when test=\"search.target.toString() eq 'titleAndContent'\"&gt;                &lt;![CDATA[                     and b.title like '%'||#{search.keyword}||'%'                    or b.content like '%'||#{search.keyword}||'%'                ]]&gt;            &lt;/when&gt;            &lt;when test=\"search.target.toString() eq 'nickName'\"&gt;                &lt;![CDATA[                     and m.nick_name like '%'||#{search.keyword}||'%'                ]]&gt;            &lt;/when&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/if&gt;&lt;![CDATA[        order by b.document_id desc    ) b    WHERE rownum &lt;= #{board.last})where num &gt;= #{board.first}]]&gt;&lt;/select&gt;...다양한 태그가 사용되었습니다. 우선 if 태그를 통해 조건에 따라 쿼리를 추가할 수 있습니다. search 객체에 target과 keyword가 있는 경우에 where 조건문을 추가하도록 작성했습니다.DAO에서 파라미터를 board와 search로 설정했으므로, 해당 파라미터를 통해 BoardDTO 객체와 SearchDTO 객체를 참조할 수 있습니다.where 조건문은 where 태그를 통해 작성하면 prefix나 suffix를 where문에 맞도록 수정해줍니다. 예를 들어 where and b.title ... 형태로 쿼리가 작성되면 오류가 발생하는데, 태그를 통해 작성하면 and 부분을 제거하여 where b.title ... 형태로 올바른 쿼리를 생성합니다.choose 태그의 경우 JSTL과 동일합니다. when 태그와 otherwise 태그를 하위태그로 추가함으로써 switch문처럼 사용할 수 있습니다.member 테이블의 nick_name 컬럼도 검색의 대상이 되므로 join문을 통해 쿼리를 작성합니다. like 뒤에 문자열을 더하는 방법은 DB마다 차이가 있는데, 오라클 DB의 경우 '%'||#{search}||'%' 형태로 작성하여 문자열을 더할 수 있습니다.조건문에 따라 검색되는 튜플의 수가 달라지므로, 페이지를 올바르게 나타내기 위해서 getCount select 쿼리도 다음과 같이 수정합니다.컨트롤러 수정클라이언트가 검색기능을 요청하면 해당 서비스를 호출하도록 BoardController의 getBoardListView 메소드를 수정해주세요./kro/rubisco/controller/BoardController.java...    @GetMapping()    public String getBoardListView(        PageDTO&lt;BoardDTO&gt; boardPage,         SearchDTO search,        Model model    ) throws Exception {        model.addAttribute(\"pageInfo\", boardService.listAll(boardPage, search));        model.addAttribute(\"boardList\", boardPage.getContentList());        return \"board/getBoardList\";    }...매개변수로 SearchDTO 객체를 주입받고, 해당 객체를 boardService의 listAll 메소드에 주입하여 호출합니다.뷰 템플릿의 페이지 네비게션 url를 수정할 필요가 있는데 생략하고 템플릿을 작성할 때 수정하도록 하겠습니다.소스코드  ex_search.zip",
        "url": "/java/spring-legacy-search"
    }
    ,
    
    "java-spring-legacy-paging": {
        "title": "스프링 레거시(Spring legacy) - 페이징",
            "author": "rubisco",
            "category": "",
            "content": "저번 글에 이어서 board 모듈에 페이징 기능을 넣어보겠습니다. 스프링 부트에서는 JPA의 Pageable 인터페이스를 통해 쉽게 구현할 수 있지만 레거시에서는 객체를 만들어야합니다.DTO 작성우선 페이징 기능과 관련된 데이터를 가지는 PageDTO를 작성하도록 하겠습니다.다형성을 위해 제네릭으로 작성했습니다.page는 현재 페이지를, size는 한 페이지에 출력되는 리스트의 크기를 나타냅니다. 두 데이터는 클라이언트로부터 요청받을 수 있는 데이터입니다.totalSize는 한 테이블의 전체 튜플수를 저장하고, contentList는 한 페이지에 포함된 튜플 리스트를 저장합니다. 두 데이터는 DAO를 통해 DB로부터 전달받는 데이터 입니다.4개의 데이터는 유저의 요청과 응답을 저장해야하므로 setter를 만들어야 합니다.pageSize는 한 페이지에 출력할 페이지 네비게이션의 크기를 나타냅니다. 저는 계산용도로 고정값으로 설정할 예정이므로 static 키워드를 통해 정적변수로 선언하고 final 키워드를 통해 재할당이 불가능하도록 만들었습니다.totalPage는 전체 페이지의 수를 나타냅니다. hasPrev는 이전 페이지의 존재 여부를 나타내고, hasNext는 다음 페이지의 존재 여부를 나타냅니다. firstPage와 lastPage는 한 페이지 내에서 출력되는 페이지 네비게이션의 첫번째 페이지와 마지막 페이지 번호를 나타내고, first와 last는 한 페이지에 출력되는 튜플 중 첫번째 튜플과 마지막 튜플의 순서를 나타냅니다. 이 값들은 계산을 통해 출력만 가능하도록 멤버변수의 선언 없이 getter만 만들 예정입니다.마지막으로 프론트에서 url을 간편하게 출력할 수 있도록 getUrl 메소드를 만들었습니다. 매개변수로 base 주소와 페이지 번호를 주입받습니다.클래스 다이어그램을 참고하여 아래와 같이 DTO를 작성합시다./kro/rubisco/dto/PageDTO.javapackage kro.rubisco.dto;import java.util.ArrayList;import java.util.List;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class PageDTO &lt;T&gt; {        private static final long pageSize = 10;        private long page;    private long size = 10;    private long totalSize;        private List&lt;T&gt; contentList = new ArrayList&lt;T&gt;();        public long getPage() {        return page &lt; 1 ? 1 : page;    }        public long getTotalPage() {        return (long)Math.ceil((double)totalSize/size);    }        public boolean getHasPrev() {        return page &lt;= 1 ? false : true;    }        public boolean getHasNext() {        return page &gt;= getTotalPage() ? false : true;    }        public long getFirstPage() {        return ((getPage()-1)/pageSize|0)*pageSize + 1;    }        public long getLastPage() {        long lastPage = ((getPage()-1)/pageSize|0)*pageSize + pageSize;        return lastPage &lt; getTotalPage() ? lastPage : getTotalPage();    }        public long getFirst() {        long first = (getPage()-1) * size + 1;        return first &lt; 1 ? 1: first;    }        public long getLast() {        return getFirst() + size - 1;    }        public String getUrl(String base, long i) {                if(i &gt; 1 &amp;&amp; size != 10) base += \"?page=\" + i + \"&amp;size=\" + size;        else if(i &gt; 1) base += \"?page=\" + i;        else if(size != 10) base += \"?size=\" + size;                return base;    }}매퍼 수정boardDTO의 목록을 불러오는 listAll select 쿼리문을 다음과 같이 수정하겠습니다.boardMapper.xml...&lt;select id=\"listAll\" resultMap=\"getBoardList\"&gt;&lt;![CDATA[select * from (    select rownum num, b.*    from (        select * from board         where document_id &gt; 0        order by document_id desc    ) b    where rownum &lt;= #{last})where num &gt;= #{first}]]&gt;&lt;/select&gt;...저는 오라클 DB를 사용하기 때문에 limit를 사용하여 페이징 처리를 하지못하여 rownum을 사용해서 페이징 처리를 했습니다.rownum을 통해 페이징 처리를 하면 order by를 통해 정렬을 하기 전에 rownum 컬럼을 가진 튜플이 먼저 select되어 원하는 순서대로 페이징 처리가 되지 않으므로, 우선 서브쿼리를 통해 정렬한 테이블을 생성한 후 rownum 컬럼을 가진 튜플을 select하도록 쿼리문을 작성합니다.select된 튜플은 지난번에 작성한 getBoardList resultMap을 통해 매핑되도록 합니다.하나의 쿼리문을 통해 totalSize와 contentList를 한꺼번에 가져오려했지만 실패하여 2개의 쿼리문으로 나누어 아래와 같이 튜플의 전체 수를 출력하는 쿼리문을 작성합니다.boardMapper.xml...&lt;select id=\"getCount\" resultType=\"long\"&gt;select count(*) from board where document_id &gt; 0&lt;/select&gt;...DAO 수정위와 같이 작성된 쿼리문은 매개변수로 first와 last를 받고 있습니다. 즉, 파라미터로 BoardDTO 대신에 PageDTO를 주입해야합니다. BoardDAO를 다음과 같이 수정하겠습니다./kro/rubisco/dao/BoardDAO.javapackage kro.rubisco.dao;import java.util.List;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;public interface BoardDAO {        public void create(BoardDTO board) throws Exception;        public BoardDTO read(Long documentId) throws Exception;    public void update(BoardDTO board) throws Exception;    public void delete(Long documentId) throws Exception;    public List&lt;BoardDTO&gt; listAll(PageDTO&lt;BoardDTO&gt; boardPage) throws Exception;        public long getCount() throws Exception;}listAll 메소드가 BoardDTO 대신에 PageDTO&lt;BoardDTO&gt; 타입의 프로퍼티를 주입받고, BoardDTO의 리스트를 출력하도록 인터페이스를 수정했습니다. 또한 전체 튜플의 수를 출력하는 getCount 메소드를 정의했습니다.Service 수정BoardDAO의 listAll 메소드를 사용하는 BoardService의 listAll 메소드를 수정하도록 하겠습니다. 우선 인터페이스부터 다음과 같이 변경합니다./kro/rubisco/service/BoardService.javapackage kro.rubisco.service;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;public interface BoardService {      public void regist(BoardDTO board) throws Exception;      public BoardDTO read(Long documentId) throws Exception;      public void modify(BoardDTO board) throws Exception;      public void remove(Long documentId) throws Exception;            public PageDTO&lt;BoardDTO&gt; listAll(PageDTO&lt;BoardDTO&gt; boardPage) throws Exception;}listAll 메소드가 PageDTO&lt;BoardDTO&gt; 타입의 매개변수를 받고 동일한 타입을 반환하도록 작성했습니다.구현체도 수정합니다./kro/rubisco/service/impl/BoardServiceImpl.javapackage kro.rubisco.service.impl;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.BoardDAO;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;import kro.rubisco.service.BoardService;@Service@Transactional(readOnly = true)public class BoardServiceImpl implements BoardService {        private final BoardDAO boardDAO;        @Autowired        public BoardServiceImpl(SqlSession sqlSession) {                this.boardDAO = sqlSession.getMapper(BoardDAO.class);    }        @Override    public void regist(BoardDTO board) throws Exception {        boardDAO.create(board);    }    @Override    public BoardDTO read(Long documentId) throws Exception {        return boardDAO.read(documentId);    }    @Override    public void modify(BoardDTO board) throws Exception {        boardDAO.update(board);    }    @Override    public void remove(Long documentId) throws Exception {        boardDAO.delete(documentId);    }    @Override    public PageDTO&lt;BoardDTO&gt; listAll(PageDTO&lt;BoardDTO&gt; boardPage) throws Exception {        boardPage.setContentList(boardDAO.listAll(boardPage));        boardPage.setTotalSize(boardDAO.getCount());        return boardPage;    }}listAll 메소드에서 boardDAO를 통해 select된 contentList와 totalSize를 setter로 주입하여 해당 객체를 반환하도록 작성했습니다.컨트롤러 수정마지막으로 컨트롤러를 수정하겠습니다. getBoardListView 메소드를 다음과 같이 수정합니다./kro/rubisco/controller/BoardController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import kro.rubisco.dto.BoardDTO;import kro.rubisco.dto.PageDTO;import kro.rubisco.service.BoardService;import kro.rubisco.service.CategoryService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/board\")public class BoardController {    private final BoardService boardService;    private final CategoryService categoryService;        @GetMapping()    public String getBoardListView(PageDTO&lt;BoardDTO&gt; boardPage, Model model) throws Exception {        model.addAttribute(\"pageInfo\", boardService.listAll(boardPage));        model.addAttribute(\"boardList\", boardPage.getContentList());        return \"board/getBoardList\";    }        @GetMapping(\"/{documentId}\")    public String getBoardView(        @PathVariable(\"documentId\") Long documentId,         Model model    ) throws Exception {        model.addAttribute(\"board\", boardService.read(documentId));        return \"board/getBoard\";    }        @GetMapping(params = \"act=write\")    public String getInsertBoardView(        @RequestParam(value=\"documentId\", required=false) Long documentId,        Model model    ) throws Exception {        model.addAttribute(\"board\", documentId == null ? new BoardDTO() : boardService.read(documentId));        model.addAttribute(\"categoryList\", categoryService.listAll());        return \"board/insertBoard\";    }        @PostMapping()    public String insertBoard(BoardDTO board) throws Exception {        boardService.regist(board);        return \"redirect:/board/\" + board.getDocumentId();    }        @PatchMapping(params = \"documentId\")    public String updateBoard(BoardDTO board) throws Exception {        boardService.modify(board);        return \"redirect:/board/\" + board.getDocumentId();    }        @DeleteMapping(params = \"documentId\")    public String deleteBoard(        @RequestParam(\"documentId\") Long documentId    )throws Exception {        boardService.remove(documentId);        return \"redirect:/board\";    }}PageDTO 객체의 contentList 프로퍼티에는 boardService의 listAll 메소드를 통해 사용자가 요청한 페이지의 게시글 목록이 저장됩니다. 이를 모델에 넣고 뷰 이름을 반환하면 view resolver가 뷰 이름에 해당하는 파일을 파싱하여 뷰 객체를 형성합니다.뷰 템플릿 작성페이징이 되는지 확인하기 위해 간단하게 게시글 목록 템플릿을 작성하겠습니다. 레거시에서는 기본 템플릿 엔진으로 jsp를 사용합니다. jsp는 Java Server Page의 약자로, HTML 코드 내에 JAVA 코드를 넣기 위해 만들어졌습니다.뷰의 작성은 추후에 종류별로 알아보도록 하고, 여기에서는 페이징 기능을 확인하기 위해 간단히 템플릿을 작성하겠습니다.우선 /src/main/webapp/WEB-INF/views/ 경로 아래에 board 폴더를 만들고 getBoardList.jsp 파일을 생성하여 다음과 같이 작성합니다./src/main/webapp/WEB-INF/views/board/getBoardList.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp\"&gt;&lt;/script&gt;    &lt;%@ include file=\"./include/tailwindcss.jsp\" %&gt;    &lt;title&gt;게시글 목록&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;main&gt;    &lt;h1&gt;게시글 목록&lt;/h1&gt;    &lt;article&gt;        &lt;table&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;&lt;/th&gt;                    &lt;th scope=\"col\"&gt;카테고리&lt;/th&gt;                    &lt;th scope=\"col\" class=\"w-full\"&gt;제목&lt;/th&gt;                    &lt;th scope=\"col\"&gt;작성자&lt;/th&gt;                    &lt;th scope=\"col\"&gt;등록일&lt;/th&gt;                    &lt;th scope=\"col\"&gt;조회수&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;            &lt;c:forEach items=\"${boardList}\" var=\"board\" step=\"1\" varStatus=\"status\"&gt;                &lt;tr&gt;                    &lt;td&gt;${pageInfo.totalSize - pageInfo.first - status.index + 1}&lt;/td&gt;                    &lt;td&gt;${board.category.category}&lt;/td&gt;                    &lt;td&gt;&lt;a href=\"/board/${board.documentId}\"&gt;${board.title}&lt;/a&gt;&lt;/td&gt;                    &lt;td&gt;${board.member.nickName}&lt;/td&gt;                    &lt;td&gt;&lt;fmt:formatDate value=\"${board.createDate}\" pattern=\"yyyy-MM-dd\"/&gt;&lt;/td&gt;                    &lt;td&gt;${board.readCount}&lt;/td&gt;                &lt;/tr&gt;            &lt;/c:forEach&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/article&gt;    &lt;div class=\"flex mt-2 sm:mt-4 lg:w-2/3 w-full mx-auto\"&gt;        &lt;button class=\"write\" onClick=\"window.location='/board?act=write'\"&gt;쓰기&lt;/button&gt;    &lt;/div&gt;    &lt;%@ include file=\"./include/pageNav.jsp\" %&gt;&lt;/main&gt;&lt;/body&gt;&lt;/html&gt;tailwindcss를 통해 뷰를 개발했습니다. 상단에는 java를 통해 실행되는 jsp 파일임을 명시하고, 그 아래에는 JSTL을 사용하기 위한 taglib을 작성했습니다. 기본 기능인 core와 포멧팅을 위한 fmt 태그라이브러리를 설정했습니다. 또한 include를 통해 통해 조각으로 나누어 작성했습니다. 타임리프의 fragment 기능과 동일하다고 보면 됩니다.나머지 include 조각들도 작성하겠습니다./src/main/webapp/WEB-INF/views/board/include/tailwindcss.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;style type=\"text/tailwindcss\"&gt;    main {@apply text-gray-600 container px-5 py-16 mx-auto}    main &gt; h1 {@apply flex flex-col text-center w-full sm:text-4xl text-2xl font-medium mb-5 text-gray-900}    article {@apply lg:w-2/3 w-full mx-auto overflow-auto}    table {@apply table-auto w-full text-xs sm:text-sm}    table &gt; thead &gt; tr &gt; th {@apply px-2 py-2 sm:px-4 sm:py-3 tracking-wider font-medium text-gray-900 bg-gray-100 text-center whitespace-nowrap align-middle}    table &gt; thead &gt; tr &gt; th:first-of-type {@apply rounded-tl rounded-bl}    table &gt; thead &gt; tr &gt; th:nth-of-type(3) {@apply text-left}    table &gt; thead &gt; tr &gt; th:last-of-type {@apply rounded-tr rounded-br}    table &gt; tbody &gt; tr {@apply hover:bg-slate-100}    table &gt; tbody &gt; tr &gt; td {@apply px-2 py-2 sm:px-4 sm:py-3 text-center whitespace-nowrap align-middle}    table &gt; tbody &gt; tr &gt; td:nth-of-type(3) {@apply p-0 text-left}    table &gt; tbody &gt; tr &gt; td &gt; a {@apply block}    table &gt; tbody &gt; tr &gt; td:nth-of-type(3) &gt; a {@apply px-2 py-2 sm:px-4 sm:py-3}    button.write {@apply flex ml-auto text-white text-sm sm:text-base bg-indigo-500 border-0 py-1 px-3 sm:py-2 sm:px-6 focus:outline-none hover:bg-indigo-600 rounded}    nav {@apply isolate flex -space-x-px rounded-md mt-2 sm:mt-4 lg:w-2/3 w-full mx-auto justify-center}    nav &gt; a {@apply relative inline-flex items-center border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-500 focus:z-20}    nav &gt; a:not(.active) {@apply hover:bg-gray-50}    nav &gt; a.active {@apply pointer-events-none border-indigo-500 bg-indigo-50 text-indigo-600 z-10}    nav &gt; a:first-of-type {@apply px-2 rounded-l-md}    nav &gt; a:last-of-type {@apply px-2 rounded-r-md}    nav &gt; a.disabled {@apply pointer-events-none bg-slate-200 text-slate-400 border-slate-400}&lt;/style&gt;/src/main/webapp/WEB-INF/views/board/include/pageNav.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;nav aria-label=\"Pagination\"&gt;    &lt;c:choose&gt;        &lt;c:when test=\"${pageInfo.hasPrev}\"&gt;&lt;c:set var=\"url\" value=\"${pageInfo.getUrl('/board', pageInfo.page - 1)}\" /&gt;&lt;/c:when&gt;        &lt;c:otherwise&gt;&lt;c:set var=\"url\" value=\"#\" /&gt;&lt;/c:otherwise&gt;    &lt;/c:choose&gt;    &lt;a href=\"${url}\"&lt;c:if test=\"${!pageInfo.hasPrev}\"&gt; class=\"disabled\"&lt;/c:if&gt;&gt;        &lt;span class=\"sr-only\"&gt;Previous&lt;/span&gt;        &lt;svg class=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\"&gt;            &lt;path fill-rule=\"evenodd\" d=\"M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z\" clip-rule=\"evenodd\" /&gt;        &lt;/svg&gt;    &lt;/a&gt;    &lt;c:forEach var=\"i\" begin=\"${pageInfo.firstPage}\" end=\"${pageInfo.lastPage}\" step=\"1\"&gt;    &lt;a href=\"${pageInfo.getUrl('/board', i)}\"&lt;c:if test=\"${pageInfo.page eq i}\"&gt;aria-current=\"page\" class=\"active\"&lt;/c:if&gt;&gt;${i}&lt;/a&gt;    &lt;/c:forEach&gt;    &lt;c:choose&gt;        &lt;c:when test=\"${pageInfo.hasNext}\"&gt;&lt;c:set var=\"url\" value=\"${pageInfo.getUrl('/board', pageInfo.page + 1)}\" /&gt;&lt;/c:when&gt;        &lt;c:otherwise&gt;&lt;c:set var=\"url\" value=\"#\" /&gt;&lt;/c:otherwise&gt;    &lt;/c:choose&gt;    &lt;a href=\"${url}\"&lt;c:if test=\"${!pageInfo.hasNext}\"&gt; class=\"disabled\"&lt;/c:if&gt;&gt;        &lt;span class=\"sr-only\"&gt;Next&lt;/span&gt;        &lt;svg class=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\"&gt;            &lt;path fill-rule=\"evenodd\" d=\"M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z\" clip-rule=\"evenodd\" /&gt;        &lt;/svg&gt;    &lt;/a&gt;&lt;/nav&gt;DBEver를 통해 예제 데이터 1000개를 입력해줍시다.테스트 데이터 입력BEGIN    FOR i IN 1..1000 LOOP        INSERT INTO BOARD (MEMBER_ID, CATEGORY_ID, TITLE, CONTENT)         VALUES (1, 1, '테스트'||i, '테스트'||i);    END LOOP;END;localhost:8080/board에 접속하면 다음과 같이 페이징 처리가 되어 출력됩니다.소스코드  ex_paging.zip",
        "url": "/java/spring-legacy-paging"
    }
    ,
    
    "java-spring-legacy-service-and-controller": {
        "title": "스프링 레거시(Spring legacy) - Service, Controller 작성",
            "author": "rubisco",
            "category": "",
            "content": "서비스(Service) 작성서비스에서는 DAO의 메소드를 호출하여 비즈니스 로직을 수행합니다.서비스 스캔 등록우선 서비스를 스캔할 수 있도록 스프링의 root-context.xml 파일에 서비스 컴포넌트 스캔 경로를 추가해줍시다. 아래 예시의 경우 kro.rubisco.service 패키지를 컴포넌트 스캔 경로로 등록했습니다.src/main/webapp/WEB-INF/spring/root-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans     https://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt;        &lt;!-- Root Context: defines shared resources visible to all other web components --&gt;    &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\" name=\"dataSource\"&gt;          &lt;property value=\"oracle.jdbc.driver.OracleDriver\" name=\"driverClassName\"/&gt;          &lt;property value=\"[DB 주소]\" name=\"url\"/&gt;          &lt;property value=\"[DB 아이디]\" name=\"username\"/&gt;          &lt;property value=\"[DB 암호]\" name=\"password\"/&gt;    &lt;/bean&gt;             &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;          &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\"&gt;&lt;/property&gt;                &lt;/bean&gt;    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt;        &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;        &lt;context:component-scan base-package=\"kro.rubisco.service\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;서비스 인터페이스 작성이제 서비스의 인터페이스를 작성하겠습니다. Board, Category, Comment, Group, Member에 대하여 CRUD 기능을 넣었습니다. DAO와 유사합니다./kro/rubisco/service/BoardService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.BoardDTO;public interface BoardService {      public void regist(BoardDTO board) throws Exception;      public BoardDTO read(Long documentId) throws Exception;      public void modify(BoardDTO board) throws Exception;      public void remove(Long documentId) throws Exception;      public List&lt;BoardDTO&gt; listAll() throws Exception;}/kro/rubisco/service/CategoryService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.CategoryDTO;public interface CategoryService {      public void regist(CategoryDTO category) throws Exception;      public CategoryDTO read(Long categoryId) throws Exception;      public void modify(CategoryDTO category) throws Exception;      public void remove(Long categoryId) throws Exception;      public List&lt;CategoryDTO&gt; listAll() throws Exception;}/kro/rubisco/service/GroupService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.GroupDTO;public interface GroupService {      public void regist(GroupDTO group) throws Exception;      public GroupDTO read(Long groupId) throws Exception;      public void modify(GroupDTO group) throws Exception;      public void remove(Long groupId) throws Exception;      public List&lt;GroupDTO&gt; listAll() throws Exception;}/kro/rubisco/service/MemberService.javapackage kro.rubisco.service;import java.util.List;import kro.rubisco.dto.MemberDTO;public interface MemberService {          public void regist(MemberDTO member) throws Exception;      public MemberDTO read(Long memberId) throws Exception;      public void modify(MemberDTO member) throws Exception;      public void remove(Long memberId) throws Exception;      public List&lt;MemberDTO&gt; listAll() throws Exception;}서비스 구현이제 서비스 인터페이스의 구현체를 작성합니다. @Service 어노테이션을 통해 서비스 컴포넌트임을 선언하고, sqlSession에 DAO 인터페이스를 연결하여 DAO 구현체를 생성자 주입합니다.DAO 구현체를 통해 CRUD 쿼리를 실행시킬 수 있으며, @Transactional 어노테이션을 통해 트랜잭션 처리를 할 수 있습니다./kro/rubisco/service/impl/BoardServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.BoardDAO;import kro.rubisco.dto.BoardDTO;import kro.rubisco.service.BoardService;@Service@Transactional(readOnly = true)public class BoardServiceImpl implements BoardService {    private final BoardDAO boardDAO;        @Autowired    public BoardServiceImpl(SqlSession sqlSession) {        this.boardDAO = sqlSession.getMapper(BoardDAO.class);    }        @Override    public void regist(BoardDTO board) throws Exception {        boardDAO.create(board);    }    @Override    public BoardDTO read(Long documentId) throws Exception {        return boardDAO.read(documentId);    }    @Override    public void modify(BoardDTO board) throws Exception {        boardDAO.update(board);    }    @Override    public void remove(Long documentId) throws Exception {        boardDAO.delete(documentId);    }    @Override    public List&lt;BoardDTO&gt; listAll() throws Exception {        return boardDAO.listAll();    }}/kro/rubisco/service/impl/CategoryServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.CategoryDAO;import kro.rubisco.dto.CategoryDTO;import kro.rubisco.service.CategoryService;@Service@Transactional(readOnly = true)public class CategoryServiceImpl implements CategoryService {    private final CategoryDAO categoryDAO;        @Autowired    public CategoryServiceImpl(SqlSession sqlSession) {        this.categoryDAO = sqlSession.getMapper(CategoryDAO.class);    }        @Override    public void regist(CategoryDTO category) throws Exception {        categoryDAO.create(category);    }    @Override    public CategoryDTO read(Long categoryId) throws Exception {        return categoryDAO.read(categoryId);    }    @Override    public void modify(CategoryDTO category) throws Exception {        categoryDAO.update(category);    }    @Override    public void remove(Long categoryId) throws Exception {        categoryDAO.delete(categoryId);    }    @Override    public List&lt;CategoryDTO&gt; listAll() throws Exception {        return categoryDAO.listAll();    }}/kro/rubisco/service/impl/CommentServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.CommentDAO;import kro.rubisco.dto.CommentDTO;import kro.rubisco.service.CommentService;@Service@Transactional(readOnly = true)public class CommentServiceImpl implements CommentService {    private final CommentDAO commentDAO;        @Autowired    public CommentServiceImpl(SqlSession sqlSession) {        this.commentDAO = sqlSession.getMapper(CommentDAO.class);    }        @Override    public void regist(CommentDTO comment) throws Exception {        commentDAO.create(comment);    }    @Override    public CommentDTO read(Long commentId) throws Exception {        return commentDAO.read(commentId);    }    @Override    public void modify(CommentDTO comment) throws Exception {        commentDAO.update(comment);    }    @Override    public void remove(Long commentId) throws Exception {        commentDAO.delete(commentId);    }    @Override    public List&lt;CommentDTO&gt; listAll() throws Exception {        return commentDAO.listAll();    }}/kro/rubisco/service/impl/GroupServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.GroupDAO;import kro.rubisco.dto.GroupDTO;import kro.rubisco.service.GroupService;@Service@Transactional(readOnly = true)public class GroupServiceImpl implements GroupService {        private final GroupDAO groupDAO;        @Autowired    public GroupServiceImpl(SqlSession sqlSession) {        this.groupDAO = sqlSession.getMapper(GroupDAO.class);    }    @Override    public void regist(GroupDTO group) throws Exception {        groupDAO.create(group);    }    @Override    public GroupDTO read(Long groupId) throws Exception {        return groupDAO.read(groupId);    }    @Override    public void modify(GroupDTO group) throws Exception {        groupDAO.update(group);    }    @Override    public void remove(Long groupId) throws Exception {        groupDAO.delete(groupId);    }    @Override    public List&lt;GroupDTO&gt; listAll() throws Exception {        return groupDAO.listAll();    }}/kro/rubisco/service/impl/MemberServiceImpl.javapackage kro.rubisco.service.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kro.rubisco.dao.MemberDAO;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;@Service@Transactional(readOnly = true)public class MemberServiceImpl implements MemberService {    private final MemberDAO memberDAO;        @Autowired    public MemberServiceImpl(SqlSession sqlSession) {        this.memberDAO = sqlSession.getMapper(MemberDAO.class);    }        @Override    public void regist(MemberDTO member) throws Exception {        memberDAO.create(member);    }    @Override    public MemberDTO read(Long memberId) throws Exception {        return memberDAO.read(memberId);    }    @Override    public void modify(MemberDTO member) throws Exception {        memberDAO.update(member);    }    @Override    public void remove(Long memberId) throws Exception {        memberDAO.delete(memberId);    }    @Override    public List&lt;MemberDTO&gt; listAll() throws Exception {        return memberDAO.listAll();    }}컨트롤러(Controller) 작성컨트롤러에서는 사용자의 요청을 받아 서비스를 호출하고 DispatcherServlet에 ModelAndView를 반환합니다.루트 경로 변경우선 톰캣의 루트 경로를 수정합니다. 왼쪽 하단에 톰캣 서버를 더블클릭하세요.Modules 탭을 선택하고 Edit... 버튼을 클릭합니다.Path를 /로 설정하고 OK버튼을 클릭 후 서버를 재시작합니다.컨트롤러 스캔 등록컨트롤러를 스캔할 수 있도록 스프링의 servlet-context.xml 파일에 컨트롤러 컴포넌트 스캔 경로를 추가해줍시다. 아래 예시의 경우 kro.rubisco.controller 패키지를 컴포넌트 스캔 경로로 등록했습니다.src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans:beans xmlns=\"http://www.springframework.org/schema/mvc\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xmlns:beans=\"http://www.springframework.org/schema/beans\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xsi:schemaLocation=\"http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure --&gt;        &lt;!-- Enables the Spring MVC @Controller programming model --&gt;    &lt;annotation-driven /&gt;    &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory --&gt;    &lt;resources mapping=\"/resources/**\" location=\"/resources/\" /&gt;    &lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt;    &lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt;        &lt;beans:property name=\"suffix\" value=\".jsp\" /&gt;    &lt;/beans:bean&gt;        &lt;context:component-scan base-package=\"kro.rubisco.controller\" /&gt;&lt;/beans:beans&gt;필터 추가한글 깨짐 문제를 해결하고 get, post 이외의 전송방식을 구현하기위해 web.xml 파일에 encodingFilter와 httpMethodFilter를 추가합니다.src/main/webapp/WEB-INF/web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt;    &lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- Processes application requests --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;            &lt;servlet-mapping&gt;        &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;        &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter&gt;        &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;매퍼 수정게시글이 입력되면 id값이 BoardDTO에 반환될 수 있도록 boardMapper의 insert 태그 아래에 selectKey 태그를 추가해줍니다.boardMapper.xml...&lt;insert id=\"create\"&gt;insert into board (category_id, is_notice, title, content, member_id)values (#{categoryId}, #{isNotice, typeHandler=kro.rubisco.config.YNTypeHandler}, #{title}, #{content}, #{memberId})&lt;selectKey keyProperty=\"documentId\" resultType=\"Long\" order=\"AFTER\"&gt;select max(document_id) as document_id from board&lt;/selectKey&gt;&lt;/insert&gt;...order 속성이 AFTER 이므로, insert 쿼리가 수행된 후에 selectKey 쿼리를 수행하여 BoardDTO의 documentId에 결과값을 반환합니다.컨트롤러 구현BoardController, CommentController, MemberController, AdminController를 작성하도록 하겠습니다./kro/rubisco/controller/BoardController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import kro.rubisco.dto.BoardDTO;import kro.rubisco.service.BoardService;import kro.rubisco.service.CategoryService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/board\")public class BoardController {    private final BoardService boardService;    private final CategoryService categoryService;        @GetMapping()    public String getBoardListView(Model model) throws Exception {        model.addAttribute(\"boardList\", boardService.listAll());        return \"board/getBoardList\";    }        @GetMapping(\"/{documentId}\")    public String getBoardView(        @PathVariable(\"documentId\") Long documentId,         Model model    ) throws Exception {        model.addAttribute(\"board\", boardService.read(documentId));        return \"board/getBoard\";    }        @GetMapping(params = \"act=write\")    public String getInsertBoardView(        @RequestParam(value=\"documentId\", required=false) Long documentId,        Model model    ) throws Exception {        model.addAttribute(\"board\", documentId == null ? new BoardDTO() : boardService.read(documentId));        model.addAttribute(\"categoryList\", categoryService.listAll());        return \"board/insertBoard\";    }        @PostMapping()    public String insertBoard(BoardDTO board) throws Exception {        boardService.regist(board);        return \"redirect:/board/\" + board.getDocumentId();    }        @PatchMapping(params = \"documentId\")    public String updateBoard(BoardDTO board) throws Exception {        boardService.modify(board);        return \"redirect:/board/\" + board.getDocumentId();    }        @DeleteMapping(params = \"documentId\")    public String deleteBoard(        @RequestParam(\"documentId\") Long documentId    )throws Exception {        boardService.remove(documentId);        return \"redirect:/board\";    }}/kro/rubisco/controller/CommentController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.dto.CommentDTO;import kro.rubisco.service.CommentService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/comment\")public class CommentController {        private CommentService commentService;        @PostMapping(params = \"commentId\")    public String insertComment(CommentDTO comment) throws Exception {        commentService.regist(comment);        return \"redirect:/board/\" + comment.getDocumentId();    }        @PatchMapping(params = \"commentId\")    public String updateComment(CommentDTO comment) throws Exception {        commentService.modify(comment);        return \"redirect:/board/\" + comment.getDocumentId();    }        @DeleteMapping(params = \"commentId\")    public String deleteComment(CommentDTO comment) throws Exception {        commentService.remove(comment.getCommentId());        return \"redirect:/board/\" + comment.getDocumentId();    }}/kro/rubisco/controller/MemberController.javapackage kro.rubisco.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.dto.MemberDTO;import kro.rubisco.service.MemberService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/member\")public class MemberController {    private final MemberService memberService;        @GetMapping()    public String getMemberInfo() {        return \"member/getMemberInfo\";    }        @GetMapping(params=\"act=signUp\")    public String getSignUpView() throws Exception {        return \"member/signUpForm\";    }        @PostMapping()    public String insertMember(MemberDTO member) throws Exception {        memberService.regist(member);        return \"redirect:/\";    }        @PatchMapping()    public String updateMember(MemberDTO member) throws Exception {        memberService.modify(member);        return \"redirect:/member\";    }        @DeleteMapping()    public String deleteMember() throws Exception {        return \"redirect:/\";    }}/kro/rubisco/controller/AdminController.javapackage kro.rubisco.controller;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kro.rubisco.dto.CategoryDTO;import kro.rubisco.dto.GroupDTO;import kro.rubisco.service.CategoryService;import kro.rubisco.service.GroupService;import lombok.RequiredArgsConstructor;@Controller@RequiredArgsConstructor@RequestMapping(\"/admin\")public class AdminController {    private final CategoryService categoryService;    private final GroupService groupService;        @GetMapping(\"/category\")    public String getCategoryListView(Model model) throws Exception {        List&lt;CategoryDTO&gt; categoryList = categoryService.listAll();        model.addAttribute(\"categoryList\", categoryList);        return \"category/getCategoryList\";    }        @PostMapping(\"/category\")    public String insertCategory(CategoryDTO category) throws Exception {        categoryService.regist(category);        return \"redirect:/admin/category\";    }        @PatchMapping(\"/category\")    public String updateCategory(CategoryDTO category) throws Exception {        categoryService.modify(category);        return \"redirect:/admin/category\";    }        @GetMapping(\"/group\")    public String getGroupListView(Model model) throws Exception {        List&lt;GroupDTO&gt; groupList = groupService.listAll();        model.addAttribute(\"groupList\", groupList);        return \"group/getGroupList\";    }        @PostMapping(\"/group\")    public String insertGroup(GroupDTO group) throws Exception {        groupService.regist(group);        return \"redirect:/admin/group\";    }        @PatchMapping(\"/group\")    public String updateCategory(GroupDTO group) throws Exception {        groupService.modify(group);        return \"redirect:/admin/group\";    }}소스코드  service_controller.zip",
        "url": "/java/spring-legacy-service-and-controller"
    }
    ,
    
    "java-spring-legacy-dto-and-dao": {
        "title": "스프링 레거시(Spring legacy) - DTO, DAO 작성",
            "author": "rubisco",
            "category": "",
            "content": "DTO 작성DTO는 Data transfer Object의 약자로, 데이터 전송 객체입니다. 스프링 부트 프로젝트에서 JPA를 사용할때는 Entity에 @Transient 어노테이션을 붙이고 빌더를 만들어 DTO 대신 사용했습니다.저번 글에서 매퍼를 만들때 BoardDTO, CommentDTO, CategoryDTO, MemberDTO, GroupDTO를 resultType으로 매핑했기때문에 해당 DTO를 만들도록 하겠습니다.mybatis-config.xml 파일에 kro.rubisco.dto 폴더를 패키지의 alias로 설정해주었으므로 해당 경로 아래에 DTO를 작성합니다. 각각의 매퍼에 대하여 매핑할 데이터와 getter, setter 정도만 작성하겠습니다.getter와 setter는 롬복을 사용하여 작성하겠습니다.BaseTime공통 속성으로 사용할 createDate와 updateDate을 담고있는 객체입니다. 저번 글에서 작성한 매퍼에서 SYSDATE를 통해 처리하여 지금 상황에서는 불필요하겠으나, 일단 만들어두고 각각의 DTO가 상속받도록 하겠습니다./kro/rubisco/dto/BaseTime.javapackage kro.rubisco.dto;import java.util.Date;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class BaseTime {    private Date createDate;    private Date updateDate;}GroupDTO속성으로 멤버의 인가권한 데이터를 가지는 객체입니다./kro/rubisco/dto/GroupDTO.javapackage kro.rubisco.dto;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class GroupDTO extends BaseTime {    private Long groupId;    private String groupName;}MemberDTO속성으로 멤버의 데이터를 가지는 객체입니다./kro/rubisco/dto/MemberDTO.javapackage kro.rubisco.dto;import java.util.Date;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class MemberDTO {    private Long memberId;    private String password;    private String email;    private String name;    private String nickName;    private Long groupId;    private GroupDTO group;    private Date createDate;    private Date lastLogin;}CategoryDTO속성으로 게시글을 분류할 카테고리의 데이터를 가지는 객체입니다./kro/rubisco/dto/CategoryDTO.javapackage kro.rubisco.dto;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class CategoryDTO extends BaseTime {    private Long categoryId;    private String category;}BoardDTO속성으로 게시글 데이터를 가지는 객체입니다./kro/rubisco/dto/BoardDTO.javapackage kro.rubisco.dto;import java.util.List;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class BoardDTO extends BaseTime {    private Long documentId;    private Long categoryId;    private Boolean isNotice;    private String title;    private String content;    private Long likeCount;    private Long dislikeCount;    private Long readCount;    private Long memberId;    private Long groupId;    private List&lt;CommentDTO&gt; commentList;    private CategoryDTO category;    private MemberDTO member;    private GroupDTO group;}CommentDTO속성으로 댓글 데이터를 가지는 객체입니다./kro/rubisco/dto/CommentDTO.javapackage kro.rubisco.dto;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class CommentDTO extends BaseTime {    private Long commentId;    private Long documentId;    private String content;    private Long likeCount;    private Long dislikeCount;    private Long memberId;    private BoardDTO board;    private MemberDTO member;}TypeHandler 작성BoardDTO에서 isNotice 변수는 Boolean 타입입니다. 하지만 테이블에서 is_notice 속성은 CHAR 타입으로 Y 또는 N이라는 문자열을 가지게 됩니다. 그러므로 매핑할때 타입의 전환이 필요합니다.kro.rubisco.config 라는 패키지 폴더를 생성하고 그 아래에 TypeHandler 인터페이스를 구현한 YNTypeHandler를 작성하도록 하겠습니다./kro/rubisco/config/YNTypeHandler.javapackage kro.rubisco.config;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.TypeHandler;public class YNTypeHandler implements TypeHandler&lt;Boolean&gt; {    @Override    public void setParameter(PreparedStatement ps, int i, Boolean parameter, JdbcType jdbcType) throws SQLException {        ps.setString(i, parameter != null &amp;&amp; parameter ? \"Y\" : \"N\" );    }    @Override    public Boolean getResult(ResultSet rs, String columnName) throws SQLException {        return \"Y\".equals(rs.getString(columnName));    }    @Override    public Boolean getResult(ResultSet rs, int columnIndex) throws SQLException {        return \"Y\".equals(rs.getString(columnIndex));    }    @Override    public Boolean getResult(CallableStatement cs, int columnIndex) throws SQLException {        return \"Y\".equals(cs.getString(columnIndex));    }}boardMapper에서 isNotice 속성을 TypeHandler를 통해 YN 타입으로 전환하여 매핑합니다. 저번 글에서 작성한 boardMapper.xml 파일에서 resultMap 태그와 insert, update 태그를 아래와 같이 수정합니다./src/main/resources/mappers/boardMapper.xml&lt;resultMap id=\"getBoard\" type=\"BoardDTO\"&gt;    &lt;id property=\"documentId\" column=\"document_id\" /&gt;    &lt;result property=\"isNotice\" column=\"is_notice\" typeHandler=\"kro.rubisco.config.YNTypeHandler\" /&gt;    &lt;association property=\"category\" column=\"category_id\" javaType=\"CategoryDTO\" select=\"getCategory\" /&gt;    &lt;association property=\"member\" column=\"member_id\" javaType=\"MemberDTO\" select=\"getMember\" /&gt;    &lt;association property=\"group\" column=\"group_id\" javaType=\"GroupDTO\" select=\"getGroup\" /&gt;    &lt;collection property=\"commentList\" column=\"document_id\" javaType=\"java.util.List\" ofType=\"CommentDTO\" select=\"getComments\" /&gt;&lt;/resultMap&gt;...&lt;insert id=\"create\"&gt;insert into board (category_id, is_notice, title, content, member_id)values (#{categoryId}, #{isNotice, typeHandler=kro.rubisco.config.YNTypeHandler}, #{title}, #{content}, #{memberId})&lt;/insert&gt;...&lt;update id=\"update\"&gt;update board set category_id=#{categoryId},     is_notice=#{isNotice, typeHandler=kro.rubisco.config.YNTypeHandler},     title=#{title},     content=#{content},      update_date=SYSDATEwhere document_id = #{documentId}&lt;/update&gt;DAO 작성DAO는 Data Access Object의 약자로, Repository 객체에 해당하는 데이터 접근 객체입니다. 인터페이스를 작성해서 mapper에 매핑하면 DAO 객체를 생성하여 sqlSession을 통해 sql문을 실행할 수 있습니다.mapper에 의하여 매핑되는 Mapper 객체라는 것을 선언하기위해 @Mapper 어노테이션을 붙여줍시다./kro/rubisco/dao/BoardDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.BoardDTO;@Mapperpublic interface BoardDAO {        public void create(BoardDTO board) throws Exception;        public BoardDTO read(Long documentId) throws Exception;    public void update(BoardDTO board) throws Exception;    public void delete(Long documentId) throws Exception;    public List&lt;BoardDTO&gt; listAll() throws Exception;}/kro/rubisco/dao/CategoryDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.CategoryDTO;@Mapperpublic interface CategoryDAO {    public void create(CategoryDTO category) throws Exception;        public CategoryDTO read(Long categoryId) throws Exception;    public void update(CategoryDTO category) throws Exception;    public void delete(Long categoryId) throws Exception;    public List&lt;CategoryDTO&gt; listAll() throws Exception;}/kro/rubisco/dao/CommentDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.CommentDTO;@Mapperpublic interface CommentDAO {    public void create(CommentDTO comment) throws Exception;        public CommentDTO read(Long commentId) throws Exception;    public void update(CommentDTO comment) throws Exception;    public void delete(Long commentId) throws Exception;    public List&lt;CommentDTO&gt; listAll() throws Exception;}/kro/rubisco/dao/GroupDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.GroupDTO;@Mapperpublic interface GroupDAO {        public void create(GroupDTO group) throws Exception;        public GroupDTO read(Long groupId) throws Exception;    public void update(GroupDTO group) throws Exception;    public void delete(Long groupId) throws Exception;    public List&lt;GroupDTO&gt; listAll() throws Exception;}/kro/rubisco/dao/MemberDAO.javapackage kro.rubisco.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import kro.rubisco.dto.MemberDTO;@Mapperpublic interface MemberDAO {    public void create(MemberDTO member) throws Exception;        public MemberDTO read(Long memberId) throws Exception;    public void update(MemberDTO member) throws Exception;    public void delete(Long memberId) throws Exception;    public List&lt;MemberDTO&gt; listAll() throws Exception;}소스코드  mapper.zip  dao_dto.zip",
        "url": "/java/spring-legacy-dto-and-dao"
    }
    ,
    
    "java-spring-legacy-mapper": {
        "title": "스프링 레거시(Spring legacy) - 매퍼 작성",
            "author": "rubisco",
            "category": "",
            "content": "매퍼(mapper) 작성매퍼(mapper)는 sqlSession을 통해서 repository에 해당하는 DAO에 SQL 쿼리문을 연결하여 실행합니다.우선 매퍼를 작성하기 전에 테이블을 생성하겠습니다. 레거시에서는 DDL을 자동으로 작성해주지 않아서 수동으로 테이블을 만들어야합니다. DBeaver를 통해서 스키마를 생성해주세요.테이블은 이전에 작성한 ER모델을 참고하여 작성하겠습니다.게시글을 저장하는 board, 댓글을 저장하는 comments, 게시글을 분류하는 category, 인증을 위한 member, 인가권한을 확인하기 위한member_group로 구성합니다.CREATE TABLE board (    document_id        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    category_id        INT NOT NULL,    is_notice        CHAR(1) DEFAULT 'N',    title            VARCHAR(250) NOT NULL,    content            CLOB NOT NULL,    like_count        INT DEFAULT 0,    dislike_count    INT DEFAULT 0,    read_count        INT DEFAULT 0,    member_id        INT NOT NULL,    create_date        DATE DEFAULT SYSDATE,    update_date        DATE DEFAULT SYSDATE);CREATE TABLE comments (    comment_id        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    document_id        INT NOT NULL,    content            CLOB,    like_count        INT DEFAULT 0,    dislike_count    INT DEFAULT 0,    member_id        INT NOT NULL,    create_date        DATE DEFAULT SYSDATE,    update_date        DATE DEFAULT SYSDATE);CREATE TABLE category (    category_id        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    category        VARCHAR(80) UNIQUE NOT NULL,    create_date        DATE DEFAULT SYSDATE,    update_date        DATE DEFAULT SYSDATE);CREATE TABLE MEMBER (    member_id        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    password        VARCHAR(60) NOT NULL,    email            VARCHAR(250) UNIQUE,    name            VARCHAR(40) NOT NULL,    nick_name        VARCHAR(40) UNIQUE NOT NULL,    group_id        INT NOT NULL,    create_date        DATE DEFAULT SYSDATE,    last_login        DATE DEFAULT SYSDATE);CREATE TABLE member_group (    group_id        INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    group_name        VARCHAR(80) UNIQUE NOT NULL,    create_date        DATE DEFAULT SYSDATE,    update_date        DATE DEFAULT SYSDATE);ALTER TABLE board ADD CONSTRAINT fk_category_id FOREIGN KEY(category_id) REFERENCES category(category_id);ALTER TABLE board ADD CONSTRAINT fk_member_id FOREIGN KEY(member_id) REFERENCES member(member_id);ALTER TABLE comments ADD CONSTRAINT fk_document_id FOREIGN KEY(document_id) REFERENCES board(document_id);ALTER TABLE comments ADD CONSTRAINT fk_member_id_2 FOREIGN KEY(member_id) REFERENCES member(member_id);ALTER TABLE member ADD CONSTRAINT fk_group_id_2 FOREIGN KEY(group_id) REFERENCES member_group(group_id);이제 매퍼를 작성하겠습니다.매퍼를 작성하기 전에 DBeaver를 통해 미리 쿼리를 작성해보도록 하겠습니다. 외래키를 통해 제약조건을 설정했기때문에 우선 그룹을 생성합니다.Admin 그룹 생성INSERT INTO member_group (group_name) VALUES ('Admin');쿼리문을 토대로 groupMapper를 생성합니다. 저번 글에서 생성한 mappers 패키지 아래 groupMapper.xml 파일을 만들고 다음과 같이 CRUD 쿼리를 작성하세요.groupMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.GroupDAO\"&gt;&lt;insert id=\"create\"&gt;insert into member_group (group_name) values (#{groupName})&lt;/insert&gt;&lt;select id=\"read\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id = #{groupId}&lt;/select&gt;&lt;update id=\"update\"&gt;update member_group set group_name=#{groupName}, update_date=SYSDATE where group_id = #{groupId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from member_group where group_id = #{groupId} &lt;/delete&gt;&lt;select id=\"listAll\" resultType=\"GroupDTO\"&gt;&lt;![CDATA[ select * from member_group where group_id &gt; 0 order by group_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;JPA에서는 레포지토리를 통해 SQL문 없이도 DB연결이 쉬웠지만, Mybatis는 SQL문을 직접 적어야합니다.우선 mapper 태그에 namespace 속성을 통해 DAO에 연결해줍니다. DAO는 Data Access Object의 약자로, 데이터베이스와 연결되는 객체입니다. JPA에서 Repository와 같은 역할을 합니다. DAO가 mapper에 연결되면서 SQL문을 실행시키고, select문의 경우 Entity를 생성합니다. mapper 태그 하위 태그에는 DML이 들어가며, id 속성값은 DAO의 메소드명이 됩니다.resultType 속성은 Entity를 DTO에 연결해줍니다. DTO는 Data Transfer Object의 약자로, 데이터를 전송해주는 객체입니다. JPA를 사용할때는 DTO를 작성하지 않고 Entity 클래스를 DTO 대신 사용 했습니다.DTO 객체의 멤버변수는 #{멤버변수}로 표시합니다. listAll 메소드에서 &lt;![CDATA[...]]&gt;라고 표시한 것은 꺽쇠 표시(&gt;) 때문입니다. 해당 태그로 감싸지 않으면 꺽쇠가 태그를 내타내는 기호인지 부등호를 나타내는 기호인지 알 수 없기때문에 오류를 나타냅니다.자바에서는 관례적으로 변수명을 낙타표기법(Camel Case)으로 나타냅니다. table과 column을 스네이크 표기법(Snake Case)으로 만들었기 때문에 DTO 변수의 매핑을 위해 이를 변환할 필요가 있습니다.mybatis-config.xml 파일의 configuration 태그 아래에 다음과 같이 settings 태그를 추가합니다.mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- 카멜 케이스 매핑 설정 --&gt;         &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;        &lt;!-- 쿼리 결과 필드가 null인 경우, 누락되지 않도록 설정 --&gt;         &lt;setting name=\"callSettersOnNulls\" value=\"true\"/&gt;        &lt;!-- 쿼리에 보내는 파라미터가 null인 경우, 오류가 발생하는 것을 방지 --&gt;         &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;package name=\"kro.rubisco.dto\"/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;이제 나머지 매퍼도 만들어줍니다. memberMapper부터 만들겠습니다.memberMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.MemberDAO\"&gt;&lt;resultMap id=\"getMember\" type=\"MemberDTO\"&gt;    &lt;association property=\"group\" column=\"group_id\" select=\"getGroup\" /&gt;&lt;/resultMap&gt;&lt;insert id=\"create\"&gt;insert into member (password, email, name, nick_name, group_id)values (#{password}, #{email}, #{name}, #{nickName}, #{groupId})&lt;/insert&gt;&lt;select id=\"read\" resultMap=\"getMember\"&gt;select * from member where member_id = #{memberId}&lt;/select&gt;&lt;select id=\"getGroup\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id=#{groupId}&lt;/select&gt;&lt;update id=\"update\"&gt;update member set password=#{password},    email=#{email},     name=#{name},     nick_name= #{nickName},where member_id = #{memberId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from member where member_id = #{memberId} &lt;/delete&gt;&lt;select id=\"listAll\" resultMap=\"getMember\"&gt;&lt;![CDATA[ select * from member where m.member_id &gt; 0 order by m.member_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;resultMap 이라는 태그가 추가되었습니다. select문의 경우 검색된 entity를 resultType에 지정된 타입의 객체에 담게 되는데, colmun은 원시값을 가지기 때문에 속성값이 참조값을 가진다면 매핑하지 못합니다. 그러므로 연관관계를 통해 entity 자체를 객체의 속성에 담기 위해서는 resultMap을 설정하여 매핑정보를 입력해주면 됩니다.resultMap 태그에 id를 설정하고 type 속성에 매핑되는 객체 타입을 입력합니다. 하위 태그인 association은 1:N 연관관계를 설정할 수 있습니다. property 속성에는 resultMap의 type에서 연관관계를 맺을 매개변수명을 입력합니다. join 쿼리를 통해 매핑해주거나 select 속성을 사용하여 매핑해줄 수 있는데 저는 후자의 방법으로 매핑했습니다.아래 코드로 예를 들어보겠습니다.resultMap 설정&lt;resultMap id=\"getMember\" type=\"MemberDTO\"&gt;    &lt;association property=\"group\" column=\"group_id\" javaType=\"GroupDTO\" select=\"getGroup\" /&gt;&lt;/resultMap&gt;&lt;select id=\"read\" resultMap=\"getMember\"&gt;select * from member where member_id = #{memberId}&lt;/select&gt;&lt;select id=\"getGroup\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id=#{groupId}&lt;/select&gt;id가 read인 select 태그에 resultType 속성 대신에 resultMap 속성을 추가합니다. 해당 select문을 실행시켜 출력된 entity는 resultMap의 type속성에 입력한 MemberDTO 타입에 매핑됩니다. 이때 association 태그의 select 속성에 입력된 getGroup이라는 id를 가진 select문을 함께 실행시켜 property에 입력된 group이라는 매개변수의 타입인 groupDTO에 매핑됩니다. column에 입력된 값은 getGroup select문의 매개변수로 전달됩니다.동일한 방식으로 각각의 mapper를 만들어줍시다.categoryMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.CategoryDAO\"&gt;&lt;insert id=\"create\"&gt;insert into category (category) values (#{category})&lt;/insert&gt;&lt;select id=\"read\" resultType=\"CategoryDTO\"&gt;select * from category where category_id = #{categoryId}&lt;/select&gt;&lt;update id=\"update\"&gt;update category set category=#{category}, update_date=SYSDATE where category_id = #{categoryId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from category where category_id = #{categoryId} &lt;/delete&gt;&lt;select id=\"listAll\" resultType=\"CategoryDTO\"&gt;&lt;![CDATA[ select * from category where category_id &gt; 0 order by category_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;boardMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.BoardDAO\"&gt;&lt;resultMap id=\"getBoard\" type=\"BoardDTO\"&gt;    &lt;id property=\"documentId\" column=\"document_id\" /&gt;    &lt;result property=\"isNotice\" column=\"is_notice\" typeHandler=\"kro.rubisco.config.YNTypeHandler\" /&gt;    &lt;association property=\"category\" column=\"category_id\" select=\"getCategory\" /&gt;    &lt;association property=\"member\" column=\"member_id\" select=\"getMember\" /&gt;    &lt;association property=\"group\" column=\"group_id\" select=\"getGroup\" /&gt;    &lt;collection property=\"commentList\" column=\"document_id\" select=\"getComments\" /&gt;&lt;/resultMap&gt;&lt;resultMap id=\"getBoardList\" type=\"BoardDTO\"&gt;    &lt;id property=\"documentId\" column=\"document_id\" /&gt;    &lt;result property=\"isNotice\" column=\"is_notice\" typeHandler=\"kro.rubisco.config.YNTypeHandler\" /&gt;    &lt;association property=\"category\" column=\"category_id\" select=\"getCategory\" /&gt;    &lt;association property=\"member\" column=\"member_id\" select=\"getMember\" /&gt;    &lt;association property=\"group\" column=\"group_id\" select=\"getGroup\" /&gt;&lt;/resultMap&gt;&lt;select id=\"getCategory\" resultType=\"CategoryDTO\"&gt;select * from category where category_id=#{categoryId}&lt;/select&gt;&lt;select id=\"getMember\" resultType=\"MemberDTO\"&gt;select * from member where member_id=#{memberId}&lt;/select&gt;&lt;select id=\"getGroup\" resultType=\"GroupDTO\"&gt;select * from member_group where group_id=#{groupId}&lt;/select&gt;&lt;select id=\"getComments\" resultType=\"CommentDTO\"&gt;select * from comments where document_id=#{documentId}&lt;/select&gt;&lt;insert id=\"create\"&gt;insert into board (category_id, is_notice, title, content, member_id)values (#{categoryId}, #{isNotice, typeHandler=kro.rubisco.config.YNTypeHandler}, #{title}, #{content}, #{memberId})&lt;selectKey keyProperty=\"documentId\" order=\"AFTER\"&gt;select max(document_id) as document_id from board&lt;/selectKey&gt;&lt;/insert&gt;&lt;select id=\"read\" resultMap=\"getBoard\"&gt; select * from board where document_id = #{documentId}&lt;/select&gt;&lt;update id=\"update\"&gt;update board set category_id=#{categoryId},     is_notice=#{isNotice, typeHandler=kro.rubisco.config.YNTypeHandler},     title=#{title},     content=#{content},      update_date=SYSDATEwhere document_id = #{documentId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from board where document_id = #{documentId} &lt;/delete&gt;&lt;select id=\"listAll\" resultMap=\"getBoardList\"&gt;&lt;![CDATA[ select * from board where document_id &gt; 0 order by document_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;commentMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"kro.rubisco.dao.CommentDAO\"&gt;&lt;resultMap id=\"getComment\" type=\"CommentDTO\"&gt;    &lt;association property=\"board\" column=\"document_id\" select=\"getBoard\" /&gt;    &lt;association property=\"member\" column=\"member_id\" select=\"getMember\" /&gt;&lt;/resultMap&gt;&lt;select id=\"getBoard\" resultType=\"BoardDTO\"&gt;select * from board where document_id=#{documentId}&lt;/select&gt;&lt;select id=\"getMember\" resultType=\"MemberDTO\"&gt;select * from member where member_id=#{memberId}&lt;/select&gt;&lt;insert id=\"create\"&gt;insert into comments (document_id, content, member_id) values (#{documentId}, #{content}, #{memberId})&lt;/insert&gt;&lt;select id=\"read\" resultMap=\"getComment\"&gt;select * from comments where cmt.comment_id = #{commentId}&lt;/select&gt;&lt;update id=\"update\"&gt;update comments set document_id=#{documentId},     content=#{content},     update_date=SYSDATEwhere comment_id = #{commentId}&lt;/update&gt;&lt;delete id=\"delete\"&gt; delete from comments where comment_id = #{commentId} &lt;/delete&gt;&lt;select id=\"listAll\" resultMap=\"getComment\"&gt;&lt;![CDATA[ select * from comments where comment_id &gt; 0 order by comment_id desc ]]&gt;&lt;/select&gt;&lt;/mapper&gt;소스코드  mapper.zip",
        "url": "/java/spring-legacy-mapper"
    }
    ,
    
    "java-spring-legacy-setting": {
        "title": "스프링 레거시(Spring legacy) - 설정",
            "author": "rubisco",
            "category": "",
            "content": "지난번 스프링 부트를 통해 게시판을 만들어 보았는데 이번에는 스프링 레거시를 사용해서 게시판을 만들어보겠습니다.STS3 / JDK 11 / Tomcat9 설치우선은 Spring Tool Suite 3을 다운받습니다. 3버전은 스프링 레거시를 지원합니다.JDK는 11 버전 이상이여야 사용할 수 있습니다. 이전에 open JDK 17을 다운받았는데, oracle JDK 11을 새로 설치하겠습니다. 오라클에 로그인 하셔야 다운가능합니다.스프링 부트와 달리 내장 톰캣이 없어서 톰캣을 다운받아야 합니다. Tomcat 9 버전을 다운받습니다.STS3 압축을 풀어 sts-bundle 폴더 안에 ws폴더를 만들고, 톰캣의 압축을 풉니다.sts-3.9.18.RELEASE 폴더에 들어가서 STS를 실행시킵시다.방금 생성한 ws 폴더를 작업폴더로 지정하고 Launch를 누릅니다.인코딩 설정상단에 Window &gt; Preferences를 클릭합니다.General &gt; Content Types에 들어가서 Text를 선택하고 하단에 Default encoding에 utf-8을 입력후 Update 버튼을 누르세요.General &gt; Workspace에서 Text file encoding 또한 UTF-8로 번경 후 Apply 버튼을 누르세요Web &gt; CSS Files, Web &gt; HTML Files, Web &gt; JSP Files, XML &gt; XML Files, JSON &gt; JSON Files 또한 Encoding을 UTF-8로 변경후 Apply 버튼을 누르세요.기본 JDK 버전을 17로 사용하고 있어서 환경변수가 17 버전으로 되어 있습니다. 환경변수를 변경해도 되지만 에디터를 통해 설정하겠습니다.JAVA &gt; Compiler에서 JDK Compiler compliance level을 11로 변경하고, JAVA &gt; Installed JREs에서 JDK 11버전 경로를 추가한 후 Apply를 클릭하세요.톰캣 서버 생성왼쪽 Package Explorer 창에 있는 기본 서버 프로젝트를 삭제합니다.Delete project contents on disk (cannot be undone)을 체크하여 완전시 삭제합시다.왼쪽 하단에 톰켓 서버도 삭제합니다.왼쪽 하단에 링크를 클릭하여 서버를 추가합시다.Tomcat v9.0 Server를 선택후 Next 버튼을 클릭합니다.Browse... 버튼을 클릭하여 아까 설치한 톰캣 폴더를 디렉토리로 지정한후 Finish를 클릭하세요.프로젝트 서버 생성스프링 레거시 프로젝트를 생성하겠습니다. 왼쪽 Package Explorer 창에 오른쪽 마우스 클릭을 한 후 New &gt; Spring Legacy Project를 선택합니다.Spring MVC Project를 선택후 프로젝트 이름을 적고 Next를 클릭합니다.패키지 및 아티팩트 이름을 적고 Finish를 클릭하면 레거시 프로젝트의 의존성이 자동으로 설치되면서 프로젝트가 추가됩니다.톰캣 서버에서 Add and Remove...를 선택하여 프로젝트를 추가해줍니다.Ctrl + Alt + R을 누르면 톰캣 서버가 시작됩니다. 기본 포트는 8080 입니다. localhost:8080/board로 접속해보세요. (board는 아티팩트 이름입니다.)한글이 깨지는데 뷰 페이지를 작성할때 encoding 메타정보를 utf-8로 입력하야합니다. 뷰 페이지 작성을 참고하세요.의존성 추가레거시 프로젝트의 경우 빌드툴로 메이븐(maven)을 사용하기 때문에 pom.xml을 통해 의존성을 추가할 수 있습니다.저는 롬복을 통해 간단하게 getter, setter 설정 및 의존성의 생성자 주입을 하므로 롬복을 설치하겠습니다.또한 DB는 스프링 부트 게시판을 만들때 사용했던 오라클 클라우드를 사용하도록 하겠습니다.롬복을 설치하면 IDE를 찾을 수 없다고 뜨는데, Specify loaction...을 클릭하여 STS3의 위치를 지정해주고 Install / Update를 클릭합니다.pom.xml 파일에 롬복 의존성을 추가합니다.pom.xml        &lt;!-- Lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.24&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;mvnrepository를 참고하여 의존성을 설정해줍니다.자바 버전은 1.8로 변경하고, 스프링 프레임워크 버전도 5.1.5.RELEASE로 설정합시다.pom.xml    &lt;properties&gt;        &lt;java-version&gt;1.8&lt;/java-version&gt;        &lt;org.springframework-version&gt;5.1.5.RELEASE&lt;/org.springframework-version&gt;        &lt;org.aspectj-version&gt;1.6.10&lt;/org.aspectj-version&gt;        &lt;org.slf4j-version&gt;1.6.6&lt;/org.slf4j-version&gt;    &lt;/properties&gt;junit은 현재 4.12 버전의 사용률이 높으므로 4.12버전으로 변경합니다.pom.xml        &lt;!-- Test --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;JPA 대신 이번에는 mybatis를 사용하여 sql문을 실행하겠습니다.DB 연결을 위해 Spring JDBC를 의존성으로 추가하고, 메이븐 레포지토리를 참고하여 mybatis와 mybatis-spring을 의존성 추가합니다.pom.xml        &lt;!-- Spring JDBC --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${org.springframework-version}&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.3.2&lt;/version&gt;        &lt;/dependency&gt;DB는 오라클 클라우드를 사용할 예정이므로 OJDBC 의존성을 추가합니다. 클라우드 연결에는 인증키를 통한 인증 과정이 필요하므로 Osdt도 OJDBC 버전에 맞추어 의존성으로 추가합니다.pom.xml        &lt;!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc8 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;            &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt;            &lt;version&gt;21.1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.oracle.database.security/osdt_cert --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;            &lt;artifactId&gt;osdt_cert&lt;/artifactId&gt;            &lt;version&gt;21.1.0.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/com.oracle.database.security/osdt_core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;            &lt;artifactId&gt;osdt_core&lt;/artifactId&gt;            &lt;version&gt;21.1.0.0&lt;/version&gt;        &lt;/dependency&gt;                &lt;!-- https://mvnrepository.com/artifact/com.oracle.database.security/oraclepki --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;            &lt;artifactId&gt;oraclepki&lt;/artifactId&gt;            &lt;version&gt;21.1.0.0&lt;/version&gt;        &lt;/dependency&gt;프로퍼티 설정스프링 부트에서는 Gradle 빌드툴을 사용하여 빈(Bean)이 자동으로 등록되고, 빈에 대한 설정은 application.properties 파일에 작성했지만, 레거시에서는 빈을 직접 등록합니다. 레거시 앱의 빈 등록은 /src/main/webapp/WEB-INF/spring/appServlet/root-context.xml 파일에 작성합니다.mybatis를 통해 오라클 DB에 접근하기 위해 dataSource와 sqlSessionFactory, sqlSession을 빈으로 등록하고 property에 다음과 같이 설정값을 입력합니다.src/main/webapp/WEB-INF/spring/root-context.xml    &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\" name=\"dataSource\"&gt;        &lt;property value=\"oracle.jdbc.driver.OracleDriver\" name=\"driverClassName\"/&gt;        &lt;property value=\"[DB 주소]\" name=\"url\"/&gt;        &lt;property value=\"[DB 아이디]\" name=\"username\"/&gt;        &lt;property value=\"[DB 암호]\" name=\"password\"/&gt;    &lt;/bean&gt;             &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;         &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;        &lt;property name=\"mapperLocations\" value=\"classpath:mappers/**/*Mapper.xml\"&gt;&lt;/property&gt;                &lt;/bean&gt;    &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\" destroy-method=\"clearCache\"&gt;        &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;sqlSession은 SQL을 실행하고 트랜잭션을 제어하는 객체입니다. mybatis에서는 sqlSession 객체를 통해 mapper의 쿼리문을 실행합니다. sqlSessionFactory를 의존성 주입받으며, sqlSessionFactory은 dataSource를 참조하여 sqlSession 객체를 생성합니다.sqlSessionFactory에는 mybatis-config.xml 파일과 mappers.xml의 위치를 지정해주고, dataSource에는 DB 정보를 입력해줍니다.해당 위치에 mybatis-config.xml 파일을 만들고 다음과 같이 작성해둡니다.mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=\"kro.rubisco.dto\"/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;typeAliases 태그 아래 package 태그의 name 속성은 패키지의 별칭을 나타냅니다. 나중에 매퍼를 작성함에 있어서 DTO를 연결할 때 패키지명을 모두 적어야하지만, 이렇게 별칭을 지정해두면 작성된 패키지 부분을 생략하고 DTO 클래스명만 적어도 연결이 됩니다.mappers라는 패키지 폴더도 하나 만들어둡시다. 나중에 매퍼를 작성할 폴더입니다.",
        "url": "/java/spring-legacy-setting"
    }
    ,
    
    "programmers-programmers-131128": {
        "title": "[1단계][131128] 숫자짝꿍 풀이",
            "author": "rubisco",
            "category": "",
            "content": "문제for문을 돌려 풀면  풀릴듯하게 보이는 문제이지만 길이가 300만자리까지 될 수 있으므로 for문으로 매칭시면 최대 O(300만*300만) 이라는 시간복잡도를 가질 수 있어서 시간초과가 될 수 있습니다.풀이관점을 다르게 보면 됩니다. X와 Y를 기준으로 매칭을 할 것이 아니라 숫자 0 ~ 9를 매칭시키는 것입니다.X와 Y는 0 ~ 9까지의 숫자로 이루어져 있습니다. 그러므로 문자열을 split하여 각각의 원소를 해쉬코드로 사용하여 count값을 구함으로써 X, Y 각각 10개의 해쉬테이블을 생성할 수 있습니다.예를 들어 X = “3403”, Y = “13203” 이면  X_table = [1, 0, 0, 2, 1, 0, 0, 0, 0, 0]  Y_table = [1, 1, 1, 2, 0, 0, 0, 0, 0, 0]가 됩니다.여기에서 하나의 index를 기준으로 두 원소 중 count값이 적은 수만큼 index를 반복한 문자열의 배열인 matchTable을 생성할 수 있습니다.  matchTable = [“0”, “”, “”, “33”, “”, “”, “”, “”, “”, “”]matchTable을 역순으로 합치게 되면 정답에 해당하는 “330”이 됩니다. 시간복잡도를 O(300만*3)으로 줄일 수 있습니다.이것을 자바스크립트 코드로 나타내면 다음과 같습니다.function solution(X, Y) {        const yArr = Y.split('').reduce((arr, cur) =&gt; ++arr[+cur] &amp;&amp; arr, Array(10).fill(0));    const xArr = X.split('').reduce((arr, cur) =&gt; ++arr[+cur] &amp;&amp; arr, Array(10).fill(0));        return ( result = Array.from({length:10}, (_,i) =&gt; (9-i).toString().repeat(Math.min(yArr[9-i], xArr[9-i]))).join('') )             ? result*1 ? result : \"0\" : \"-1\";}",
        "url": "/programmers/programmers-131128"
    }
    ,
    
    "etc-git-tutorial": {
        "title": "Git 튜토리얼",
            "author": "rubisco",
            "category": "",
            "content": "git 설치기본적인 용어를 알아보았으니 실제로 명령어를 통해 커밋과 풀, 푸시를 해보도록 하겠습니다. IDE를 통해 쉽게 작업할 수 있지만 터미널상에서 명령어를 통해 커밋을 하겠습니다.우선은 원격 컴퓨터에 로그인하고 git를 설치합니다.$ sudo apt install git커밋에 정보를 남기기 위해 config에 name과 mail을 입력합니다. email은 github에 입력된 email을 입력해야 잔디가 심어집니다.$ git config --global user.name [userName]$ git config --global user.email [userEmail]커밋(commit)우선 로컬 저장소를 생성해보도록 하겠습니다. 우선 작업 트리를 생성하고 이동합니다.$ mkdir -p ~/git/example &amp;&amp; cd ~/git/example로컬 저장소는 init 명령어를 통해 생성할 수 있습니다.init 명령어$ git init로컬 저장소가 생성되면 .git 폴더가 생성됩니다. 이제 임의의 파일을 하나 생성하고 임의의 내용을 작성합니다.$ touch test.txt &amp;&amp; echo \"임의의 내용 작성 1\" &gt; test.txt커밋을 하기 위해서는 add 명령어를 통해 인덱스에 파일을 등록해야 합니다.add 명령어$ git add test.txt인덱스에 등록된 파일을 확인하려면 status 명령어를 사용합니다.status 명령어$ git status이제 commit 명령어를 통해 변경 상태를 기록합니다. 이때 -m 옵션을 통해 커밋 메시지를 작성해야만 합니다.-m 옵션$ git commit -m \"test.txt 파일 생성\"커밋 로그를 확인하고 싶다면 log 명령어를 입력해보세요.log 명령어$ git log스테이징과 커밋을 한번에 해결하려면 commit 명령어에 -am 옵션을 주면 됩니다.-am 옵션$ git commit -am \"test.txt 파일 생성\"푸시(push)와 풀(pull)이번에는 방금 생성한 로컬 저장소를 원격 저장소에 push 해보겠습니다. 그전에 ssh 인증키를 만들어서 github에 등록합시다.$ ssh-keygen -t ed25519 -C \"이메일 주소\"passphrase를 입력하라고 뜨면 암호를 입력해주거나 그냥 엔터를 눌러주시면 됩니다.인증키가 생생되면 다음 명령어로 개인키를 확인합니다.$ cat ~/.ssh/id_ed25519.pub터미널에 뜬 개인키를 복사하고 github에서 Settings &gt; SSH and GPG keys &gt; New SSH Key로 이동하여 개인키를 등록해줍니다.이제 github에 접속하여 원격 저장소를 하나 생성합니다.저장소 주소를 복사한 후 remote add명령어를 통해 원격 저장소를 추가해줄 수 있습니다.$ git remote add origin git@github.com:[userName]/[repository].git원격 저장소가 추가되었는지 확인하기 위해서는 remote 명령어에 -v 옵션을 주면 됩니다.$ git remote -v이제 push 명령어를 통해 로컬 저장소의 변경 내역을 원격 저장소에 반영하도록 하겠습니다.$ git push origin maingithub의 원격 저장소에 접속하면 test.txt 파일이 저장된 것을 확인할 수 있습니다.이번에는 원격 저장소를 clone을 통해 복사하여 example2 작업 트리에 로컬 저장소를 만들어보겠습니다.우선 example2 작업 트리를 만들고 해당 폴더로 이동합니다.$ mkdir -p ~/git/example2 &amp;&amp; cd ~/git/example2clone 명령어를 통해 원격 저장소를 복사합니다.$ git clone git@github.com:[userName]/[repository].git .test.txt 파일을 수정해봅시다.$ echo \"내용 추가\" &gt;&gt; test.txttest.txt 파일을 스테이징 하여 커밋하고 원격 저장소에 푸시해줍시다.$ git commit -am \"내용 추가\"$ git push origin mainexample 작업트리로 이동하여 test.txt 파일의 내용을 확인합시다.$ cd ~/git/example &amp;&amp; cat test.txt아직 원격 저장소와 동기화되지 않았습니다. pull 명령어로 원격 저장소의 커밋 내역을 로컬 저장소에 합치고 test.txt 내용을 확인하면 동기화가 된 것을 알 수 있습니다.$ git pull origin main &amp;&amp; cat test.txt브랜치(branch)이제 브랜치를 만들어 보겠습니다. 브랜치는 branch 명령어를 통해서 추가할 수 있습니다.브랜치 추가$ git branch issue1브랜치가 성생되었는지 확인하려면 다음 명령어를 입력하세요.브랜치 생성 확인$ git branch브랜치를 이동하려면 checkout 명령어를 사용합니다. git 2.23 부터는 checkout의 기능이 분리되어 switch 명령어를 통해서도 브랜치의 이동이 가능합니다.$ git switch issue1브랜치를 생성하고 바로 이동하려면 다음과 같이 -b 옵션 / -c 옵션을 붙이면 됩니다.checkout의 경우$ git checkout -b issue1switch의 경우$ git switch -c issue1브랜치의 삭제는 -d 옵션을 사용합니다.브랜치 삭제$ git branch -d issue1병합(merge)이번에는 병합을 해보겠습니다.issue1 브랜치로 이동하여 test.txt 파일을 임의로 수정하고 스테이징 후 커밋을 합니다.VSCode의 extension인 Git Graph를 통하여 커밋 로그를 그래프로 확인하면 브랜치가 하나로 이어져있는 것을 확인할 수 있습니다.이것은 현재 issue1 브랜치를 기준으로 main 브랜치는 fast-forward 상태에 있기 때문입니다.main 브랜치로 이동하고 merge 명령어로 하면 main 브랜치는 fast-forward merge가 됩니다.fast-forward merge$ git switch main$ git merge issue1이번에는 non fast-forward merge를 해보겠습니다.issue1 브랜치로 이동하여 test.txt 파일을 수정한 후 커밋합니다.issue1 커밋$ git switch issue1$ echo -e \"\\nissue1 내용 추가\" &gt;&gt; test.txt$ git commit -am \"test.txt issue1 내용 추가\"메인 브랜치로 이동 후 issue2 브랜치를 생성하여 이동 후, test.txt 파일을 수정한 후 커밋합니다.issue2 커밋$ git switch main$ git switch -c issue2$ echo \"issue2 내용 추가\" &gt;&gt; test.txt$ git commit -am \"test.txt issue2 내용 추가\"메인 브랜치로 이동하면 다음과 같이 fast-forward 상태가 됩니다.우선 issue1 브랜치를 fast-forward merge 합니다.메인 브랜치가 fast-forward 상태이기때문에 그냥 merge 명령어만 사용하도 fast-forward merge가 되지만, --ff 옵션을 주어 명시적으로 fast-forward merge를 하겠습니다.–ff 옵션을 통한 fast-forward merge$ git switch main$ git merge --ff issue1메인 브랜치의 참조 커밋이 변경되면서 non fast-forward 상태가 되었습니다. 이 상태에서는 자동으로 non fast-forward merge가 됩니다.하지만 issue1과 issue2 양쪽에서 같은 파일을 수정했기 때문에 병합충돌이 발생합니다.non fast-forward merge$ git merge issue2test.txt 파일을 열어봅니다. 메인 브랜치인 HEAD의 변경 부분과 issue2 브랜치 변경부분을 다음과 같이 구분하여 파일이 수정되어 있습니다.HEAD(메인 브랜치)의 변경부분&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD브랜치 병합 테스트issue1 내용 추가=======issue2 브랜치의 변경부분=======issue2 내용 추가&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue2코드를 수정하고 스테이징 후 다시 커밋을 보내면 커밋이 생성되면서 merge가 됩니다.test.txt임의의 내용 작성 1내용 추가브랜치 병합 테스트issue1 내용 추가issue2 내용 추가병합충돌 해결$ git commit -am \"병합충돌 해결\"--no-ff 옵션을 사용하면 fast-forward 상태일지라도 non fast-forward merge를 할 수 있습니다.issue1 브랜치로 변경하여 메인 브랜치와 fast-forward merge를 하고, test.txt를 수정한 후 스테이징 및 커밋합니다.issue1 새로운 커밋$ git switch issue1$ git merge main$ echo \"issue1 새로운 커밋\" &gt;&gt; test.txt$ git commit -am \"issue1 새로운 커밋\"메인 브랜치로 이동하여 –no-ff 옵션을 통해 issue1을 non fast-forward merge 해봅시다.–no-ff 옵션$ git switch main$ git merge --no-ff issue1다음과 같이 커밋 메시지를 적기위한 에디터가 뜹니다. vim과 같은 명령어를 사용합니다.:wq를 입력하면 병합이 완료됩니다.또다른 병합 옵션으로 --squash가 있는데 이는 rebase를 알아야합니다.리베이스(rebase)리베이스(rebase)는 이름 그대로 커밋이 분기되는 base를 수정하는 작업입니다. 공통된 커밋으로부터 수정하려는 base 커밋까지의 차이점을 패치(patch)라는 공간에 임시로 저장하고 참조 커밋을 수정한 후 패치(patch)를 순차적으로 적용합니다.방금 병합한 작업을 다음 상태로 되돌려 베이스가 수정되는 과정을 보겠습니다.커밋 되돌리기$ git reset --hard HEAD~2$ git switch issue1$ git reset --hard HEAD~2우선 issue2 브랜치로 이동하여 rebase 명령어로 메인 브랜치를 base로 만듭니다.리베이스$ git switch issue2$ git rebase main아까 상황과 마찬가지로 issue1과 issue2에서 동시에 같은 파일을 수정했기 때문에 패치를 만드는 과정에서 병합충돌이 발생했습니다.아까와 동일하게 test.txt 파일을 수정합니다.test.txt임의의 내용 작성 1내용 추가브랜치 병합 테스트issue1 내용 추가issue2 내용 추가스테이징 한 후 병합과는 달리 커밋을 하지 않고 rebase 명령어에 --continue 옵션을 주어 리베이스를 계속 진행하도록 합니다.리베이스 진행$ git add test.txt$ git rebase --continue그러면 커밋 메시지를 입력하는 에디터가 뜹니다. :wq를 입력하여 커밋을 생성합니다.이제 메인 브랜치로 이동하여 fast-forward merge를 합니다. 병합과 비교해보면 issue2 브랜치에 있던 커밋이 main 브랜치로 베이스가 옮겨졌음을 확인할 수 있습니다.리베이스의 경우병합의 경우중간에 리베이스를 취소하려면 –continue 옵션 대신에 –abort 옵션을 넣습니다.리베이스 취소$ git rebase --abort리베이스를 사용하면 커밋 히스토리가 한줄로 깔끔해지지만 이미 공개된 저장소에 push한 커밋을 리베이스하면 히스토리가 꼬일 수 있으므로 주의해야합니다.체리픽(cherry-pick)체리픽(cherry-pick)은 리베이스와 유사하게 베이스를 변경하는 작업인데, 원하는 커밋만 pick해서 브랜치에 적용시키는 작업입니다.issue1 브랜치로 이동하여 커밋을 2번 합니다.issue1 브랜치에서 2번의 커밋 작업$ git switch issue1$ git merge main$ git echo \"issue1 체리픽1\" &gt;&gt; test.txt$ git commit -am \"issue1 체리픽1\"$ git echo \"issue1 체리픽2\" &gt;&gt; test.txt$ git commit -am \"issue1 체리픽2\"로그를 통해 체리픽1 커밋의 해시를 확인합니다.커밋 해시 확인$ git log --oneline메인 브랜치로 이동하여 cherry-pick 명령어를 통해 체리픽 작업을 합니다.cherry-pick$ git switch main$ git cherry-pick [커밋 해시]마찬가지로 패치(patch) 과정에서 충돌이 발생합니다.패치(patch) 충돌test.txt 파일을 충돌나지 않도록 수정합니다.test.txt임의의 내용 작성 1내용 추가브랜치 병합 테스트issue1 내용 추가issue2 내용 추가issue1 체리픽1저장하고 스테이징 후 --continue 옵션으로 체리픽을 계속 진행해주세요.체리픽 진행$ git add .$ git cherry-pick --continue다음과 같이 원하는 커밋만 브랜치에 가져왔습니다. 커밋을 새로 생성했기 때문에 커밋 해시가 다르다는 것을 볼 수 있습니다.체리픽 결과중간에 체리픽을 취소하려면 --continue 옵션 대신에 --abort 옵션을 넣으면 됩니다.체리픽 취소$ git cherry-pick --abort스쿼시 병합(squash merge)체리픽과 유사한 작업이 병합의 --squash 옵션입니다. 스쿼시 옵션은 리베이스처럼 브랜치 베이스의 참조를 변경하지만, 리베이스가 베이스 이후로 브랜치 전체 커밋을 반영하는 것과 달리 스쿼시 병합은 브랜치의 커밋을 하나로 합쳐 체리픽처럼 새로운 하나의 커밋을 생성합니다.체리픽 작업 이전으로 되돌리기$ git reset --hard HEAD~스쿼시 병합$ git merge --squash issue1test.txt 패치(patch) 충돌 해결임의의 내용 작성 1내용 추가브랜치 병합 테스트issue1 내용 추가issue2 내용 추가issue1 체리픽1issue1 체리픽2스쿼시 병합 진행$ git commit -am \"스쿼시 병합\"reset과 revert커밋 상태를 과거로 되돌리는 명령어에는 reset과 revert가 있습니다.reset은 헤드 자체를 과거로 옮겨 특정 커밋으로 되돌리는 작업을 하며, revert는 과거로 되돌린다는 이력을 남기고서 특정 커밋을 없던 것으로 하는 작업을 합니다.resetreset의 옵션에는 --soft, --mixed, --hard가 있습니다.  --soft : 커밋을 하기 전단계인 스테이징 상태로 돌려놓습니다.--mixed : 기본값으로 적용되며, 파일을 스테이징 이전단계로 돌려놓습니다.(파일이 작업 트리에 존재)--hard : 추적 상태인 파일을 작업 트리에서 제거합니다. 즉, 파일을 수정하기 전으로 돌려놓습니다.명령어의 형태는 다음과 같습니다.$ git reset [옵션(선택)] [커밋 해시]커밋 해시 대신에 헤드의 상대적인 수치로도 reset을 수행할 수 있습니다. 틸트(~숫자)의 경우 틸트로부터 숫자만큼 reset을 수행하며, 캐럿(^)의 경우 헤드로부터 한단계 아래 커밋으로 reset을 수행합니다.예를 들어 아래 코드의 경우 2칸 이전의 커밋을 파일 수정 이전으로 되돌립니다.reset$ git reset --hard HEAD~2revertrevert는 하나의 커밋 상태로 되돌리며, 상태를 되돌릴때마다 revert 상태를 남기는 커밋을 생성합니다. 다음과 같이 여러 커밋에 대하여 revert 작업이 가능합니다.revert$ git revert HEAD^ HEAD^^스태쉬(stash)스태쉬(stash)는 추적 상태에 있거나 스테이징 상태에 있는 파일을 임시로 저장하는 작업입니다. 추적 상태에 있거나 스테이징 상태인 파일이 있다면 다른 브랜치로 이동하지 못합니다. 이때 스태쉬를 통해 파일을 저장하고 다른 브랜치로 이동할 수 있습니다.다음 명령어를 통해 새로운 스태쉬를 생성할 수 있습니다.스태쉬 생성$ git stash또는$ git stash save스태쉬 스택의 확인은 다음 명령어를 통해 확인할 수 있습니다. 리스트에서 스태쉬 이름을 확인할 수 있습니다.ex) stash@{0}: ….스태쉬 목록$ git stash list스태쉬의 적용은 apply 명령어를 통해 적용할 수 있습니다. 스태쉬를 생성한 브랜치 뿐만 아니라 다른 브랜치에도 적용가능합니다.스태쉬 목록$ git switch issue2$ git stash apply stash@{0}옵션 없이 적용하면 스테이징 상태에 있던 파일도 추적 상태로 적용되지만, --index 옵션을 준다면 스테이징 상태에 있던 파일은 스테이징 상태 그대로 적용됩니다.drop 명령을 사용하면 스태쉬를 스택에서 삭제하며, pop 명령을 사용하면 스태쉬를 적용하고 스택에서 삭제합니다.스태쉬 삭제$ git stash drop stash@{0}-m –keep-index원격 브랜치의 생성과 삭제원격 브랜치를 생성하려면 로컬 브랜치가 존재해야하며, push 명령어를 사용하여 생성할 수 있습니다.origin/issue1 원격 브랜치 생성$ git push origin issue1원격 브랜치를 가져오려면 switch 또는 checkout 명령어에 --track 옵션을 붙입니다.origin/issue1 원격 브랜치 가져오기$ git switch origin/issue1또는 $ git checkout origin/issue1원격 브랜치를 삭제하려면 push 명령어에 --delete 옵션을 붙입니다.origin/issue1 원격 브랜치 삭제$ git push --delete origin issue1원격 저장소 동기화원격 저장소를 동기화 하려면 fetch 명령어를 사용합니다.origin 원격 저장소 동기화$ git fetch originpull 명령어의 경우, fetch 작업과 merge 작업을 수행합니다. fetch를 하면 원격 저장소로부터 최신이력을 가져와 이름없는 브랜치에 반영합니다. 이 브랜치는 FETCH_HEAD라는 이름으로 참조할 수 있습니다. 메인 브랜치를 병합하고 싶다면 브랜치를 merge하거나 pull을 수행하면 됩니다.",
        "url": "/etc/git-tutorial"
    }
    ,
    
    "etc-git": {
        "title": "Git 길라잡이",
            "author": "rubisco",
            "category": "",
            "content": "Git와 Github 차이Git는 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템입니다. 원래는 Linux 소스코드를 관리할 목적으로 개발 되었습니다.Git를 통해 버전을 관리하면 소스 코드가 변경된 이력을 쉽게 확인할 수 있으며, 특정 시점의 버전과 비교하거나 그 시점의 버전으로 파일을 되돌릴 수 있습니다. 또한 협업을 하는 경우 충돌을 감지하여 사용자에게 경고를 주기도 합니다.GitHub는 Git Repository를 위한 웹 기반 호스팅 서비스 입니다. 클라우드 서버를 통해 로컬에서 관리하는 소스코드를 업로드하고 공유할 수 있어서 공동작업이 가능하도록 합니다. Git의 기본적인 기능을 제공하여 한 프로젝트에 여러 사람이 공동으로 작업하여도 효율적으로 버전관리를 할 수 있도록 합니다.Git 용어저장소(Repository)저장소(Repository)는 말그대로 파일이나 폴더를 저장해 두는 장소를 말합니다. 파일의 변경 이력을 관리하며, 원격 저장소(Remote Repository)와 로컬 저장소(Local Repository)로 구분됩니다.원격 저장소는 Github와 같이 소스코드를 공유하고 공동작업을 하기위한 저장소이고, 로컬 저장소는 개인 전용 저장소입니다.평소에는 로컬 저장소에서 작업을 하지만 공동작업이 필요하다면 원격 저장소에 저장하고, clone 명령어를 통해 로컬 저장소로 코드를 가져올 수 있습니다.작업 트리(Work Tree) / 인덱스(Index)작업 트리(work tree)는 소스코드를 편집하는 작업 공간(workspace) 그 자체를 말하고, 인덱스(index)는 커밋을 하기 전에 작업 트리와 저장소 사이에 존재하는 공간을 말합니다.커밋 작업은 작업 트리의 변경 이력을 바로 기록하지 않고 인덱스에 저장되어 있는 파일의 상태를 우선적으로 기록하게 됩니다.인덱스에 파일 상태를 기록하는 것을 스테이징(staging)이라고 하며, add 명령어를 통해 스테이징 상태로 만들 수 있습니다. 커밋은 인덱스에 스테이징 상태로 있는 파일의 이력만 저장소에 저장하게 됩니다.풀(pull) / 푸시(push)풀(pull)은 원격 저장소에 저장된 파일을 로컬 저장소로 가져오는 것을 말하고, 푸시(push)는 로컬 저장소에 저장된 파일을 원격 저장소에 반영하는 것을 말합니다. 각각 pull과 push 명령어를 통해 작업할 수 있습니다.커밋(Commit)commit은 파일의 변경 이력을 기록하는 명령어 입니다. 작업 트리(work tree)의 파일을 저장소(repository)에 스냅샷으로 기록하며, 시간순으로 저장되어 과거 변경 이력과 그 내용을 알 수 있습니다.커밋들은 서로 체인구조를 형성하여 참조하고 있기 때문에 과거 커밋 내용이 훼손되면 그 이후의 커밋도 훼손되어 버립니다.위 그래프에서 각 노드는 커밋 시점을 나타냅니다. 보는 바와 같이 커밋 시점은 순차적으로 연결되어 있습니다.각 커밋은 영문과 숫자로 구성된 40자리의 커밋 해시(commit hash)를 통해 구분되며, 커밋을 하기 위해서는 커밋 메시지의 작성이 필요합니다. 커밋 메시지를 작성하지 않으면 커밋이 이루어지지 않습니다.커밋은 코드에 이력을 남기는 중요한 작업이므로 커밋 메시지에는 코드의 변경 내용과 변경 사유 등을 간략히 기록해 두는것이 권장됩니다.브랜치(Branch)브랜치(Branch)는 독립적인 작업을 진행할 수 있도록 해주는 기능입니다. 각각의 브랜치는 다른 브랜치의 영향을 받지않아서 여러 작업을 동시에 진행할 수 있습니다.로컬 저장소를 생성하면 기본적으로 메인(main) 브랜치에서 작업을 수행하게 되고, 체크아웃(checkout) 하기 전까지 모든 작업은 메인 브랜치에서 이루어집니다. 여기에서 체크아웃이란 브랜치를 옮기는 작업을 말합니다.공동작업을 할때에는 우선 로컬 저장소의 메인 브랜치를 pull을 통해 원격 저장소의 메인 브랜치와 동기화 시킨 후, 작업전용 브랜치를 만들어 독립적인 작업을 하게 됩니다. 이때 브랜치가 생성되는데, 브랜치는 항상 최신 커밋을 참조하고 있습니다.브랜치는 작업에 따라 자유롭게 만들 수 있지만, 이를 효율적으로 관리하기 위해서는 사전에 팀원들과 어떤 방식으로 브랜치를 만들고 통합할 것인지 미리 정해두는 것이 좋습니다. 즉, 브랜치 전략이 있어야 합니다.가정 널리 사용되는 브랜치 전략으로는 Git-Flow, Github-Flow, Gitlab-Flow가 있습니다.Git-Flowgit flow는 메인(main) 브랜치(기존 master 브랜치)와 개발(devlop) 브랜치를 중점으로 운영하는 브랜치 전략입니다.이 전략에는 다음과 같이 5개의 브랜치가 존재합니다.      main : 정식 배포되는 브랜치 입니다.    develop : 개발 브랜치로, 이 브랜치를 기준으로 하여 각자 작업한 기능등을 병합합니다.    feature : 단위 기능을 개발하는 브랜치 입니다. 개발이 완료되면 develop 브랜치에 병합됩니다.    release : main 브랜치에 보내기 전에 품질검사를 하기 위한 브랜치 입니다.    hotpix : main 브랜치에 배포한 이후 버그가 생겼을 때 긴급 패치를 위한 브랜치 입니다.  이 전략의 운영과정은 다음과 같습니다.  main 브랜치에서 develop 브랜치를 분기하고, 개발자들은 develop 브랜치에 커밋을 합니다.  기능 구현이 있는 경우 develop 브랜치에서 feature-* 브랜치를 분기합니다.  배포를 준비하기위해 develop 브랜치에서 release-* 브랜치를 분기합니다.  테스트를 진행하면서 발생하는 버그 수정은 release-* 브랜치에 직접 반영합니다.  테스트가 완료되면 release 브랜치를 main과 develop 브랜치에 병합합니다.Github-Flowgithub flow는 git flow가 Github에서 사용하기에는 너무 복잡하여 나온 브랜치 전략입니다.hotfix 브랜치와 feature 브랜치를 따로 구분하지 않으며, Pull Request를 사용하는 것을 권장합니다.브랜치는 항상 메인 브랜치를 통해 분기하며, 브랜치 이름과 커밋 메시지는 목적에 맞도록 명확하게 작성하는 것이 좋습니다. 또한 원격 브랜치로 수시로 push하고 자신이 하고 있는 작업을 다른사람이 확인할 수 있도록 합니다.피드백이나 도움요청, 또는 병합 준비가 되었을 때는 pull request를 생성합니다.현재 우리팀에서는 이 전략을 통해 버전을 관리하고 있으며, 이슈를 기반으로 하여 브랜치를 생성합니다. 다음 글을 참고하세요.GitHub로 프로젝트 관리하기Gitlab-Flowgitlab flow는 복잡하지 않고 효율성을 높이기 위해 생긴 브랜치 전략으로, master, feature, production 브랜치가 존재합니다.기능 구현은 feature 브랜치를 통해서 이루어지며, master 브랜치는 production 브랜치로 병합됩니다. production 브랜치는 오직 배포만을 담당합니다.Gitlab을 사용해 본적이 없어서 자세한 내용은 생략하겠습니다.헤드(HEAD)헤드(HEAD)는 현재 체크아웃된 브랜치의 커밋에 대한 참조 포인터입니다. 평소에는 브랜치를 통해 간접적으로 최신 커밋을 참조하고 있습니다.브랜치를 설명할때 체크아웃을 브랜치를 옮기는 작업이라고 했지만, 정확하게는 헤드의 참조를 변경하는 작업입니다. 위에 그림처럼 헤드가 브랜치를 통해 간접적으로 커밋을 참조하는 상태를 Attached HEAD State라고 하며, 직접적으로 커밋을 참조하는 상태를 Detached HEAD State라고 합니다.체크아웃을 통해 헤드를 옮김으로써 이전 커밋 지점으로 되돌아가는 것이 가능합니다.원격 브랜치(Remote Branch)원격 브랜치(remote branch)는 원격 저장소의 브랜치를 트래킹(Tracking)하는 브랜치 입니다. 로컬에 존재하면서 원격 저장소와 통신하며 자동으로 업데이트 됩니다.원격 저장소를 clone하면 origin이라는 이름의 원격 브랜치가 생성되고, 로컬 브랜치를 원격 브랜치와 동기화시킵니다.원격 브랜치와 로컬 브랜치는 독립적으로 존재하기 때문에 로컬 브랜치에서 커밋하더라도 원격 브랜치에 바로 반영되지는 않습니다.병합(merge)병합은 브랜치로 분기되어 있는 커밋을 하나의 브랜치로 합치는 작업을 말합니다. 병합 방식에 따라 fast-forward merge와 3-way merge로 나눌 수 있습니다.fast-forward merge다음과 같이 브랜치가 분기점으로부터 변화가 없는 상태를 빨리감기(fast-forward) 상태라고 합니다.main 브랜치는 issue1 브랜치가 분기한 이후로 변화가 없는 상태이며, 이 경우 merge를 하면 커밋 지점을 따로 만들지 않고 브랜치의 참조만 변경하게 됩니다.non fast-forward merge다음과 같이 빨리감기 상태가 아니라면 참조변수를 옮기는 것 만으로 병합을 할 수 없습니다.이 경우 새로운 커밋을 만들어서 병합을 수행하게 됩니다.이때 main 브랜치에서 수정한 파일을 issue1 브랜치에서도 수정했다면 병합충돌이 발생할 수 있습니다.튜토리얼을 참고해주세요.패치(fetch)pull은 패치와 병합 2가지 작업으로 구성되어 있습니다.패치(fetch)는 원격 브랜치만 원격 저장소와 동기화시키며, 병합은 위에서 설명한 것과 같이 로컬 저장소를 원격 저장소와 동기화 시킵니다.패치작업의 경우 바로 로컬 저장소에 변경 내용이 반영되지 않기 때문에 헤드만 이동하여 원격 저장소의 커밋을 확인할 수 있어서 병합충돌의 위험을 줄일 수 있습니다.",
        "url": "/etc/git"
    }
    ,
    
    "etc-mosh": {
        "title": "향상된 SSH 프로토콜 : Mosh",
            "author": "rubisco",
            "category": "",
            "content": "Mosh란?Mosh는 Mobile Shell의 약자로, 모바일 환경에서 원격 터미널을 원활하게 사용할 수 있도록 해주는 프로토콜입니다. 기존 SSH의 상위 호환 프로토콜이라고 보시면 됩니다.SSH의 경우 TCP 프로토콜을 사용하기 때문에 세션으로 연결되어야만 통신이 가능합니다. 그렇기 때문에 모바일 환경과 같이 세션의 연결이 불안정한 네트워크의 경우 세션의 연결이 끊어지면 다시 세션을 연결하기 때문에 입출력의 지연이 발생하고, 시간내에 세션에 연결하지 못하면 기존에 구성해둔 작업환경을 다시 구성해야 할 수도 있습니다.반면에 Mosh는 UDP 프로토콜을 사용하여 세션의 연결상태를 지속할 필요가 없으며, 입출력을 따로 연결하고 세션의 상태를 보존하기때문에 명령에 대한 연결지연이 없습니다.하지만 UDP를 통해서 Mosh 서버에 직접적인 연결이 불가하여 SSH를 통해 간접적으로 접속해야 하며, 하나의 접속에 대하여 하나의 포트를 필요로 하기때문에 방화벽의 유지관리에 많은 비용이 들 수 있습니다.Mosh 설치Ubuntu 20.04 LTS 환경인 원격 서버에 Mosh를 설치하여 윈도우 환경에서 접속해보도록 하겠습니다.우선 원격서버에 접속하고 apt를 업데이트 하세요.$ sudo apt update &amp;&amp; sudo apt upgradeapt를 통해 mosh를 설치하세요.$ sudo apt install moshmosh는 60000 ~ 61000번의 UDP 포트를 사용합니다. 우선 os 방화벽에서 해당포트를 열어주세요.$ sudo ufw allow 60000:61000/udp원격서버에서도 포트를 열어야합니다. 이전에 작성한 도커(Docker) 설치하기을 참고하세요.윈도우에서 Mosh 프로토콜을 통해 통신하려면 Cygwin을 설치하거나 크롬 브라우저에 extention을 설치하여 통신할 수 있습니다.저는 크롬 브라우저에 extension을 설치하겠습니다.extionstion을 설치하면 Mosh app이 설치됩니다. 실행시키면 다음과 같은 화면이 뜹니다.os 유저이름과 ip주소, ssh 포트를 입력하고 Connect를 클릭하면 됩니다. 그전에 ssh key를 통해 접속하므로 비밀키를 입력해야합니다. 오른쪽에 Add ssh key를 클릭하고, 비밀키를 메모장으로 열어서 키값을 복사하여 입력하세요.Passphrase를 입력하라고 뜹니다.. 다음 명령어를 통해 Passphrase를 설정합니다. 그냥 엔터를 입력하면 Passphrase 없이 비밀키만으로 접속가능합니다.$ ssh-keygen -p -f [비밀키 경로] -m pem다시 비밀키를 복사하여 입력한후 Connect를 누르면 ssh를 통해 원격 서버에 접속되고 mosh 통신이 시작됩니다.",
        "url": "/etc/mosh"
    }
    ,
    
    "etc-github-issue": {
        "title": "GitHub로 프로젝트 관리하기",
            "author": "rubisco",
            "category": "",
            "content": "팀 프로젝트를 진행함에 있어 일정관리가 필요한데 GitHub를 사용하여 일정관리를 해보도록 하겠습니다.프로젝트 만들기Github의 프로젝트 레포지토리에 접속하면 상단에 Projects 탭이 있습니다. 클릭하세요.얼마 전까지만 해도 beta 버전이었는데 clasic이 사라지고 beta가 정식 Projects가 되었습니다. 오른쪽 상단에 Add project를 클릭하고, 아래쪽에 Go to ... to create a new project를 클릭하세요.이어서 New project를 클릭합니다.마음에 드는 템플릿을 선택하고 Create를 누릅니다. 저는 Team Backlog를 선택했습니다.프로젝트를 관리할 수 있는 보드가 생성되었습니다! 왼쪽 상단에 프로젝트 보드 이름을 변경해줍시다.왼쪽에 자물쇠 표시는 Private 상태를 나타내는데 access 권한이 없는 유저의 접근을 막습니다. 확인하지는 않았지만 같은 프로젝트를 진행하는 팀원들은 프로젝트 보드가 표시될 것으로 예상합니다.나중에 설명할텐데 PR이나 이슈의 상태가 closed 라면 연관된 이슈를 자동으로 closed 상태로 바꾸기 위해 Workflows를 설정해야합니다.item closed에서 Set를 Status: Done로 바꾸고 오른쪽 위에 Disabled를 Enabled로 바꿔주세요.Pull request merged도 동일하게 바꿔줍니다.Item added to project는 New가 설정되어 있습니다. 스위치만 Enabled로 바꿔주세요. 이 경우 이슈나 PR이 생성되면 자동으로 New 상태가 됩니다.나머지는 선택적으로 해주시면 됩니다.이제 다시 레포지토리의 Projects 탭으로 돌아와서 Add project를 클릭하면 방금 생성한 프로젝트 백로그가 있습니다. 클릭해주세요.빈곳 아무곳이나 클릭하면 다음과 같이 레포지토리에 프로젝트 백로그가 생성됩니다.이슈(Issues) 등록이제 프로젝트 보드에 이슈를 등록해보겠습니다.레포지토리에서 상단의 Issues 탭을 클릭합니다.상단 메뉴를 보면 라벨(Labels)과 마일 스톤(Milestones)이 있습니다.라벨(Labels)라벨은 이슈의 유형을 지정해 줄 수 있습니다. 라벨을 클릭해서 확인하면 기본 라벨이 생성되어 있습니다.Edit를 눌러 수정하거나 New label을 눌러 새로운 라벨을 생성할 수 있습니다.마일 스톤(Milestones)마일 스톤은 한국어로 이정표를 뜻합니다. 말 그대로 이정표를 두고 일정을 관리 할 수 있도록 합니다. New milestone을 클릭하여 새로운 마일 스톤을 생성합시다.타이틀 및 일정 기한과 함께 짧은 설명을 적고 Create milestone을 누르면 마일 스톤이 생성됩니다.이슈(Issues)이제 이슈를 등록해보겠습니다. 상단에 New issue를 클릭하세요.제목과 이슈 내용을 적어주기만 하면 이슈가 등록됩니다. 마크다운 문법을 통해 작성할 수 있습니다.중요한 부분은 오른쪽 영역입니다. 이슈를 통해 팀원들에게 작업을 할당하는 것이 가능합니다. 우선 Assignees를 클릭하면 레포지토리에 접근 권한이 있는 팀원들의 목록이 뜹니다. 작업 할당을 원하는 팀원을 선택합니다. 여러 인원을 선택할 수도 있습니다.그 아래쪽에는 위에서 생성한 라벨과 프로젝트 백로그, 마일스톤을 설정해 줄 수 있습니다.Submit new issue를 클릭면 이슈가 등록됩니다.이제 다시 프로젝트 백로그로 이동해보세요.Workflows를 설정하기 전에 등록해서 이슈가 No Status에 있습니다. 해당 이슈를 마우스로 드래그하여 상태를 설정해줄 수 있습니다. 저는 In progress 상태로 끌어넣었습니다.해당 이슈를 클릭하면 우선순위나 개발 사이즈도 설정해 줄 수 있습니다.동일하게 팀원들에 대한 이슈도 작성여 작업을 할당해 주면 프로젝트 백로그를 통해 진행 과정을 한눈에 확인할 수 있습니다.이슈 기반 브랜치 만들기이렇게 생성된 이슈를 기반으로 하여 브랜치를 만들어 에디터를 통해 작업을 할 수 있습니다.인텔리제이에서 브랜치 만들기인텔리 제이에서는 브랜치를 만들기 전에 Task와 GitHub를 연결해야 합니다.Ctrl + Alt + S를 눌러 설정창을 열고 도구 &gt; 작업 &gt; 서버로 이동합니다.+를 눌러 Github를 선택하고 레포지토리 소유자와 레포지토리 이름을 입력 후 API 토큰 생성을 눌러주세요. 아래쪽에 나에게 할당되지 않은 이슈 포함 체크를 해제하면 본인에게 할당된 이슈만 확인가능합니다.로그인하고 인증을 받으면 토큰이 자동으로 입력됩니다. 확인을 누르고 에디터 오른쪽 상단에 디폴트 작업 &gt; 작업열기을 클릭하세요.그러면 이슈 목록을 확인할 수 있습니다.할당받은 이슈를 더블클릭하여 작업을 생성해주세요. 이때 브랜치를 생성할 수 있습니다.확인을 누르면 브랜치가 생성되어 변경되고 task 상태가 변화된 것을 확인할 수 있습니다. 즉, 이슈를 기반으로 하여 task와 브랜치가 같이 만들어졌습니다.이제 코드 개발을 열심히 하고 브랜치와 수정 내역을 확인 후 commit / push를 합니다.인텔리제이의 경우 왼쪽 가장자리에 커밋 탭이 있으며, 단축키 Alt + 0을 눌러도 됩니다.확인 후 메시지를 작성하고 커밋 또는 커밋 및 푸시를 누르세요.이제 왼쪽 가장자리의 풀 리퀘스트 아이콘 탭을 클릭하고 상단의 +를 눌러 풀 리퀘스트를 보냅니다.PR 제목과 내용을 입력 후 풀 리퀘스트 생성을 클릭하여 PR을 보냅시다. 이때 검토자, 담당자 및 라벨을 설정할 수 있습니다.중요한 부분은 내용에 close #[이슈번호]를 적어주면 Merge가 되었을 때 참조된 이슈가 closed 상태가 된다는 것입니다.GitHub 레포지토리에 들어가서 확인해보면 PR이 잘 작성되어 있습니다. 이슈와 마찬가지로 프로젝트의 우선순위와 크기, 마일스톤 등을 지정해 줄 수 있습니다. 차이점은 검토자를 설정할 수 있다는 것입니다.확인만 하고 에디터에서 Merge를 해보겠습니다. 제가 담당자 이므로 PR은 저한테 날아올 것입니다. 왼쪽 가장자리의 풀 리퀘스트 탭을 누르고 state:open 을 검색하면 PR이 온 것을 확인할 수 있습니다.더블클릭하면 내용을 확인할 수 있으며, Merge가 가능합니다.Merge 후 이슈를 확인하면 위에서 언급한 대로 closed 상태가 된 것을 확인할 수 있습니다.이제 브랜치를 삭제하고 task를 default 상태로 되돌립니다.VS Code에서 브랜치 만들기VS code도 인텔리제이와 비슷합니다. 이슈를 생성하고, VS code에 다음 Extension을 설치하세요.:GitHub Pull Requests and Issues설치를 하면 왼쪽 가장자리에 github 아이콘이 생깁니다.클릭후 하단에 ISSUES 영역에서 refresh 버튼을 누르면 이슈가 나타납니다.마우스를 hover하면 오른쪽에 화살표가 뜹니다. 화살표를 클릭하면 이슈를 기반으로 하여 브랜치가 생성됩니다.코드를 개발하고 커밋 / 푸시를 합니다. 센스있게도 메시지가 자동으로 작성되어 있으며, #[이슈 번호]를 붙여 연관된 이슈를 참조하고 있습니다.기트허브 아이콘을 클릭하여 상단에 풀리퀘스트 생성 버튼을 누르면 왼쪽 아이콘바에 Github Pull Request 아이콘이 뜹니다.커밋과 마찬가지로 PR도 DESCRIPTION에 연관된 이슈를 Fixes로 선언하여 참조하도록 자동으로 작성되어 있습니다. Close 말고도 Fixes, resolve 같은 선언자도 Merge가 되면 참조된 이슈를 함께 닫는 듯 합니다.Create를 눌러 PR을 보내고 기트허브 아이콘을 누르면 PR이 Open 상태가 된 것을 확인할 수 있습니다. 해당 PR을 확인하면 github에 가지 않아도 에디터 내에서 라벨이라던지 검토자 라던지 설정이 가능합니다. Merge도 가능합니다.Merge를 누르고 Create Merge Commit를 누르면 Merge가 됩니다.Delete branch...를 눌러 브랜치를 바로 삭제할 수 있으며, 왼쪽 하단에 ISSUE를 refresh하면 이슈가 닫힌 것을 확인할 수 있습니다.",
        "url": "/etc/github_issue"
    }
    ,
    
    "trouble-trouble-01": {
        "title": "No.001 - 첵크박스 null값 전송 문제",
            "author": "rubisco",
            "category": "",
            "content": "문제 발생insertBoard 뷰를 통해 /Board 로 POST 요청시 java.lang.IllegalArgumentException 발생했습니다원인 파악board 객체의 isNotice 필드가 null이기 때문에 발생한 오류로 판단했습니다.템플릿을 확인먼저 템플릿을 살펴보았습니다.insertBoard.html&lt;label class=\"row label is_notice\"&gt;    &lt;input th:if=\"${isBoardExist}\" type=\"checkbox\" th:field=\"*{isNotice}\"&gt;    &lt;input th:unless=\"${isBoardExist}\" type=\"checkbox\" name=\"isNotice\"&gt;&lt;/label&gt;일반적으로 첵크박스의 상태가 checked 일때 “on”이라는 String 타입의 데이터를 전송하는데, 스프링에서 Boolean 타입으로 데이터를 받을 경우 컨버터에 의하여 자동으로 true를 반환합니다.문제는 checked 상태가 아닐때 입니다. checked 상태가 아니면 클라이언트에서는 값 자체를 전송하지 않습니다. 즉, 서버에는 null값을 받게 됩니다.템플릿 작성때부터 인지하고 있던 사안인지라 타임리프의 th:field 문법을 통해 해당 문제를 사전에 막았습니다. 템플릿에는 이상없어 보입니다.Board 객체 확인오류를 다시 확인해보니 ‘board’ 객체의 필드에 Binding을 하지 못하고 있습니다.그러므로 Board 클래스를 확인해보았습니다.Board.java...public class Board extends BaseTime {    ...    @Column(length = 1)    @ColumnDefault(\"'N'\")    @Convert(converter = BooleanToYNConverter.class)    private boolean isNotice;    ...}문제는 이곳에 있었습니다.원인 확인우선 템플릿의 경우 타임리프의 th:field 문법을 사용했는데, 이 문법은 제가 전송한 isNotice의 값을 변환시키는 것이 아니라 hidden 필드를 추가하여 체크박스 존재 자체를 알리는 문법이었던 것입니다. 이 경우 다음과 같은 hidden 필드가 추가되어 서버로 전송됩니다.th:field 문법&lt;input type=\"hidden\" name=\"_isNotice\" value=\"on\" /&gt;즉, 히든 필드에 의하여 스프링 서버에 ‘isNotice’ 필드의 값이 체크박스 상태를 담고 있다는 사실을 알리고, checked 속성의 추가 여부를 확인하는 문법이었던 것입니다.문제는 Board 클래스에 있었습니다. 위에 보시는 것처럼 boolean 타입으로 선언했습니다. 즉, 원시타입으로 선언했습니다. boolean 원시타입의 경우, true, false만 값으로 받을 수 있고, null은 값으로 받을 수 없습니다.클라이언트에서 체크박스를 클릭하지 않아 isNotice 파라미터의 값은 null로 전송이 되고, 서버는 이 값을 Board 객체의 isNotice 필드에 할당하려 한 것입니다. 그러므로, 타입 캐스팅 오류였던 것입니다.해결isNotice 필드가 null값을 할당 받을 수 있도록 boolean 타입의 래퍼 클래스 타입인 Boolean 타입으로 선언해주었습니다.Board.java...public class Board extends BaseTime {    ...    @Column(length = 1)    @ColumnDefault(\"'N'\")    @Convert(converter = BooleanToYNConverter.class)    private Boolean isNotice;    ...}Boolean 타입은 참조타입이며, Serializable 인터페이스를 상속받고 있습니다.public final class Boolean implements java.io.Serializable, java.lang.Comparable, java.lang.constant.Constable {    ...}즉, true, false 뿐만 아니라 null값 또한 인식할 수 있습니다.",
        "url": "/trouble/trouble-01"
    }
    ,
    
    "java-spring-boot": {
        "title": "스프링 부트로 게시판 만들기",
            "author": "rubisco",
            "category": "",
            "content": "개발 환경 구축우분투 20.04 LTS 환경을 기준으로 하여 VScode로 원격개발을 하도록 하겠습니다.원격 코드 개발환경 구축를 참고하여 원격 Spring Boot 개발환경을 구축합니다.저는 gradle을 통해 Spring Boot 2.7.2 / JDK 17 환경의 프로젝트를 생성했습니다.의존성으로는 Spring Boot DevTools, Lombok, Spring Web, Spring Data JPA, MariaDB Driver, Thymeleaf를 추가했습니다. gradle을 통해 단위 테스트 도구 juint도 추가했습니다.MariaDB가 아닌 다른 DB의 경우 DB에 맞는 드라이버를 의존성으로 추가해주세요.build.gradleplugins {    id 'org.springframework.boot' version '2.7.3'    id 'io.spring.dependency-management' version '1.0.13.RELEASE'    id 'java'}group = 'practice'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {    compileOnly {        extendsFrom annotationProcessor    }}repositories {    mavenCentral()}dependencies {    // 스프링 부트    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'    implementation 'org.springframework.boot:spring-boot-starter-web'    // 롬복    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.projectlombok:lombok'    // mariaDB JDBC driver    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'    // 단위 테스트 도구    testImplementation 'junit:junit'    testImplementation 'org.springframework.boot:spring-boot-starter-test'    // 개발툴    developmentOnly 'org.springframework.boot:spring-boot-devtools'}tasks.named('test') {    useJUnitPlatform()}의존성 모듈의 프로퍼티를 설정합니다.application.properties# 타임리프 설정spring.thymeleaf.prefix = classpath:templates/spring.thymeleaf.suffix = .htmlspring.thymeleaf.cache = false# JPA 설정spring.jpa.hibernate.ddl-auto = updatespring.jpa.hibernate.use-new-id-generator-mappings = falsespring.jpa.generate-ddl = truespring.jpa.show-sql = truespring.jpa.database = defaultspring.jpa.database-platform = org.hibernate.dialect.MariaDB103Dialectspring.jpa.properties.hibernate.format_sql = truespring.jpa.properties.hibernate.use_sql_comments = false# 데이터베이스 설정spring.datasource.driver-class-name = org.mariadb.jdbc.Driverspring.datasource.url = [DB 주소]spring.datasource.username = [DB 아이디]spring.datasource.password: [DB 암호]# devtools 설정spring.devtools.livereload.enabled = truespring.devtools.remote.restart.enabled = true# 서버 설정server.port = 8080# 로그 설정logging.level.org.hibernate = info다른 DB를 사용하는 경우 spring.jpa.database, spring.jpa.database-platform의 값과 데이터베이스 설정값을 바꿔주세요.Entity 작성애플리케이션을 개발하려면 요구사항을 분석해야 합니다. 저는 문서에 대한 CRUD와 댓글 기능을 구현하도록 하겠습니다.추가적으로 회원과 카테고리, 그룹 기능도 구현하겠습니다.개체-관계 다이어그램(Entity Relationship Diagram, ERD)을 통해 Entity와 테이블의 관계를 분석합니다.연관관계에 대한 설명은 추후에 하도록 하고, ERD를 토대로 엔티티를 작성하겠습니다.우선 연관관계가 없는 column만 매핑하는데, column의 길이나 제약조건은 생각하지 않고 필드의 타입을 중점으로 매핑합니다.Board.javaimport javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import lombok.*;/** * 게시판 도메인 * * @since : 2022-08-20 오후 6:18 * @author : Rubisco * @version : 1.0.0 */@Getter@Setter@Entitypublic class Board {        @Id @GeneratedValue    private Long documentId;    private boolean isNotice;    private String title;    private String content;    private Long likeCount;    private Long dislikeCount;    private Long readCount;}가장 기본적인 형태의 Entity 입니다.ERD에서 테이블의 이름은 스네이크 표기법으로 되어있는데, Entity의 필드명을 카멜 표기법으로 정의하면 자동으로 스네이크 표기법으로 column 이름이 설정됩니다.예를 들어 documentId 라는 필드는 document_id 라는 column과 매핑됩니다.isNotice 필드는 ERD에서 String 타입이지만 boolean 타입으로 전환할 예정이므로 boolean 타입으로 선언합니다.@Entity 어노테이션을 통해 Board 클래스가 Entity임을 선언하고, @Id 어노테이션으로 documentId가 기본키(Primary Key, PK)임을 선언했으며, @GeneratedValue 어노테이션으로 기본키의 숫자가 자동으로 증가되도록 기본키 전략을 지정해주었습니다.또한 코드를 줄이고 가시성을 높이기 위해 롬복의 @Setter와 @Getter 어노테이션을 통해 세터와 게터를 생성했습니다.그런데 Entity에 세터(Setter)가 있으면 중간에 데이터가 변형될 가능성이 있어서 영속화된 Entity의 경우 DB의 일관성을 보장할 수 없게 됩니다.물론 트랜잭션이 끝나면 detached 상태가 되어 일관성을 보장할 수 있지만, Entity에는 전달하지 말아야 하는 데이터가 포함될 수도 있습니다. 즉, 보안성에 문제가 생길 수도 있습니다.그러므로 DTO를 따로 만들어 Entity를 DTO로 전환하거나, 빌더(builder)를 통해 새로운 Board 객체를 만드는 것을 권장합니다.개인적인 의견으로는 관점에 따라 필요한 DTO를 만들어 주는 것이 맞겠으나, 지금은 소규모 프로젝트 인데다가 개인이 작업하고 있으므로 빌더를 통해 새로운 Board 객체를 생성할 수 있도록 만들겠습니다.Board.javaimport javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import lombok.*;/** * 게시판 도메인 * * @since : 2022-08-20 오후 6:18 * @author : Rubisco * @version : 1.0.0 */@Getter@Entitypublic class Board {        @Id @GeneratedValue    private Long documentId;    private boolean isNotice;    private String title;    private String content;    private Long likeCount;    private Long dislikeCount;    private Long readCount;    protected Board() {}    public Board(        Long documentId,         boolean isNotice,         String title,         String content    ) {        this.documentId = documentId;        this.isNotice = isNotice;        this.title = title;        this.content = content;    }    public static Builder builder() {        return new Builder();    }    public static class Builder {        private Long documentId;        private boolean isNotice;        private String title;        private String content;        Builder() {}        public Builder documentSrl(Long documentSrl) {            this.documentSrl = documentSrl;            return this;        }        public Builder isNotice(boolean isNotice) {            this.isNotice = isNotice;            return this;        }        public Builder title(String title) {            this.title = title;            return this;        }        public Builder content(String content) {            this.content = content;            return this;        }        public Board build() {            return new Board(documentSrl, isNotice, title, content);        }    }}빌더 패턴은 추후에 설명하겠습니다. 빌더를 만들었더니 코드가 너무 복잡해졌습니다.우선 비어있는 Board의 생성자는 Entity의 프록시 역할을 합니다. 자세한 설명은 생략하겠으나 어찌되었든 Entity를 생성하기 위해서는 매개변수가 없는 생성자가 필요합니다.생성자가 없으면 자바에서 자동으로 매개변수가 없는 생성자를 만들어주지만, 빌더 패턴으로 생성자를 만들었으므로 매개변수가 없는 생성자도 같이 만들어 주어야 합니다.외부에서 접근하는 것을 막기위해 protected 접근자를 사용했습니다.protected Board() {}짧은 코드지만 이 코드 또한 롬복의 @NoArgsConstructor 어노테이션을 통해 생성할 수 있습니다. 이때 access 매개변수를 통해 접근레벨을 설정할 수 있습니다.@Getter@Entity@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Board {    ...}그 다음 코드는 필드를 주입하기 위한 생성자 입니다. 빌더만 있어도 새로운 Board 객체를 생성하는 것에는 문제가 없으나, Board 객체의 필드는 접근자가 private 이므로 필드를 주입해 줄 수 없습니다.컨트롤러에서 클라이언트의 요청(Request)을 받으면 Board 객체의 필드이름과 동일한 파라미터를 매핑하여 필드를 주입하는데, 세터도 없고 생성자도 없으면 필드를 주입할 수 없어서 Board 객체의 필드값은 모두 null이 됩니다.물론 Entity는 문제없이 생성되므로 DB에서 값을 조회하는 것은 문제가 없지만 DB에 값을 입력하는데 문제가 있습니다. 그러므로 생성자를 DI를 할 수 있는 환경을 만들어 줍시다.롬복의 @AllArgsConstructor 어노테이션을 통해 전체 필드에 대한 생성자를 만들 수도 있지만, 우리는 Entity를 만드는 Board 클래스를 DTO 대신 사용하는 것이므로 필요한 필드만 선택하여 생성자를 만들어 주도록 합시다.그 아래 코드는 빌더를 만드는 코드입니다. 빌더는 롬복의 @Builder 어노테이션을 통해 간단하게 생성할 수 있습니다. 클래스에 붙이면 전체 필드에 대한 빌더가 생성되지만 생성자에 붙이면 선택적인 빌드를 할 수 있는 빌더가 생성됩니다.어노테이션을 적용하여 다음과 같이 코드를 줄일 수 있습니다.Board.javaimport javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import org.springframework.util.Assert;import lombok.*;/** * 게시판 도메인 * * @since : 2022-08-20 오후 6:18 * @author : Rubisco * @version : 1.0.0 */@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Board {        @Id @GeneratedValue    private Long documentId;    private boolean isNotice;    private String title;    private String content;    private Long likeCount;    private Long dislikeCount;    private Long readCount;    @Builder    public Board(        Long documentId,         boolean isNotice,         String title,         String content    ) {        this.documentId = documentId;        this.isNotice = isNotice;        this.title = title;        this.content = content;    }    public Board update(Board board) {        Assert.notNull(title, \"Title must not be null\");        Assert.notNull(content, \"Content must not be null\");        Assert.notNull(isNotice, \"IsNotice must not be null\");        title = board.title;        content = board.content;        isNotice = board.isNotice;        return this;    }}@DynamicInsert 어노테이션과 @DynamicUpdate 어노테이션에 대한 설명은 추후에 하도록 하고 마지막에 update 메소드 내부를 보면 Assert.notNull 이라는 메소드를 호출합니다.이 메소드는 값이 null이면 예외를 발생시키는 메소드로써, 방어 코드로 입력했습니다. 테스트를 할 때 어디에서 문제가 발생했는지 쉽게 찾을 수 있기 때문에 이렇게 방어코드를 작성하는 것을 권장합니다.이렇게만 작성해도 문제가 없겠으나, ERD에 작성한대로 각 필드마다 column과 매칭시키도록 하겠습니다. column의 속성은 필드에 @column 어노테이션을 붙여서 설정할 수 있습니다.Board.javaimport javax.persistence.Column;import javax.persistence.Convert;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Lob;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import org.springframework.util.Assert;import kr.kro.hex.BooleanToYNConverter;import lombok.*;/** * 게시판 도메인 * * @since : 2022-08-20 오후 6:18 * @author : Rubisco * @version : 1.0.0 */@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Board {        @Id @GeneratedValue    private Long documentId;    @Column(length = 1)    @ColumnDefault(\"'N'\")    @Convert(converter = BooleanToYNConverter.class)    private boolean isNotice;    @Column(length = 250, nullable = false)    private String title;    @Lob @Column(nullable = false)    private String content;    @Column(updatable = false)    @ColumnDefault(\"0\")    private Long likeCount;    @Column(updatable = false)    @ColumnDefault(\"0\")    private Long dislikeCount;    @Column(updatable = false)    @ColumnDefault(\"0\")    private Long readedCount;    @Builder    public Board(        Long documentId,         boolean isNotice,         String title,         String content    ) {        this.documentId = documentId;        this.isNotice = isNotice;        this.title = title;        this.content = content;    }    public Board update(Board board) {        Assert.notNull(title, \"Title must not be null\");        Assert.notNull(content, \"Content must not be null\");        Assert.notNull(isNotice, \"IsNotice must not be null\");        title = board.title;        content = board.content;        isNotice = board.isNotice;        return this;    }}@Column 어노테이션의 속성은 이전에 작성한 JPA 글을 참고하세요.@Convert 어노테이션은 column 타입과 필드 타입을 달리 하고 싶을때 사용합니다. isNotice 필드는 boolean 타입인데, DB에 YN 형태로 저장하고 싶다면 컨버터를 통해 전환해야 합니다. 즉, 컨버터 클래스를 만들어야 합니다. 적당한 곳에 BooleanToYNConverter.java 클래스를 만들고 다음과 같이 작성하세요.BooleanToYNConverter.javaimport javax.persistence.AttributeConverter;import javax.persistence.Converter;/** * Boolean 타입을 YN 문자열로 전환 * * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 6:52 */@Converterpublic class BooleanToYNConverter implements AttributeConverter&lt;Boolean, String&gt; {    @Override    public String convertToDatabaseColumn(Boolean attribute) {        return (attribute != null &amp;&amp; attribute) ? \"Y\" : \"N\";    }    @Override    public Boolean convertToEntityAttribute(String dbData) {        return \"Y\".equals(dbData);    }}@Converter 어노테이션을 통해 컨버터라는 것을 선언하고 AttributeConverter 인터페이스를 상속받아 convertToDatabaseColumn, convertToEntityAttribute 메소드를 구현합니다.메소드명에서 알 수 있듯이 convertToDatabaseColumn 메소드는 필드를 column으로 바꾸는 메소드이고, convertToEntityAttribute 메소드는 column을 필드로 바꾸는 메소드입니다.content 필드에서 @Lob 어노테이션은 대용량의 문자열이나 이진스트림을 저장할 때 사용합니다.likeCount, dislikeCount, readedCount 필드는 쿼리를 통해 값을 증가시킬 예정으로, update가 되지 않도록 설정합니다.이제 생성 시간과 업데이트 시간을 필드에 추가해야 한데, ERD를 보면 두 필드는 모든 테이블에서 반복되어 나타납니다. 그러므로 두 필드를 가진 객체를 부모클래스로 하여 상속받도록 하겠습니다.BaseTime 클래스를 다음과 같이 작성하세요.BaseTime.javaimport java.time.LocalDateTime;import javax.persistence.EntityListeners;import javax.persistence.MappedSuperclass;import org.springframework.data.annotation.CreatedDate;import org.springframework.data.annotation.LastModifiedDate;import org.springframework.data.jpa.domain.support.AuditingEntityListener;import lombok.Getter;/** * 시간 도메인 *  * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-12 오후 12:09 */@Getter@MappedSuperclass@EntityListeners(AuditingEntityListener.class)public class BaseTime {    @CreatedDate    private LocalDateTime createDate;    @LastModifiedDate    private LocalDateTime updateDate;}@MappedSuperclass 어노테이션은 이 클래스가 Entity 클래스의 부모클래스 라는 것을 선언합니다. 부모 클래스를 Entity로 선언하면 테이블이 별도로 생성되지만, MappedSuperclass를 선언하면 테이블이 생성되지 않고 상속할 수 있습니다.@EntityListeners 어노테이션은 상태를 관찰하는 리스너를 생성합니다. 이때 스프링이 실행되는 메인 클래스에 다음과 같이 @EnableJpaAuditing 어노테이션을 달아주어야 정상적으로 작동합니다.HexApplication.javaimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.jpa.repository.config.EnableJpaAuditing;@EnableJpaAuditing@SpringBootApplicationpublic class HexApplication {    public static void main(String[] args) {        SpringApplication.run(HexApplication.class, args);    }}나머지는 예상하듯이 @CreatedDate 어노테이션은 INSERT 상태를, @LastModifiedDate 어노테이션은 UPDATE 상태를 관찰하여 시간을 자동으로 입력해줍니다.이제 Board 클래스에 BaseTime 클래스를 extends 해줍니다.Board.javapublic class Board extends BaseTime { ... }Member, Comments, Category, Group 테이블에 대한 Entity 클래스도 동일한 방식으로 작성해주세요.Comments.javaimport javax.persistence.*;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import org.springframework.util.Assert;import lombok.*;/** * 댓글 도메인 * * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 9:18 **/@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Comments extends BaseTime {    @Id @GeneratedValue    private Long commentId;    @Lob @Column(nullable = false)    private String content;    @Column(updatable = false)    @ColumnDefault(\"0\")    private Long likeCount;    @Column(updatable = false)    @ColumnDefault(\"0\")    private Long dislikeCount;    @Builder    public Comments(            Long ,            String commentId    ) {        this.commentId = commentId;        this.content = ccommentSrlontent;    }    public Comments update(Comments comment) {        Assert.notNull(content, \"content must not be null\");        this.content = comment.content;        return this;    }}Member.javaimport java.time.LocalDateTime;import javax.persistence.*;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import lombok.*;/** * 회원 도메인 * * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 9:52 */@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Member extends BaseTime {    @Id @GeneratedValue    private Long memberId;    @Column(length = 80, nullable = false, updatable = false, unique = true)    private String id;    @Column(length = 60, nullable = false)    private String password;    @Column(unique = true)    private String email;    @Column(length = 40, nullable = false)    private String name;    @Column(length = 40, nullable = false, unique = true)    private String nickName;    @Column(name=\"last_login\")    private LocalDateTime updateDate;    @Builder    public Member(            Long memberId,            String id,            String password,            String email,            String name,            String nickName    ) {        this.memberId = memberId;        this.id = id;        this.password = password;        this.email = email;        this.name = name;        this.nickName = nickName;    }}Category.javaimport lombok.*;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import javax.persistence.*;/** * 카테고리 도메인 *  * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 10:19 */@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Category extends BaseTime {    @Id @GeneratedValue    private Long categoryId;    @Column(length = 80, nullable = false, unique = true)    private String category;    @Builder    public Category(Long categoryId, String category) {        this.categoryId = categoryId;        this.category = category;    }}Group.javaimport lombok.*;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import javax.persistence.*;/** * 그룹 도메인 *  * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 10:52 */@Getter@Entity@DynamicInsert@DynamicUpdate@NoArgsConstructor(access = AccessLevel.PROTECTED)public class Group extends BaseTime {    @Id @GeneratedValue    private Long groupId;    @Column(length = 80, nullable = false, unique = true)    private String group;    @Builder    public Group(Long groupId, String group) {        this.groupId = groupId;        this.group = group;    }}이제 연관관계를 맺어야 하는데 여기서 설명하기에는 많은 내용이라 추후에 따로 설명하겠습니다.Repository 작성Entity를 작성했으니 이제 Repository를 작성하겠습니다. Repository로부터 Entity가 생성됩니다. Spring Data JPA를 사용하므로, 인터페이스를 상속받기만 하면 됩니다.BoardRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Board;/** * 게시판 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface BoardRepository extends JpaRepository&lt;Board, Long&gt;  {}CommentRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Comments;/** * 댓글 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface CommentRepository extends JpaRepository&lt;Comments, Long&gt;  {}MemberRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Member;/** * 회원 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;  {}MemberRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Member;/** * 회원 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;  {}CategoryRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Category;/** * 카테고리 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface CategoryRepository extends JpaRepository&lt;Category, Long&gt;  {}GroupRepository.javapackage kr.kro.hex.persistance;import org.springframework.data.jpa.repository.JpaRepository;import kr.kro.hex.domain.Group;/** * 그룹 레포지토리 *  * @author : Rubisco * @version : 1.0.0 * @date : 2022-08-21 오후 10:20 */public interface GroupRepository extends JpaRepository&lt;Group, Long&gt;  {}Service 작성이제 어플리케이션과 DB를 연결해주는 서비스를 작성해 보겠습니다. 게시판의 CRUD 서비스를 만들겠습니다.서비스는 @Service 어노테이션을 통해 선언할 수 있습니다. 우선 아래와 같이 CRUD 메소드를 정의한 인터페이스를 작성합니다.BoardService.javaimport java.util.List;import kr.kro.hex.domain.Board;/** * 게시판 서비스의 인터페이스 * * @see Board 게시판 Entity * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 11:04 */public interface BoardService {    void insertBoard(Board board);    List&lt;Board&gt; getBoardList();    Board getBoard(Board board);    void updateBoard(Board board);    void deleteBoard(Board board);}인터페이스를 상속받은 구현체를 만드세요. 인텔리제이의 경우 구현체부터 만들면 인터페이스 추출이 가능합니다.BoardServiceImpl.javaimport java.util.List;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kr.kro.hex.domain.Board;import kr.kro.hex.persistance.BoardRepository;import kr.kro.hex.service.BoardService;import lombok.RequiredArgsConstructor;/** * 게시판 서비스의 구현체 * * @see Board 게시판 Entity * @see BoardRepository 게시판 레포지토리 * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 11:04 */@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class BoardServiceImpl implements BoardService {        /** 게시판 레포지토리 */    private final BoardRepository boardRepo;    @Override    public void insertBoard(Board board) {}    @Override    public List&lt;Board&gt; getBoardList() {        return null;    }    @Override    public Board getBoard(Board board) {        return board;    }    @Override    public void updateBoard(Board board) {}    @Override    public void deleteBoard(Board board) {}}@RequiredArgsConstructor 어노테이션은 final 키워드가 있는 필드를 매개변수로 하는 생성자를 만들어 줍니다. 즉, 생성자 주입을 가능한 상태로 만듭니다.@Transactional 어노테이션은 트랜잭션 처리를 할 수 있도록 하는데, 클래스에 붙으면 전체 메소드에 트랜잭션 처리 기능이 생깁니다 매개변수 readOnly는 조회만 가능하도록 합니다. flush를 자동으로 호출하지 않기 때문에 수동으로 flush 하지 않는 한 CUD 작업은 동작하지 않습니다. 그러므로 스냅샷을 생성하거나 dirty checking을 하지 않아서 성능이 향상된 효과를 볼 수 있습니다.CUD 작업이 필요한 메소드인 경우 메소드에 @Transactional 어노테이션을 붙이면 됩니다.이제 메소드 단위로 개발을 하시면 됩니다. 간단하게 CRUD 로직을 구현했습니다.BoardServiceImpl.javaimport java.util.List;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import kr.kro.hex.domain.Board;import kr.kro.hex.persistance.BoardRepository;import kr.kro.hex.service.BoardService;import lombok.RequiredArgsConstructor;/** * 게시판 서비스의 구현체 * * @see Board 게시판 Entity * @see BoardRepository 게시판 레포지토리 * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-21 오후 11:04 */@Service@RequiredArgsConstructor@Transactional(readOnly = true)public class BoardServiceImpl implements BoardService {        /** 게시판 레포지토리 */    private final BoardRepository boardRepo;    @Override    public void insertBoard(Board board) {        boardRepo.save(board);    }    @Override    public List&lt;Board&gt; getBoardList() {        return boardRepo.findAll();    }    @Override    public Board getBoard(Board board) {        return boardRepo.findById(board.getDocumentId()).get();    }    @Override    @Transactional(rollbackFor = Exception.class)    public void updateBoard(Board board) {        boardRepo.save(getBoard(board).update(board));    }    @Override    @Transactional(rollbackFor = Exception.class)    public void deleteBoard(Board board) {        boardRepo.deleteById(board.getDocumentId());    }}단위 테스트서비스가 잘 만들어 졌는지 단위테스트를 해보겠습니다. 단위테스트는 Spring에서도 권하는 사항이며, 뷰를 따로 만들 필요가 없기 때문에 메소드 단위로 개발을 했다면 단위테스트를 하시는 것을 추천합니다.VScode에서는 클래스 이름위에 오른쪽 마우스 클릭을 하여 소스작업 -&gt; Generate test... 를 클릭하면 테스트 클래스를 만들 수 있고, 인텔리제이의 경우 Shift + Ctrl + T를 눌러 간단하게 테스트 클래스를 생성할 수 있습니다.BoardServiceImpl.javaimport org.junit.jupiter.api.Test;public class BoardServiceImplTest {    @Test    void testDeleteBoard() {    }    @Test    void testGetBoard() {    }    @Test    void testGetBoardList() {    }    @Test    void testInsertBoard() {    }    @Test    void testUpdateBoard() {    }}자동으로 import 되어 있는 org.junit.jupiter.api.Test는 org.juit.Test로 변경해줍시다. 또한 @SpringBootTest 어노테이션을 붙여서 스프링 부트를 테스트한다는 것을 선언하고, @RunWith(SpringRunner.class) 어노테이션을 붙여 스프링 러너를 함께 실행하도록 합니다.메소드는 public 접근자로 모두 바꾸고 @Autowired 어노테이션으로 BoardService를 주입해주세요.코드를 다음과 같이 작성하고 testInsertBoard -&gt; testGetBoardList -&gt; testUpdateBoard -&gt; testGetBoard -&gt; testDeleteBoard 순서로 실행시키면서 DB 내용을 확인해보세요. 정상적으로 작동하는 것을 볼 수 있습니다.BoardServiceImplTest.javaimport org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import kr.kro.hex.domain.Board;import kr.kro.hex.service.BoardService;@RunWith(SpringRunner.class)@SpringBootTestpublic class BoardServiceImplTest {    @Autowired    private BoardService boardservice;    @Test    public void testDeleteBoard() {        boardservice.deleteBoard(            boardservice.getBoard(                Board.builder().documentId(1L).build()            )        );    }    @Test    public void testGetBoard() {        System.out.println(            boardservice.getBoard(                Board.builder().documentId(1L).build()            ).getTitle()        );    }    @Test    public void testGetBoardList() {        for (Board board : boardservice.getBoardList()) {            System.out.println(board.getTitle());        }    }    @Test    public void testInsertBoard() {        boardservice.insertBoard(            Board.builder()                .isNotice(false)                .title(\"테스트 제목\")                .content(\"테스트 내용\")                .build()        );    }    @Test    public void testUpdateBoard() {        boardservice.updateBoard(            Board.builder()                .documentId(1L)                .title(\"제목 수정\")                .content(\"내용 수정\")                .build()        );    }}Controller 작성컨트롤러는 @Controller 어노테이션을 통해 선언합니다. DispatcherServlet에서 클라이언트의 요청(Request)을 받으면 핸들러를 통해  컨트롤러의 메소드를 검색합니다. 이때 핸들러가 찾을 수 있도록 메소드에 어노테이션을 선언하는데 @RequestMapping, @GetMapping, @PostMapping, @PatchMapping, @DeleteMapping을 사용합니다.보통 Get 요청에는 Read, Post 요청에는 Create, Patch 요청에는 Update, Delete 요청에는 Delete 처리를 합니다. 또한 클래스에 @ReqpuestMapping 어노테이션을 붙여서 엔트리 포인트를 설정 할 수도 있습니다.저는 BoardController를 다음과 같이 작성했습니다.import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PatchMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import kr.kro.hex.domain.Board;import kr.kro.hex.service.BoardService;import kr.kro.hex.service.CategoryService;import lombok.RequiredArgsConstructor;/** * 게시판 서비스 컨트롤러 * * @see BoardService 게시판 서비스 * @see CategoryService 카테고리 서비스 * * @author : Rubisco * @version : 1.0.0 * @since : 2022-08-08 오후 6:24 */@Controller@RequiredArgsConstructor@RequestMapping(path = \"/board\")public class BoardController {        /** 게시판 서비스 */    private final BoardService boardService;    /** 카테고리 서비스 */    private final CategoryService categoryService;    /**     * 게시글 목록 뷰를 반환     *     * @author Rubisco     * @param model 모델     * @return getBoardList.html     */    @GetMapping()    public String getBoardListView(Model model) {        model.addAttribute(\"boardList\", boardService.getBoardList());        return \"getBoardList\";    }    /**     * 게시글 뷰를 반환     *     * @see Board     * @author Rubisco     * @param board 게시글     * @param model 모델     * @return getBoard.html     */    @GetMapping(\"/{documentId}\")    public String getBoardView(Board board, Model model) {        model.addAttribute(\"nl\", System.getProperty(\"line.separator\"));        model.addAttribute(\"board\", boardService.getBoard(board));        return \"/board/getBoard\";    }    /**     * 게시글 작성 페이지 뷰를 반환     *     * @author Rubisco     * @param model 모델     * @return insertBoard.html     */    @GetMapping(params = \"act=write\")    public String insertBoardView(Model model) {        model.addAttribute(\"categoryList\", categoryService.getCategoryList());        return \"/board/insertBoard\";    }    /**     * 게시글 수정 페이지 뷰를 반환     *     * @see Board     * @param board 게시글     * @param model 모델     * @return insertBoard.html     * @author Rubisco     */    @GetMapping(params = {\"documentId\",\"act=update\"})    public String updateBoardView(Board board, Model model) {        model.addAttribute(\"board\", boardService.getBoard(board));        model.addAttribute(\"categoryList\", categoryService.getCategoryList());        return \"/board/insertBoard\";    }    /**     * 게시글 등록 요청을 처리     *     * @see Board     * @author Rubisco     * @param board 게시글     * @return redirect:/board     */    @PostMapping()    public String insertBoardController(Board board) {        boardService.insertBoard(board);        return \"redirect:/board\";    }    /**     * 게시글 수정 요청을 처리     *     * @see Board     * @param board 게시글     * @author Rubisco     * @return redirect:/board/{documentId}     */    @PatchMapping(params = \"documentId\")    public String updateBoard(Board board) {        boardService.updateBoard(board);        return \"redirect:/board/\"+board.getDocumentId();    }    /**     * 게시글 삭제 요청을 처리     *     * @author Rubisco     * @param board     * @return redirect:/board     */    @DeleteMapping(params = \"documentId\")    public String deleteBoard(Board board) {        boardService.deleteBoard(board);        return \"redirect:/board\";    }}이제 컨트롤러에서 반환하는 뷰의 이름에 맞는 템플릿을 작성하면 프로그램은 정상적으로 작동할 수 있게 됩니다.뷰는 타임리프 템플릿 엔진을 사용해서 작성할것인데 이또한 내용이 많으므로 추후에 따로 글을 올리겠습니다.",
        "url": "/java/spring_boot"
    }
    ,
    
    "java-spring": {
        "title": "스프링 프레임워크(Spring Framework)",
            "author": "rubisco",
            "category": "",
            "content": "스프링(Spring)스프링(Spring)은 자바 엔터프라이즈 개발을 위한 오픈소스 경량 애플리케이션 프레임워크 입니다. 파이썬에는 Django, 자바스크립트에는 Nodejs를 통해 웹서버를 개발한다면, 자바에서는 Spring을 사용하여 웹서비스를 만들 수 있습니다. 우리나라에서는 공공기관의 웹 서비스 개발 시 사용하는 전자정부 표준프레임워크의 기반 기술로 스프링을 사용하고 있습니다.스프링 이전에는 엔터프라이즈 자바빈즈(Enterprise JavaBeans, EJB)라는 엔터프라이즈 에디션(Java Enterprise Edition, Java EE)으로 애플리케이션을 개발했습니다. 하지만 EJB 기술의 복잡도가 증가함에 따라 EJB로 애플리케이션을 개발하는 것이 어려워졌고, 개발자들은 좀 더 쉽게 개발할 방법을 요구하게 됩니다. 이 시기를 개발자들은 자바의 겨울에 비유하였고, 스프링이 등장함으로써 겨울이 끝나고 봄이 찾아오게 될 것이라는 의미로 스프링 이라는 이름이 지어졌다고 합니다.Spring Framework스프링은 Spring Framework, Spring Boot, Spring MVC, Spring Data 등 다양한 프로젝트로 구분되며, 기본이 되는 프로젝트는 스프링 프레임워크(Spring Framework) 입니다. 스프링 프레임워크은 약 20개의 모듈로 구성되어 있으며, 아키텍처는 다음과 같습니다.이 중에서도 핵심은 코어 모듈인 Core Container입니다. 코어 컨테이너에서 Beans 모듈은 IOC 패턴을 통해 객체의 구성부터 의존성 처리까지 맡고 있는 가장 핵심적인 모듈이라 할 수 있습니다.Spring MVC스프링 MVC는 이전에 설명했던 MVC 패턴 기반의 웹 프레임워크 입니다. MVC2모델의 발전된 형태의 구조를 하고 있습니다.스프링 MVC는 Front Controller인 DispatcherServlet에서 모든 요청(Request)을 받아 각 컨트롤러로 요청을 위임하는 형태입니다.디스패처 서블릿은 다음과 같은 상속 구조를 가지고 있습니다.HTTP 프로토콜 서비스를 지원하는 HttpServlet을 상속받고 있는데 HttpServlet의 service 메소드를 통해 DispatcherServlet의 doDispatch 메소드가 호출됩니다.doDispatch는 사용자의 요청에 대하여 적절한 컨트롤러를 찾아 매핑해주며, View까지 찾아서 렌더링 해주는 핵심적인 메소드입니다.아래 메소드를 보면 HandlerAdapter를 통해 핸들러를 실행시켜 ModelAndView 객체를 생성하고, processDispatchResult를 호출하는 것을 확인할 수 있습니다.dispatherServlet 클래스의 doDispatch 메소드protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try {        ModelAndView mv = null;        Exception dispatchException = null;        try {            processedRequest = checkMultipart(request);            multipartRequestParsed = (processedRequest != request);            // Determine handler for the current request.            mappedHandler = getHandler(processedRequest);            if (mappedHandler == null) {                noHandlerFound(processedRequest, response);                return;            }            // Determine handler adapter for the current request.            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());            // Process last-modified header, if supported by the handler.            String method = request.getMethod();            boolean isGet = HttpMethod.GET.matches(method);            if (isGet || HttpMethod.HEAD.matches(method)) {                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {                    return;                }            }            if (!mappedHandler.applyPreHandle(processedRequest, response)) {                return;            }            // Actually invoke the handler.            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            if (asyncManager.isConcurrentHandlingStarted()) {                return;            }            applyDefaultViewName(processedRequest, mv);            mappedHandler.applyPostHandle(processedRequest, response, mv);        }        catch (Exception ex) {            dispatchException = ex;        }        catch (Throwable err) {            // As of 4.3, we're processing Errors thrown from handler methods as well,            // making them available for @ExceptionHandler methods and other scenarios.            dispatchException = new NestedServletException(\"Handler dispatch failed\", err);        }        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    }    catch (Exception ex) {        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);    }    catch (Throwable err) {        triggerAfterCompletion(processedRequest, response, mappedHandler,                new NestedServletException(\"Handler processing failed\", err));    }    finally {        if (asyncManager.isConcurrentHandlingStarted()) {            // Instead of postHandle and afterCompletion            if (mappedHandler != null) {                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            }        }        else {            // Clean up any resources used by a multipart request.            if (multipartRequestParsed) {                cleanupMultipart(processedRequest);            }        }    }}Spring Boot스프링 부트는 스프링 프레임워크의 복잡한 환경설정을 최소화할 수 있도록 구성된 프로젝트 입니다. 스프링 프레임워크의 설정 부분을 자동화 하여 사용자가 편안하게 스프링을 활용할 수 있도록 돕습니다. 의존성으로 spring-boot-starter만 추가해주면 바로 API를 정의하고 내장된 톰켓을 통해 웹 어플리케이션 서버(Web Application Server, WAS)를 실행시킵니다.심지어 Spring Initializr를 통해 곧바로 실행가능한 코드를 만들 수 있어서 실행환경이나 의존성 관리 등의 인프라스트럭쳐(infrastructure)를 고려하지 않고 코드 개발을 할 수 있습니다.Spring Data스프링 데이터는 데이터의 영속성을 위해 사용할 수 있는 모듈의 집합입니다. JDBC, ORM, JPA와 관련된 모듈은 이 프로젝트에 포함되어 있으며, 관계형 데이터베이스, 비관계형 데이터베이스에 관계없이 데이터 접근에 대하여 일관된 방식을 제공합니다.스프링의 핵심스프링은 자바 언어 기반의 프레임워크 입니다. 자바 언어의 가장 큰 특징은 객체 지향 언어라는 것입니다.EJB는 컨테이너가 비즈니스 객체를 관리하여 필요할때마다 컨테이너로부터 객체를 받아쓰는 형식으로 비즈니스 로직의 복잡성 문제를 해결했지만, 문제는 비즈니스 로직이 EJB에 종속된다는 것이었습니다. 하나의 기능을 구현하기 위해 EJB에서 구현된 불필요한 객체들을 상속받아야 했으며, 이러한 이유로 실제 비즈니스 로직보다 EJB를 사용하기 위한 코드가 길어지고 복잡해졌을 뿐만 아니라 객체 지향의 핵심 가치인 상속과 다형성 등을 포기해야 했습니다.이러한 상황에서 특정 기술에 종속되어 작동하는 객체가 아닌 순수한 자바객체를 뜻하는 POJO(Plain Old Java Object)라는 단어가 만들어 졌습니다. POJO는 말 그대로 오래된 방식의 간단한 자바 오브젝트 입니다. 개발자들은 옛날 객체지향성이 컸던 시절로 돌아가자는 의미에서 POJO를 개발하게 되었습니다.POJOpublic class Board {        private long seq;    private String title;    private String content;    public void setSeq(long seq) {        this.seq = seq;    }    public void getSeq() {        return this.seq;    }    public void setTitle(String title) {        this.title = title;    }    public void getTitle() {        return this.title;    }    public void setContent(String content) {        this.content = content;    }    public void getContent() {        return this.content;    }}위의 코드와 같이 기본적인 필드와 이에 해당하는 getter 및 setter로 구성된 객체를 POJO라고 합니다.스프링의 핵심 이념은 POJO를 통해 개발하면서 EJB에서 제공하는 엔터프라이즈 서비스를 그대로 사용하자는 것에 있습니다. 즉, 스프링은 특정 기술에 종속되지 않으면서 객체를 관리할 수 있는 컨테이너를 제공합니다. 이것을 가능하게 한 핵심 기술은 IOC/DI, AOP, PSA 입니다.제어의 반전(Inverson of Control, IoC)IoC는 코드의 흐름을 제어하는 주체가 바뀌는 패턴을 말합니다.프레임워크를 사용하지 않는 일반적인 프로그램의 경우 객체의 라이프사이클(생성, 초기화, 소멸, 호출 등)을 클라이언트가 직접 관리합니다.Cient.javapublic class Client {    public static void main(String[] args) {        Board board = new Board();        ...        board.submit();    }}Board.javapublic class Board {        private long seq;    private String title;    private String content;    public Board(long seq, String title, String content) {        this.seq = seq;        this.title = title;        this.content = content;    }    public void submit() {        ...    }}보시는 것처럼 new 키워드를 통해 클라이언트가 직접 Board 객체를 생성하고 Board 객체의 로직을 구현하고 있습니다.반면 스프링 프레임워크를 사용하면 클라이언트가 객체를 직접 객체를 제어하지 않고 IoC 컨테이너에게 제어권을 양도합니다.스프링 프레임워크를 통한 프로그래밍@Controllerpublic class BoardController {    @GetMapping(\"/Board\")    public String getBoarView(Board board) {        ...    }}보시는 것처럼 클라이언트는 BoardController 객체를 직접 생성하지 않고 @Controller 어노테이션을 선언하는 것 만으로도 구현한 로직을 작동시킬 수 있습니다.IOC를 구현하는 방법은 다양한데, 대표적으로 템플릿 메소드 패턴(Template Method Pattern)을 통해서 구현될 수 있습니다.템플릿 메소드 패턴은 알고리즘의 구조를 메소드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴입니다. 객체지향 프로그래밍을 한다면 무의식적으로 사용하게 되는 패턴입니다.예제 코드를 하나 작성해 보겠습니다.Ramen.javapublic abstract class Ramen {        public void make() {        boilWater();        putNoodles();        putIngredients();        waiting();        complete();    }    public void boilWater() {        System.out.println(\"물을 끓입니다.\");    }    public void putNoodles() {        System.out.println(\"면을 넣습니다.\");    }    public abstract void putIngredients();    public void waiting() {        System.out.println(\"3분을 기다립니다.\");    }    public abstract void complete();}KimchiRamen.javapublic class KimchiRamen extends Ramen {    @Override    public void complete() {        System.out.println(\"김치라면 완성!!\");    }    @Override    public void putIngredients() {        System.out.println(\"김치를 넣습니다.\");    }    }SeafoodRamen.javapublic class SeafoodRamen extends Ramen {    @Override    public void complete() {        System.out.println(\"해물라면 완성!!\");    }    @Override    public void putIngredients() {        System.out.println(\"해물을 넣습니다.\");    }    }CheeseRamen.javapublic class CheeseRamen extends Ramen {    @Override    public void complete() {        System.out.println(\"치즈라면 완성!!\");    }    @Override    public void putIngredients() {        System.out.println(\"치즈를 넣습니다.\");    }    }라면을 끓이는 로직입니다. 상위 클래스인 Ramen은 추상 클래스이며, make 메소드에는 라면을 끓이는 순서를 정의해 두었습니다. 또한 공통 메소드를 구현하고 재료투입 로직인 putIngredients 메소드와 완성 로직인 complete 메소드는 abstract 키워드를 통해 추상메소드로 선언했습니다.Ramen을 상속받는 구현체인 KimchiRamen, SeafoodRamen CheeseRamen은 재료투입 로직과 완성 로직을 각각 구현했습니다.재료를 투입하고 완성시키는 로직은 하위 클래스에서 구현했지만 해당 메소드가 호출되는 시점은 상위 클래스의 make 로직에 의하여 결정됩니다. 즉, 제어의 역전이 일어났습니다.스프링은 IoC 컨테이너를 통해 객체의 흐름을 제어합니다. 개발자는 객체의 제어권을 IoC 컨테이너에 양도함으로써 프로그램의 흐름을 고려할 필요없이 구현로직에만 집중할 수 있게 됩니다.의존성 주입(Dependency Injection, DI)DI는 IoC를 구현하는 패턴 중 하나입니다. IoC 컨테이너는 DI를 통해 IoC를 구현합니다. DI는 이름에서 알 수 있듯이 객체의 의존 관계를 외부에서 주입시켜주는 패턴입니다.위에서 작성한 Ramen 클래스를 사용하여 클라이언트가 라면을 끓여보겠습니다.Client.javapublic class Client {    private Ramen ramen = new SeafoodRamen();    public void makeRamen() {        ramen.make();    }    public static void main(String[] args) {        Client client = new Client();        try {            client.makeRamen();        } catch (Exception e) {            e.printStackTrace();        }    }}정상적으로 해물라면이 만들어질 것입니다. 그런데 해물라면 로직에 변화가 생긴 경우를 가정해봅시다.SeafoodRamen.javapublic class SeafoodRamen extends Ramen {    private final String seafood;    public SeafoodRamen(String seafood) {        this.seafood = seafood;    }    @Override    public void complete() {        System.out.println(seafood + \"라면 완성!!\");    }    @Override    public void putIngredients() {        System.out.println(seafood + \"을(를) 넣습니다.\");    }}seafood라는 String 필드가 하나 만들어졌으며, 생성자는 seafood를 요구합니다. 하지만 클라이언트는 seafood를 매개변수로 주지 않았으므로 컴파일 에러가 발생할 것입니다. 즉, SeafoodRamen 클래스를 수정하면 Client 클래스도 함께 수정해야 프로그램이 정상작동합니다.이런 경우 Client는 SeafoodRamen에 의존한다. 라고 표현합니다. Client 클래스 내부에 SeafoodRamen 객체를 생성하고 있기 때문에 의존관계가 고정되어 있습니다. 즉, 클라이언트는 해물라면에 강하게 의존하고 있습니다.코드를 다음과 같이 변경해 보겠습니다.Client.javapublic class Client {    private Ramen ramen;    public Client(Ramen ramen) {        this.ramen = ramen;    }    public void makeRamen() {        ramen.make();    }    public static void main(String[] args) {        Ramen ramen = new SeafoodRamen(\"새우\");        Client client = new Client(ramen);        try {            client.makeRamen();        } catch (Exception e) {            e.printStackTrace();        }    }}여전히 Client는 Ramen에 의존하고 있지만 의존대상인 Ramen을 외부로부터 주입받았습니다. 정상적인 Ramen 객체를 주입받는다면 Client 클래스는 수정하지 않더라도 프로그램이 정상작동할 수 있게 됩니다. 또한 해물라면 뿐만 아니라 김치라면, 치즈라면 등 다양한 라면을 끓일 수 있습니다. 즉, 해물라면에 대한 의존관계를 약화시키고 다형성을 확보할 수 있게 되었습니다.DI를 하는 방법은 3가지가 있습니다.생성자 주입(Constructor Injection)위에 예제에서 구현한 의존성 주입 방식으로, 생성자 주입은 스프링에서 권장하고 있는 방식입니다.Client.javapublic class Client {    private Ramen ramen;    public Client(Ramen ramen) {        this.ramen = ramen;    }    public void makeRamen() {        ramen.make();    }}세터 주입(Setter Injection)자바빈 패턴으로 세터를 통해 의존성을 주입받습니다.Client.javapublic class Client {    private Ramen ramen;    public void setRamen(Ramen ramen) {        this.ramen = ramen;    }    public void makeRamen() {        ramen.make();    }}인터페이스 주입(Interface Injection)인터페이스를 통해 의존성 주입을 담보받는 형식입니다. Ramen을 주입받는 Client는 해당 인터페이스의 구현체가 됩니다.Client.javapublic class Client implements RamenInject {    private Ramen ramen;    @Override    public void injectRamen(Ramen ramen) {        this.ramen = ramen;    }    public void makeRamen() {        ramen.make();    }}RamenInject.javapublic interface RamenInject {    public void injectRamen(Ramen ramen);}이처럼 스프링은 DI를 통해 IOC를 구현하면서 객체 사이의 의존성을 약화시키고 다형성을 확보합니다. 스프링으로 컨트롤러를 만들어보겠습니다.BoardController.java@Controllerpublic class BoardController {    private final BoardService boardService;    public BoardController(BoardService service) {        this.boardService = service;    }    ...BoardController 는 BoardService에 의존하고 있다는 것을 확인할 수 있습니다.@Controller 어노테이션을 붙이면 스프링의 IoC 컨테이너에서 관리하는 객체인 Bean으로 등록되어 객체가 자동으로 생성됩니다. 이때 자동으로 의존성 주입이 일어나는데 @Autowired 어노테이션을 붙임으로써 의존성을 주입받습니다.그런데 위에 작성한 코드에는 @Autowired 어노테이션이 없습니다. 이것은 생성자가 1개인 경우 IoC 컨테이너가 자동으로 이를 인식하여 의존성을 주입해 주기때문입니다.스프링에서 DI를 하는 방식은 다음과 같습니다.필드 주입(Fild Injection)필드 주입은 의존성을 주입할 필드에 @Autowired 어노테이션을 붙입니다.BoardController.java@Controllerpublic class BoardController {    @Autowired    private BoardService boardService;    ...}필드 주입은 가장 간단하면서도 가장 추천되지 않는 방식입니다. 인텔리제이에서 필드 주입을 하면 경고를 나타내는 것을 확인할 수 있습니다.필드 주입의 경우 외부에서 접근이 불가능합니다. 이것은 다시 말해서 DI 프레임워크나 리플렉션 없이는 필드값을 주입해 줄 방법이 없다는 것을 의미합니다. 즉, 프레임워크에 강하게 종속적인 객체가 되어버립니다.또한 필드 주입은 순환참조 문제가 발생할 수 있습니다. 다음 코드를 확인해봅시다.Chicken.java@Componentpublic class Chicken {        @Autowired    private Egg egg;    public void layEgg() {        egg.becomeChicken();    }}Egg.java@Componentpublic class Egg {        @Autowired    private Chicken chicken;    public void becomeChicken() {        chicken.layEgg();    }}닭은 알에 의존하고 알은 닭에 의존하고 있는 형태입니다. 닭은 알을 놓고, 알은 닭이 됩니다.이 코드는 컴파일 시점에서는 문제가 되지 않지만 런타임 시점에서 메소드를 호출하는 순간 스택오버플로우가 발생합니다.서로 메소드를 참조하여 무한하게 순환하기 때문입니다. 즉, 컴파일 시점에서 에러를 발견할 수 없다는 문제점이 있습니다.이러한 이유로 필드 주입은 지양해야합니다.세터 주입(Setter Injection)세터 주입은 Setter에 @Autowired 어노테이션을 붙여 의존성을 주입합니다.BoardController.java@Controllerpublic class BoardController {        private BoardService boardService;    @Autowired    public void setBoardService(BoardService boardservice) {        this.boardService = boardservice;    }    ...}세터 주입 역시 순환참조 문제가 발생할 수 있습니다. 하지만 의존성을 수정할 수 있기 때문에 런타임에서 의존성 수정이 필요한 경우 사용합니다.생성자 주입(Constructor Injection)생성자 주입은 스프링에서 공식적으로 추천하는 방식입니다.BoardController.java@Controllerpublic class BoardController {        private final BoardService boardService;    public BoardController(BoardService boardservice) {        this.boardService = boardservice;    }    ...}생성자 주입의 경우 최초 빈(Bean)의 생성시 1회 호출을 보장하며, 다른 방식과 달리 필드에 final 키워드를 사용가능합니다. 또한 컴파일 시점에서 순환참조를 체크하기 때문에 에러를 초기에 발견할 수 있습니다.위에서 설명했듯이 단일 생성자의 경우 어노테이션을 붙이지 않아도 되며, 생성자가 여러 개인 경우 매개변수가 가장 많은 생성자에 의존성을 주입합니다. @Autowired 어노테이션을 붙여 명시적으로 의존성 주입을 위한 생성자를 지정할 수도 있습니다.관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)AOP는 관심사(기능)를 분리하여 개발의 복잡성을 낮추기 위한 프로그래밍 패러다임의 하나입니다.객체 지향 프로그래밍(Object Oriented Programming, OOP)에서는 주요 관심사에 따라 클래스를 분할하는데, 이 클래스들은 단일 책임 원칙(Single Responsibility Principle, SRP)에 따라 설계되어 있습니다. 하지만 클래스를 설계하다보면 로깅, 보안, 트랜잭션 등 공통적으로 사용하는 부가기능이 생길 수 있습니다. 이때 공통되지 않는 주요 비즈니스 로직을 핵심 관심사(Core Concern)라고 하며, 주요한 비즈니스 로직은 아니지만 반복적으로 사용되는 관심사를 횡단 관심사(Cross Cutting Concern)라고 합니다.AOP에서 관점(Aspect)이란 이러한 횡단 관심사를 하나로 모아 모듈화 시킨 것을 의미합니다. 즉, AOP는 흩어져 있는 횡단 관심사를 별도의 클래스로 모듈화하여 OOP에 도움을 주는 부가적인 기능이라 할 수 있습니다.스프링에서 AOP는 프록시 패턴(Proxy Pattern)을 통해 구현됩니다. 프록시 패턴은 다른 객체로의 접근을 통제하기 위해 그 객체의 대리자를 두는 패턴입니다.프록시는 인터페이스를 통해 실제 서비스와 동일한 이름의 메소드를 구현하여 실제 서비스에 대한 직접적인 접근을 제어할 수 있으며, 메소드 호출 전후에 별도의 로직을 수행하도록 할 수 있습니다.프록시 패턴의 예제 코드를 작성해 보겠습니다.Target.javapublic interface Target {    public void logic();}TargetImpl.javapublic class TargetImpl implements Target {    @Override    public void logic() {        System.out.println(\"비즈니스 로직 수행\");    }}TargetProxy.javapublic class TargetProxy implements Target {        private final Target target;    public TargetProxy(Target target) {        this.target = target;    }    private void before() {        System.out.println(\"비즈니스 로직 수행 전 실행\");    }    private void after() {        System.out.println(\"비즈니스 로직 수행 후 실행\");    }    @Override    public void logic() {        before();        target.logic();        after();    }}Client.javapublic class Client {    public static void main(String[] args) {        Target target = new TargetImpl();        Target proxy = new TargetProxy(target);        proxy.logic();    }}위에 코드와 같이 프록시를 통해 비즈니스 로직을 수행하면 비즈니스 로직 전후로 부가적인 기능을 추가할 수 있게 됩니다. 스프링 AOP의 대표적인 예로 트랜잭션 처리를 위한 @Transactional 어노테이션이 있습니다. 해당 어노테이션이 붙은 메소드는 메소드의 실행 전 autoCommit(false) 처리를 하고, 메소드 실행 후 commit() 처리를 합니다. 또한 트랜잭션 오류가 발생하면 rollback()이 수행되도록 합니다.교체가능한 서비스 추상화(Portable Service Abstraction, PSA)PSA는 환경의 변화 및 세부기술의 변경과 상관없이 일관된 방식으로 기술에 접근할 수 있게 해주는 설계원칙을 말합니다.PSA는 POJO 원칙을 철저하게 따르는 스프링의 기능으로, 스프링에서 동작하는 라이브러리들은 POJO 원칙을 지키게끔 PSA 형태로 추상화 되어있습니다. 즉, 복잡한 기술은 내부에 숨기면서 개발자에게 편의성을 제공합니다.예를 들어 트랜잭션을 처리하는 경우, 놀랍게도 JDBC를 통해 DB에 접근하든 JPA를 통해 DB에 접근하든 @Transactional 어노테이션을 선언하는 것 만으로도 별도의 코드를 추가할 필요없이 트랜잭션 서비스를 사용할 수 있습니다.",
        "url": "/java/spring"
    }
    ,
    
    "etc-plantuml": {
        "title": "VSCode로 UML 그리기",
            "author": "rubisco",
            "category": "",
            "content": "PlantUML클래스를 설계할 때 클래스 다이어그램(Class Diagram)을 그리게 됩니다. 클래스 다이어그램 뿐만 아니라 프로젝트의 문서를 작성한다면 시퀀스 다이어그램(Sequence Diagram), 유스케이스 다이어그램(Usecase Diagram) 등 다이어그램을 작성이 필요합니다.사용해 보지는 않았지만 UML을 그리는 대표적인 도구로 StarUML이 있습니다. 또한 인텔리제이(IntelliJ) 얼티메이트 에디션에는 자동으로 다이어그램을 그리는 플러그인이 포함되어 있습니다. 그러나 StarUML은 GUI를 통해 직접 UML을 그려야 하며, 인텔리제이의 경우 UML 기능이 유료입니다.인텔리제이의 기능만큼은 아니지만 자동으로 UML을 그려주는 도구가 있는데, 바로 PlantUML입니다. 간단한게 객체간의 관계를 정의해준다면 자동으로 UML을 생성해줍니다.설치PlantUML은 PlantUML Online Server를 제공하여 웹에서 UML을 만들 수 있지만 로컬에 설치하여 사용할 수도 있습니다. 간단하게는 apt를 통해 설치할 수 있습니다.$ sudo apt-get install plantumlVSCode의 확장팩을 통해 설치할 수도 있습니다. VScode Extension에서 plantuml을 검색하여 설치합니다.작동을 위해서는 DOT 스크립트로 그래프를 그려주는 graphviz라는 도구가 필요합니다. apt를 통해 설치해주도록 합시다.$ sudo apt install graphviz준비는 되었습니다. 이제 관계를 정의해주면 자동으로 UML을 그릴 수 있습니다. 지원하는 파일 확장자는 다음과 같습니다.  *.wsd, *.pu, *.puml, *.plantuml, *.iumlUML 그리기먼저 관계를 정의하기 위한 파일을 생성합니다.$ touch testuml.wsd간단하게 클래스의 관계를 정의해보겠습니다.testuml.wsd@startuml testinterface Subject {    +notify(Observer): void}class ConcreteSubject {    +notify(Observer): void}interface Observer {    +update(): void}class ConcreteObserverA {    +update(): void}class ConcreteObserverB {    +update(): void}class ConcreteObserverC {    +update(): void}Subject --&gt; ObserverSubject &lt;|.. ConcreteSubjectObserver &lt;|.. ConcreteObserverAObserver &lt;|.. ConcreteObserverBObserver &lt;|.. ConcreteObserverCConcreteSubject --&gt; ConcreteObserverAConcreteSubject --&gt; ConcreteObserverBConcreteSubject --&gt; ConcreteObserverC@enduml이제 vscode에서 ctrl + shift + p를 눌러 팔레트를 열고 PlantUML: Export Current Diagram을 선택하고 이미지 포멧을 선택하면 자동으로 UML 이미지가 만들어집니다.그래프 도구인 graphviz를 통해 그려서 depth가 구분됩니다. Observer와 Subject의 depth를 같도록 그려주고 싶은데 잘 찾아보면 방법이 있을듯 합니다.다르게 표현할 수 있을듯 한데 일단은 이런 형식으로 사용이 가능합니다.자세한 작성법은 PlantUML 문서(한글)를 참조하세요.",
        "url": "/etc/plantuml"
    }
    ,
    
    "etc-ubuntu-dev-env": {
        "title": "원격 코드 개발환경 구축",
            "author": "rubisco",
            "category": "",
            "content": "우분투 20.04 LTS 환경인 원격 컴퓨터에 코딩환경을 구축하고, VSCode를 통해 원격 환경에서 코드 개발을 해보도록 하겠습니다.원격 접속Remote Development 설치우선 vscode extentions에서 Remote Development를 설치합니다.Remote - WSL, Remote - SSH, Remote - Containers 등이 함께 설치됩니다.원격 접속F1을 누르고 Remote-SSH: Connect to Host...를 클릭합니다.+ Add New SSH Host...를 클릭합니다.ssh 원격접속을 위한 명령어를 입력합니다. 터미널에서 ssh 연결하는 명령어와 같습니다.Remote Development 설치원격환경에 접속하면 필요한 extenstions를 설치해줍니다.extension이 로컬에 설치되어 있지만 원격환경에는 설치되어 있지 않다면 다음과 같이 extenstion 아래에 Install in SSH: server... 라고 뜹니다.JAVA 환경 설정JDK 설치apt 업데이트win + R `을 눌러 터미널을 열고 ssh로 원격 접속 후 apt를 업데이트 해주세요.$ sudo apt update &amp;&amp; sudo apt upgrade -yjdk 설치원하는 자바 버전을 설치합니다. 11버전과 17버전을 설치하도록 하겠습니다.$ sudo apt install openjdk-11-jdk$ sudo apt install openjdk-17-jdk경로(path) 설정bashrc를 nano 에디터로 열고 맨 아래에 JAVA_HOME 경로를 추가해줍시다.$ sudo nano ~/.bashrc...export JAVA_HOME=$(readlink -f /usr/bin/java | sed \"s:bin/java::\")/usr/bin/java 는 자바 설치시 추가되는 심볼릭 링크이며, /etc/alternatives/java를 가리키고 있습니다./etc/alternatives/java는 설치된 자바 버전 중 하나를 가리키고 있습니다.sed \"s:bin/java::\" 부분은 경로의 마지막 bin/java를 제거하는 명령어입니다.변경 사항 적용bashrc의 변경 사항을 적용하기 위해 다음 명령어를 통해 bashrc를 실행해주세요.$ source ~/.bashrc버전 변경우분투에서 어플리케이션의 버전은 update-alternatives를 통해 관리됩니다.아래 그림처럼 java와 javac의 버전을 update-alternatives 명령어를 통해 변경합니다.해당 명령어는 /etc/alternatives/java가 가리키는 경로를 변경함으로써 버전을 동적으로 변경할 수 있도록 해줍니다.현재 JDK 버전 확인$ update-alternatives --list java설치된 JDK 버전 확인$ update-alternatives --list java버전 변경$ sudo update-alternatives --config java$ sudo update-alternatives --config javacSpring Boot 개발 환경VSCode에서 Spring Boot 개발환경을 구축해보겠습니다.Extension 설치VSCode에서 다음 Extension을 설치합니다.  Extension Pack for Java  Spring Boot Extension Pack  Lombok Annotations Support for VS Code  Gradle for Java프로젝트 생성Ctrl + Shift + P를 눌러 커맨드 팔레트(Command palette)를 열고 Spring initalizr을 입력후 선택합니다. Gradle 또는 Maven 프로젝트를 선택할 수 있습니다.그 후 순서대로 스프링 부트 버전, 프로젝트 언어, 그룹 ID, 아티팩트 ID, 패키징 타입, 자바 버전, 의존성 패키지, 루트 경로를 지정합니다.프로젝트 선택스프링 부트 버전 선택프로젝트 언어 선택그룹 ID 설정아티팩트 ID 설정패키징 타입 선택자바 버전 선택의존성 패키지 선택루트 경로 설정디버깅디버깅 환경에서 원격 포트로 연결하기 위해서는 포트를 설정해주어야 합니다. 터미널창 상단의 PORTS 탭을 클릭하세요.add를 눌러 포트를 추가하면 로컬에서 원격 포트로 접근이 가능해집니다.DevTools 사용디버깅 환경에서 뷰를 동적으로 확인하기 위해서는 DevTools 패키지를 설치해야 합니다.Gradle 의존성에 다음 패키지를 추가하세요.compileOnly 'org.springframework.boot:spring-boot-devtools'다음으로 터미널에서 LiveReloadServer 포트를 확인하고 Port에 추가하여 해당 포트를 로컬에서 접근가능하도록 해주세요.크롬에서 Extension인 RemoteLiveReload를 설치해주세요.이제 톰캣 포트로 접속하여 html 파일을 수정하면 실시간으로 내용이 반영되는 것을 확인할 수 있습니다.Phython 환경 설정아나콘다(Anaconda) 설치아나콘다 설치아나콘다 아카이브 또는 아나콘다 다운로드 페이지에 접속하여 OS 환경에 맞는 버전의 설치 경로를 확인합니다.저는 원격 인스턴스가 ARM 64비트 이므로 리눅스 arm64 버전을 설치하도록 하겠습니다.아나콘다 인스톨러 다운로드$ wget https://repo.anaconda.com/archive/Anaconda3-2022.05-Linux-aarch64.sh다운받은 파일을 실행하여 아나콘다를 설치합니다.아나콘다 설치$ bash Anaconda3-2022.05-Linux-aarch64.sh라이센스 동의 문구가 나오는데 Enter를 계속 눌러 쭉 내려간 다음 마지막에 동의여부를 물으면 yes를 입력하세요.환경변수 등록설치가 완료되면 환경변수를 할 것인지 묻는 문구가 나오는데 yes를 입력하여 환경변수를 등록해주세요.no를 입력했다면 bashrc에 환경변수를 직접 등록해야합니다.$ sudo nano ~/.bashrc...export PATH=$HOME/anaconda3/bin:$PATH콘다 환경 비활성화환경변수를 설정하면 쉘에 접속할때마다 콘다의 기본환경이 활성화됩니다. 이를 해제하기 위해 다음 명령어를 입력합니다.$ conda config --set auto_activate_base false변경 사항 적용bashrc의 변경 사항을 적용하기 위해 다음 명령어를 통해 bashrc를 실행해주세요.$ source ~/.bashrc인스톨러 제거다음 명령어를 통해 다운받은 인스톨러를 제거해 주세요.$ rm Anaconda3*가상환경 설정가상환경(virtualenv)은 여러 파이썬 프로젝트가 하나의 컴퓨터에서 충돌을 일으키지 않고 존재할 수 있도록 해주는 독립된 환경을 말합니다.각 프로그램별로 완전히 독립적인 가상의 환경을 만들어서 프로그램별로 라이브러리 모듈 등의 버전을 별도로 지정할 수 있습니다.가상환경 생성가상환경은 다음 명령어를 통해 생성할 수 있습니다.$ conda create -n &lt;가상환경 이름&gt; python=&lt;파이썬 버전&gt; &lt;의존성 패키지 목록&gt;가상환경 생성 예제$ conda create -n ml python=3.9 anaconda가상환경 활성화가상환경은 다음 명령어를 통해 활성화 할 수 있습니다.$ conda activate &lt;가상환경 이름&gt;가상환경 생성 예제$ conda activate ml가상환경 목록 확인가상환경의 목록은 다음 명령어를 통해 확인할 수 있습니다.$ conda env list가상환경 생성가상환경은 다음 명령어를 통해 생성할 수 있습니다.$ conda env remove -n &lt;가상환경 이름&gt;가상환경 생성 예제$ conda env remove -n ml --all패키지 설정패키지 설치패키지는 다음 명령어를 통해 설치할 수 있습니다.$ conda install &lt;패키지 이름&gt;패키지 설치 예제$ conda install tensorflow패키지 제거패키지는 다음 명령어를 통해 제거할 수 있습니다.$ conda remove &lt;패키지 이름&gt;패키지 제거 예제$ conda remove tensorflow패키지 업데이트패키지는 다음 명령어를 통해 업데이트할 수 있습니다.$ conda update &lt;패키지 이름&gt;패키지 업데이트 예제$ conda update tensorflow전체 패키지의 업데이트는 다음과 같습니다.$ conda update --all패키지 정리다양한 conda 환경을 생성하고 패키지를 설치 / 삭제하다 보면 불필요한 캐시가 쌓여 용량에 문제가 발생할 수 있습니다.이때 다음 명령어를 통해 캐시를 제거할 수 있습니다.$ conda clean -p아나콘다 제거아나콘다의 제거는 설치 디렉토리를 제거해주면 됩니다.$ rm -rf ~/anaconda3그런다음 bashrc를 열고 아나콘다 환경변수를 지웁니다.$ sudo nano ~/.bashrc...(환경변수 제거)마지막으로 숨겨진 파일을 제거합니다.$ rm -rf ~/.condarc ~/.conda ~/.continuumNodeJS 환경 설정NVM 설치NodeJS는 apt를 통해 설치할 수도 있지만 다양한 버전을 관리하기 위해서 NVM(Node Version Manager)을 통해 설치하도록 하겠습니다.NVM Github로 이동하여 버전을 확인하고 curl이나 wget을 통해 인스톨러를 설치합니다.$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash$ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash설치가 완료되면 bashrc의 변경 사항을 적용하기 위해 다음 명령어를 통해 bashrc를 실행해주세요.$ source ~/.bashrcNode.js 설치NodeJS의 설치는 NVM의 다음 명령어를 통해 설치할 수 있습니다.$ nvm install &lt;노드 버전&gt;각종 버전 설치 방법$ nvm install node  # 최신 버전 설치$ nvm install --lts # 최신 LTS 버전 설치$ nvm install 16.14.0  # 특정 버전 설치$ nvm install 16  # 특정 버전 16의 최신 릴리즈 설치버전 선택설치된 노드의 버전은 NVM의 다음 명령어를 통해 확인 가능합니다.$ nvm ls기본 노드 버전의 선택은 다음과 같습니다.$ nvm alias default &lt;노드 버전&gt;일시적인 버전의 선택은 다음과 같습니다.$ nvm use &lt;노드 버전&gt;이 경우 터미널이 종료되면 다시 기본 버전으로 돌아갑니다.",
        "url": "/etc/ubuntu-dev-env"
    }
    ,
    
    "java-jpa": {
        "title": "JPA(Java Persistence API)",
            "author": "rubisco",
            "category": "",
            "content": "JPA란?JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준으로, ORM 프레임워크를 쉽게 사용하기 위한 인터페이스의 모음입니다.데이터베이스 연동에 사용되는 기술은 JDBC에서부터 Spring DAO, MyBatis, Hibernate 등 다양합니다. 이 중에서 Hibernate 같은 ORM 프레임워크는 SQL까지 프레임워크에서 제공하여 개발자들이 처리해야 할 업무가 상당히 감소했습니다.이전에는 데이터베이스에 연동하기 위해 SQL Query를 직접 작성하여 영속 데이터를 가져왔습니다. 이 경우 여러 문제점이 있는데 데이터베이스의 테이블이 변경되더라도 SQL Query는 String 형식으로 되어있어서 컴파일 에러가 나오지 않습니다. 또한 Query문을 잘못 작성하더라도 컴파일시 확인할 수 없어서 런타임에서 에러를 발생시킵니다. 이러한 이유로 개발자들은 순수 객체지향 프로그래밍에 집중하지 못하고 Query문 작성에 많은 비용을 지불해야만 했습니다.하지만 Hibernate의 등장으로 이런 문제들이 해소되어 이후 많은 ORM 프레임워크가 등장했으며, 이런 ORM을 보다 쉽게 사용할 수 있도록 표준화 시킨 것이 JPA(Java Persistence API) 입니다.JPA는 애플리케이션과 JDBC 사이에서 동작합니다. 기존 마이바티스 같은 프레임워크는 SQL을 개발자가 직접 XML 파일에 등록하여 사용했지만, JPA를 사용하면 JPA 내부에서 JDBC API를 통해 SQL을 호출하여 DB와 통신하게 됩니다. 즉, 개발자가 직접 JDBC API를 사용하지 않습니다.JPA의 장점은 CRUD SQL을 작성할 필요가 없고 조회된 결과를 객체로 매핑하는 작업을 자동으로 처리하기 때문에 데이터 저장 계층에서 작성해야할 코드가 대폭적으로 줄어듭니다. 또한 SQL이 아닌 객체 중심으로 개발하여 생산성과 유지보수가 좋아집니다.그러나 배우기가 어렵고 잘 이해하지 않으면 데이터 손실이 있을 수 있으며, 복잡한 작업에 대해서는 성능상 문제가 있을 수 있습니다.예제 파일JPA 예제 파일JPA 관련 용어객체-관계 매핑(Object Relational Mapping, ORM)ORM이란 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 기술을 말합니다.기본적으로 객체 지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용하기 때문에 객체 모델과 관계형 모델 간에 불일치가 존재합니다. ORM은 객체 간의 관계를 바탕으로 SQL을 자동으로 생성함으로써 이런 패러다임의 불일치 문제를 해결해줍니다.HibernateJPA가 제공하는 인터페이스를 이용하여 데이터베이스를 처리하면 실제로는 Hibernate 같은 구현체(Implimentations)가 동작합니다. 그렇기 때문에 Hibernate를 통해 개발하더라도 실제 서비스에서는 다른 ORM 기술인 EclipseLink로 변경하더라도 동일한 서비스를 제공할 수 있습니다.5 레이어 아키텍처(5 Layer Architecture)스프링 프레임워크는 MVC 패턴을 좀더 세분화 하여 5 레이어 아키텍처(5 Layer Architecture)로 나타낼 수 있습니다.모델(Model)은 비즈니스 로직 계층(Business Logic Layer)과 영구 계층(Persistence Layer), 도메인 모델 계층(Domain Model Layer)에 해당합니다.여기에서 비즈니스 로직 계층(Business Logic Layer)은 주로 상태 변화를 처리하는 역할을 하며, 컨트롤러와 JPA를 연결해주는 서비스(Service)와 객체를 연관 테이블과 매핑해주는 도메인(Domain)으로 나눌 수 있습니다.기존에는 비즈니스 로직과 ORM 기능을 모두 이 계층에서 수행했지만 이를 분리하여 비즈니스 로직은 서비스에서, ORM 기능은 도메인에서 수행합니다.5 레이어 아키텍처는 도메인 주도 설계(Domain Driven Design, DDD)와 관련있는데, 아직 이에 대한 이해도가 부족하여 생략하겠습니다.아래에는 비즈니스 로직 계층과 관련된 객체들에 대한 설명입니다.DAO(Data Access Object)DAO(Data Access Object)는 DB에 접근하여 CRUD를 할 수 있는 객체입니다. 서비스와 DB를 연결해주며, 구현체에 CRUD 기능을 구현하고 이를 의존성 주입(DI)해주는 방식으로 사용됩니다. 스프링에서는 Repository가 DAO 역할을 하는데, DB 접근 방식에 약간의 차이가 있다고 합니다.DTO(Data Transfer Object)DTO(Data Transfer Object)는 계층 간 데이터 교환을 하기 위해 사용하는 객체입니다. 로직을 가지지 않는 순수한 데이터 객체로서, getter나 setter 정도의 메소드를 가질 수 있습니다.이와 비슷한 VO(value Object) 객체는 오직 읽기만 가능한 read-Only 특징을 가지며, getter 메소드만 가지고 있습니다.Board.javaimport lombok.Getter;import lombok.Setter;import lombok.ToString;import java.util.Date;@Getter@Setter@ToStringpublic class Board {    private Long seq;    private String title;    private String writer;    private String content;    private Date createDate;    private Long cnt;}Domain(=Entity)도메인은 DB 테이블과 매핑되는 객체입니다. 변경사항이 생기면 여러 다른 클래스에 영향을 주기때문에 변경사항이 많은 DTO와 분리하여 사용됩니다.도메인의 생성에는 @Entity, @Column, @Id 등과 같은 어노테이션(annotation)이 사용됩니다.Board.javaimport lombok.*;import javax.persistence.*;import java.util.Date;@Getter@Setter@ToString@Entitypublic class Board {    @Id @GeneratedValue    private Long seq;    private String title;    private String writer;    private String content;    @Temporal(TemporalType.DATE)    private Date createDate;    private Long cnt;}JPA 설정Hibernate를 사용하여 JPA를 구현해보도록 하겠습니다. 빌드는 gradle을 사용하며, Oracle DB에 연결하겠습니다.의존성(dependency) 설정gradle에 의존성 패키지로 hibernate-entitymanager를 추가합니다.implementation 'org.hibernate:hibernate-entitymanager'Entity 작성을 편하게 하기 위해 Lombok 패키지도 의존성에 추가하고, 암호키로 오라클DB에 접근하기 위해 ojdbc와 security 패키지도 추가합니다.compileOnly 'org.projectlombok:lombok'annotationProcessor 'org.projectlombok:lombok'runtimeOnly 'com.oracle.database.jdbc:ojdbc8'implementation 'com.oracle.database.security:oraclepki'implementation 'com.oracle.database.security:osdt_core'implementation 'com.oracle.database.security:osdt_cert'전체 코드입니다.build.gradleplugins {    id 'org.springframework.boot' version '2.7.2'    id 'io.spring.dependency-management' version '1.0.12.RELEASE'    id 'java'}group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {    compileOnly {        extendsFrom annotationProcessor    }}repositories {    mavenCentral()}dependencies {    implementation 'org.springframework.boot:spring-boot-starter'    testImplementation 'org.springframework.boot:spring-boot-starter-test'    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.projectlombok:lombok'    implementation 'org.hibernate:hibernate-entitymanager'    runtimeOnly 'com.oracle.database.jdbc:ojdbc8'    implementation 'com.oracle.database.security:oraclepki'    implementation 'com.oracle.database.security:osdt_core'    implementation 'com.oracle.database.security:osdt_cert'}tasks.named('test') {    useJUnitPlatform()}영속성 컨텍스트(Persistence Context) 설정영속성(Persistence)이란 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 말합니다. 영속성이 없는 데이터는 메모리에서만 존재하기 때문에 프로그램을 종료하면 사라져 버립니다. 데이터가 영속성을 가지기 위해서는 파일 시스템이나 데이터베이스 등을 통해 영속성을 부여해야만 합니다.JPA는 영속성이 없는 데이터에 영속성을 부여하는 역할을 하며, 이렇게 영속성이 부여되는 환경을 영속성 컨텍스트(Persistence Context)라고 합니다. 프로그램이 종료되기 전까지 Entity가 영구적으로 저장되는 환경입니다.영속성 컨텍스트는 기본적으로는 persistence.xml 파일을 통해 설정됩니다./resources/META-INF/persistence.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" version=\"2.1\"&gt;    &lt;persistence-unit name=\"practice\"&gt;        &lt;class&gt;com.example.demo.Board&lt;/class&gt;        &lt;properties&gt;            &lt;property name=\"javax.persistence.jdbc.driver\" value=\"oracle.jdbc.OracleDriver\"/&gt;            &lt;property name=\"javax.persistence.jdbc.user\" value=\"아이디\"/&gt;            &lt;property name=\"javax.persistence.jdbc.password\" value=\"암호\"/&gt;            &lt;property name=\"javax.persistence.jdbc.url\" value=\"주소\"/&gt;            &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.Oracle12cDialect\"/&gt;            &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt;            &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt;            &lt;property name=\"hibernate.use_sql_comments\" value=\"false\"/&gt;            &lt;property name=\"hibernate.id.new_generator_mappings\" value=\"false\"/&gt;            &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\"/&gt;        &lt;/properties&gt;    &lt;/persistence-unit&gt;&lt;/persistence&gt;영속성 유닛(persistence-unit) 설정persistence.xml 파일의 루트는 &lt;persistence&gt;이며, 영속성 유닛인 &lt;persistence-unit&gt;을 엘리먼트로 가집니다.영속성 유닛은 데이터베이스당 하나씩 설정할 수 있습니다. 즉, 데이터베이스가 하나 이상이면 영속성 유닛 또한 여러 개 이므로 이를 구분하기 위해 유일한 이름(name)을 지정해야 합니다. 위의 코드에서는 practice라는 이름으로 영속성 유닛을 하나 생성합니다.영속성 유닛은 EntityManagerFactory를 생성할 수 있습니다. JPA를 사용하려면 EntityManager 객체가 필요한데, EntityManager는 EntityManagerFactory로부터 생성됩니다. 생성 비용이 크기때문에 싱글톤으로 만들어 사용하며, Thread-safe 입니다.EntityManager는 CRUD를 처리합니다. Thread-unsafe 이기 때문에 Thread 환경에서는 주의해야 합니다. 각각 영속성 컨텍스트를 가지고 있으며, 데이터를 변경하려면 트랜잭션(transaction)이 이루어져야 합니다.EntityManager 생성EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");EntityManager em = emf.createEntityManager();Entity 클래스 등록Entity 클래스 목록은 영속성 유닛 설정에서 가장 먼저 등록되는 정보입니다. 순수 JPA만 사용한다면 Entity 클래스를 영속성 유닛에 명시적으로 등록해야만 합니다. Entity 작성은 아래 Entity 매핑 설정항목을 참조하세요.프로퍼티(property) 설정이제 각종 프로퍼티를 설정해줍니다.우선 데이터소스(Datasource)를 설정합니다. JPA 구현체는 데이터소스를 참조하여 특정 데이터베이스와 연결할 수 있습니다. 데이터소스의 설정은 프로퍼티 이름만으로 어느정도 의미를 알 수 있습니다.데이터 소스(Datasource) 프로퍼티            프로퍼티      의미                  javax.persistence.jdbc.driver      JDBC 드라이버              javax.persistence.jdbc.user      DB 아이디              javax.persistence.jdbc.password      DB 암호              javax.persistence.jdbc.url      DB 주소      다음으로 Dialect를 설정합니다. Dialect는 번역하면 방언 입니다. JPA의 큰 장점 중 하나가 SQL을 자동으로 생성한다는 점인데 데이터베이스마다 SQL이 조금씩 차이가 있습니다. 그러므로 Dialect를 설정하여 특정 데이터베이스에 최적화된 SQL이 생성되도록 합니다.hibernate-core 패키지에는 대부분의 데이터베이스에 해당하는 Dialect가 포함되어 있습니다.            데이터베이스      Dialect                  DB2      org.hibernate.dialect.DB2Dialect              PostgreSQL      org.hibernate.dialect.PostgreDialect              MySQL      org.hibernate.dialect.MySQLDialect              Oracle      org.hibernate.dialect.OracleDialect              Sybase      org.hibernate.dialect.SybaseDialect              Microsoft SQL Server      org.hibernate.dialect.SQLServerDialect              SAP DB      org.hibernate.dialect.SAPDBDialect              H2      org.hibernate.dialect.H2Dialect      Hibernate에서 지원하는 Dialect의 종류는 공식문서를 참조하세요.마지막으로 JPA 구현체를 설정하겠습니다. Hibernate를 사용할 것이므로 이에 대한 프로퍼티를 설정하면 됩니다.            프로퍼티      의미                  hibernate.show_sql      하이버네이트에서 생성한 SQL을 콘솔에 출력              hibernate.format_sql      SQL을 출력할 때 특정 포맷으로 출력              hibernate.use_sql_comments      SQL에 포함된 주석을 포함하여 출력              hibernate.id.new_generator_mapping      키(key) 생성전략 사용 여부              hibernate.hbm2ddl.auto      DDL 자동 실행 여부      여기에서 hibernate.hbm2ddl.auto는 SessionFactory가 생성될 때 실행될 DDL을 정의합니다.            옵션      의미                  create      기존 테이블을 삭제하고 다시 생성 (DROP + CREATE)              create-drop      SessionFactory가 종료되면 테이블을 삭제              update      변경된 부분에만 UPDATE 적용              validate      Entity와 테이블이 정상적으로 매핑되었는지 확인              none      (default) 아무것도 하지 않음      주의할 점은 개발 단계나 테스트 단계에서만 사용하며, 운영서버에서는 validate나 none으로 설정해야 합니다.Entity 매핑 설정JPA는 어노테이션(annotation)만 적절히 설정한다면 Entity를 통해 데이터를 쉽게 관리할 수 있습니다.Board.javaimport lombok.*;import javax.persistence.*;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import java.util.Date;@Getter@Entity@Builder@AllArgsConstructor@NoArgsConstructor(access = AccessLevel.PROTECTED)@DynamicInsert@DynamicUpdatepublic class Board {        @Id @GeneratedValue    private Long seq;    @Setter    @Column(nullable = false)    private String title;    @Column(length = 40, nullable = false)    private String writer;    @Setter    @Column(columnDefinition = \"varchar(100) default 'No Contents'\")    private String content;    @Temporal(TemporalType.DATE)    @Column(updatable = false)    private Date createDate;    @ColumnDefault(\"0\")    private Long cnt;    @PrePersist    protected void onCreate() {        createDate = new Date();    }}@Entity클래스를 JPA가 관리하는 Entity로 인식하도록 합니다.@DynamicInsertnull이 아닌 필드만 사용하여 동적인 INSERT Query를 생성합니다.@DynamicUpdate변경된 필드만 사용하여 동적인 UPDATE Query를 생성합니다.@Id다른 객체와 식별할 수 있는 고유값을 가지는 필드로, 테이블의 기본키(Primary key)와 매핑됩니다.@GeneratedValue식별자값을 자동으로 증가시키며, 다음과 같은 속성을 줄 수 있습니다.@GeneratedValue            속성      설명                  strategy      기본키 자동 생성 전략 선택              generator      이미 생성된 키 생성기 참조      기본키를 생성하는 전략은 다음과 같습니다.기본키 생성 전략            strategy      설명                  GenerationType.TABLE      테이블을 사용하여 기본키 생성 (기본키를 생성하는 별도의 테이블 필요)              GenerationType.SEQUENCE      시퀀스를 이용하여 기본키 생성 (시퀀스를 지원하는 DB에서 사용 가능)              GenerationType.IDENTITY      auto_increment 또는 IDENTITY를 이용하여 기본키 생성              GenerationType.AUTO      (기본값) Hibernate가 DB에 맞는 전략을 자동으로 선택      @TableEntity를 테이블과 매핑할 때 사용하며, 다음과 같은 속성을 줄 수 있습니다.@Table            속성      설명                  name      테이블 이름 지정              catalog      DB 카탈로그 지정              schema      DB 스키마 지정              uniqueConstraints      결합 unique 제약조건을 지정      @ColumnEntity 필드와 테이블 column을 매핑할 때 사용하며, 다음과 같은 속성을 줄 수 있습니다.@Column            속성      설명                  name      column 이름 지정 (생략시 프로퍼티명과 동일)              unique      제약조건 추가 (기본값: false)              nullable      null 허용 여부 (기본값: true)              insertable      INSERT 가능 여부 (기본값: true)              updatable      UPDATE 가능 여부 (기본값: true)              columnDefinition      column에 대한 DDL을 직접 기술              length      문자열 타입 column 길이 지정 (기본값: 255)              precision      숫자 타입의 자리수 지정 (기본값: 0)              scale      숫자 타입의 소수점 자리수 지정 (기본값: 0)      @ColumnDefault스키마 생성시 필드의 기본값을 설정합니다.@TransientEntity 필드를 매핑에서 제외할 때 사용합니다.@Temporaljava.util.Date 타입의 날짜 데이터를 매핑할 때 사용하며, 다음과 같은 값을 가집니다.@Temporal            값      설명                  TemporalType.DATE      날짜만 출력              TemporalType.TIME      시간만 출력              TemporalType.STAMP      날짜와 시간 모두 출력      @PrePersistEntity가 persist 되기 전에 호출됩니다.@PreUpdateEntity가 update 되기 전에 호출됩니다.JPA 이해JPA를 이용하여 CRUD 프로그램을 구현하기에 앞서 영속성 컨텍스트와 Entity의 생명주기(Lifecycle)에 대해 알아보도록 하겠습니다.영속성 컨텍스트(Persistence Context)영속성 유닛을 설정할 때 잠깐 언급했지만 영속성 컨텍스트는 데이터가 영속성을 부여받는 환경을 말합니다. 영속성을 부여받았다고 해서 완전히 사라지지 않는 것은 의미하지는 않습니다. 앞서 말했지만 영속성 컨텍스트에 저장된 데이터는 프로그램이 종료되면 컨텍스트와 함께 메모리에서 사라져 버립니다.영속성 컨텍스트는 EntityManager가 가지고 있습니다. EntityManager는 영속성 컨텍스트를 통해 CRUD를 수행할 수 있습니다.영속성 컨텍스트는 크게 1차 캐시 저장소와 SQL 저장소로 구분됩니다.1차 캐시 저장소에는 Entity 정보를 저장합니다. 이 상태를 영속 상태라고 합니다.SQL 저장소에는 SQL Query를 저장합니다. 저장된 쿼리는 EntityManager의 flush() 메소드에 의하여 DB에 반영됩니다.Entity 생명주기(Lifecycle)Entity는 EntityManager가 제공하는 메소드를 통해 관리되며, 다음과 같이 4가지 상태로 존재합니다.비영속 상태(New)비영속 상태는 Entity 객체만 생성하고 아직 Entity를 영속성 컨텍스트에 저장하지 않은 상태입니다.비영속 상태Board board = Board.builder()    .title(\"테이블 제목\")    .writer(\"Rubisco\")    .content(\"첫번째 글입니다.\")    .build();영속 상태(Managed)영속 상태는 Entity 객체가 영속성 컨텍스트에 저장된 상태입니다. Id를 키(key)로 하여 Entity가 1차 캐시 저장소에 저장됨과 동시에 SQL 저장소에는 INSERT Query가 저장됩니다.이 상태에서는 Entity를 영속성 컨텍스트가 관리하는 상태이므로 객체의 상태변경을 자동으로 감지합니다. 이것을 Dirty Checking이라고 합니다.영속 상태가 되기 위해서는 EntityManager의 persist() 메소드를 사용합니다.EntityManager.persist()EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");EntityManager em = emf.createEntityManager();em.persist(board);persist() 메소드를 통해 Entity가 영속화 되어도 flush() 메소드가 호출되기 전까지는 DB에 쿼리가 전달되지 않고 SQL 저장소에 쌓입니다.EntityManager의 flush() 메소드가 호출되면 SQL 저장소의 모든 쿼리가 DB에 반영됩니다. flush를 하더라도 Entity는 영속성 컨텍스트에 계속 저장되어 있습니다. 단지 영속성 컨텍스트와 DB를 동기화(Synchronize)할 뿐입니다.EntityManager의 find() 메소드를 통해서도 DB의 데이터를 통해 Entity 객체를 만들어 영속성 컨텍스트에 저장함으로써 영속 상태가 될 수 있습니다.EntityManager.find()em.find(Board.class, 2L);만약 같은 Entity를 조회한다면 JPA는 1차 캐시 저장소에 있는 Entity를 반환하게 되므로 성능상 큰 이점을 얻을 수 있습니다.아래 코드를 실행시켜보면 영속화된 board 객체와 find()로 호출한 findBoard 객체는 동일한 객체라는 것을 확인할 수 있습니다.JPAClient.javaimport javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JPAClient {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");        EntityManager em = emf.createEntityManager();        EntityTransaction tx = em.getTransaction();        try {            tx.begin();            Board board = Board.builder()                .title(\"테이블 제목\")                .writer(\"Rubisco\")                .content(\"첫번째 글입니다.\")                .build();                        em.persist(board);            tx.flush();            Board findBoard = em.find(Board.class, 1L);            System.out.println(\"동일성 여부 : \" + (board == findBoard)); // true 출력                    } catch (Exception e) {            e.printStackTrace();            tx.rollback();        } finally {            em.close();            emf.close();        }    }}준영속 상태(Detatched)EntityManager의 detach() 메소드 또는 clear(), close() 메소드가 호출된 경우 Entity는 준영속 상태가 됩니다.detach() 메소드는 특정 Entity를 준영속 상태로 전환합니다.EntityManager.detach()em.detach(board);clear() 메소드는 영속성 컨텍스트 안의 모든 Entity를 준영속 상태로 만듭니다.close() 메소드는 EntityManager를 닫아 영속성 컨텍스트를 종료하고 영속성 컨텍스트 안의 모든 Entity를 준영속 상태로 만듭니다.준영속 상태가 된 Entity는 EntityManager의 관리를 벗어나기 때문에 Dirty Checking을 하지 않습니다. 하지만 완전히 메모리에서 사라진 것은 아니기 때문에 EntityManager의 merge() 메소드를 통해 다시 영속상태로 전환될 수 있습니다.EntityManager.merge()em.merge(board);여기에서 중요한 것은 board 객체 자체가 다시 영속상태가 되는 것이 아니라는 것입니다. merge라는 말처럼 새로운 Entity에 board 객체의 모든 필드를 합병하고 새로운 객체를 1차 캐시 저장소에 저장합니다. 즉, merge는 UPDATE 기능을 수행합니다.EntityManager로부터 merge 메소드가 호출되면 우선 DB에서 Id 필드와 같은 동일한 기본키를 조회합니다. 동일한 기본키가 없다면 새로운 Entity에 board Entity를 합병하고 합병된 Entity를 반환합니다. 이때 SQL 저장소에는 INSERT Query가 저장됩니다.동일한 기본키가 있다면 해당 Entity를 영속화하여 board Entity를 합병합니다. 이때 SQL 저장소에는 UPDATE Query가 저장됩니다.실제 아래 코드를 통해 1차 캐시 저장소에 저장된 객체는 board가 아닌 mergedBoard라는 것을 확인할 수 있습니다.JPAClient.javaimport javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JPAClient {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");        EntityManager em = emf.createEntityManager();        EntityTransaction tx = em.getTransaction();        try {            tx.begin();            Board board = Board.builder()                .title(\"테이블 제목\")                .writer(\"Rubisco\")                .content(\"첫번째 글입니다.\")                .build();                        Board mergedBoard = em.merge(board);            em.flush();            Board findBoard = em.find(Board.class, 1L);            System.out.println(\"동일성 여부 : \" + (findBoard == mergedBoard)); // true 출력                    } catch (Exception e) {            e.printStackTrace();            tx.rollback();        } finally {            em.close();            emf.close();        }    }}사실 1차 캐시 저장소에는 entity 자체가 저장되는 것이 아니라 Entity의 Reference와 Snapsot을 저장하고 있습니다.flush가 호출되고 실행되기 전에 EntityManager는 실제 Entity와 Snapshot을 비교하여 변경을 감지할 수 있습니다. 내용이 변경되었다면 UPDATE Query를 생성하여 DB를 update 할 수 있습니다.주의할 것은 Entity의 모든 필드가 교체되므로 값이 null이 될 가능성이 있다는 것을 숙지해야합니다.JPAClient.javaimport javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JPAClient {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");        EntityManager em = emf.createEntityManager();        EntityTransaction tx = em.getTransaction();        try {            tx.begin();            Board board = Board.builder()                .title(\"테이블 제목\")                .writer(\"Rubisco\")                .content(\"첫번째 글입니다.\")                .build();                        em.persist(board);            em.flush();            em.detach(board);            em.merge(board); // board의 cnt는 null이므로 cnt가 null로 갱신            em.flush();        } catch (Exception e) {            e.printStackTrace();            tx.rollback();        } finally {            em.close();            emf.close();        }    }}위에 코드를 실행하고 DB를 확인하면 cnt 값이 null이라는 것을 확인할 수 있습니다.삭제 상태(Removed)EntityManger의 remove() 메소드로 Entity를 삭제하면 해당 Entity는 영속성 컨텍스트에서 제외되고 DELETE Query가 SQL 저장소에 저장됩니다.EntityManager.remove()Board removeBoard = em.find(Board.class, 2L);em.remove(removeBoard);JPQL(Java Persistence Query Language)특정 데이터의 조회는 EntityManager의 find() 메소드를 사용하면 되지만, 목록을 조회하려면 JPQL 이라는 JPA에서 제공하는 별도의 쿼리 명령어를 사용해야 합니다. SQL문과 유사한 문법을 사용하므로 해석에는 특별한 어려움이 없지만 중요한 것은 검색 대상이 테이블이 아니라 Entity라는 점입니다.import java.util.List;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JPAClient {    public static void main(String[] args) {        EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"practice\");        EntityManager em = emf.createEntityManager();        EntityTransaction tx = em.getTransaction();        try {            tx.begin();            for(int i = 0; i &lt; 10; i++) {                Board board = Board.builder()                .title(\"테이블 제목\" + i)                .writer(\"Rubisco\")                .content(i + \"번째 글입니다.\")                .build();                            em.persist(board);            }                        tx.commit();            String jpql = \"select b from Board b order by b.seq desc\";            List&lt;Board&gt; BoardList = em.createQuery(jpql, Board.class).getResultList();            for(Board brd : BoardList) {                System.out.println(\"---&gt; \" + brd.getTitle());            }        } catch (Exception e) {            e.printStackTrace();            tx.rollback();        } finally {            em.close();            emf.close();        }    }}Spring Data JPASpring Data JPA는 JPA를 쉽게 사용하기 위해 Spring에서 제공하는 프레임워크 이며, JPA의 인터페이스 입니다. JPA는 아니지만 보통 JPA라고 하면 Spring Data JPA를 뜻합니다.Spring Data JPA, Spring Data MongoDB, Spring Data Redis등 Spring Data의 하위 프로젝트들은 동일한 인터페이스를 가지고 있어서 Repository를 교체해도 기본적인 기능이 변하지 않습니다.프로젝트 생성빌드 도구를 Gradle로 하여 프로젝트를 만들겠습니다. 의존성 패키지로 spring-boot-starter-data-jpa를 추가합니다.implementation 'org.springframework.boot:spring-boot-starter-data-jpa'전체 코드는 다음과 같습니다.build.gradleplugins {    id 'org.springframework.boot' version '2.7.2'    id 'io.spring.dependency-management' version '1.0.12.RELEASE'    id 'java'}group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = '17'configurations {    compileOnly {        extendsFrom annotationProcessor    }}repositories {    mavenCentral()}dependencies {    implementation 'org.springframework.boot:spring-boot-starter'    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'    testImplementation 'org.springframework.boot:spring-boot-starter-test'    testImplementation 'junit:junit'    compileOnly 'org.projectlombok:lombok'    annotationProcessor 'org.projectlombok:lombok'    // 오라클DB 접근    runtimeOnly 'com.oracle.database.jdbc:ojdbc8'    implementation 'com.oracle.database.security:oraclepki'    implementation 'com.oracle.database.security:osdt_core'    implementation 'com.oracle.database.security:osdt_cert'    }tasks.named('test') {    useJUnitPlatform()}프로퍼티 설정스프링 데이터 JPA는 persistence.xml 파일에 작성한 설정과 동일하게 application.properties 파일을 작성하면 됩니다. 아래와 같이 작성합시다.# DataSource Settingspring.datasource.driver-class-name=oracle.jdbc.OracleDriverspring.datasource.url=DB 주소spring.datasource.username=DB 아이디spring.datasource.password=DB 암호# JPA Settingspring.jpa.hibernate.ddl-auto=createspring.jpa.hibernate.use-new-id-generator-mappings=falsespring.jpa.generate-ddl=falsespring.jpa.show-sql=truespring.jpa.database=oraclespring.jpa.database-platform=org.hibernate.dialect.OracleDialectspring.jpa.properties.hibernate.format_sql=truespring.jpa.properties.hibernate.use_sql_comments=false# Logging Settinglogging.level.org.hibernate=infoEntity 설정Entity 매핑을 설정합니다. 위에 작성한 Board 클래스와 동일합니다.Board.javaimport lombok.*;import javax.persistence.*;import org.hibernate.annotations.ColumnDefault;import org.hibernate.annotations.DynamicInsert;import org.hibernate.annotations.DynamicUpdate;import java.util.Date;@Getter@ToString@Entity@Builder@AllArgsConstructor@NoArgsConstructor(access = AccessLevel.PROTECTED)@DynamicInsert@DynamicUpdatepublic class Board {        @Id @GeneratedValue    private Long seq;    @Setter    @Column(nullable = false)    private String title;    @Column(length = 40, nullable = false)    private String writer;    @Setter    @Column(columnDefinition = \"varchar(100) default 'No Contents'\")    private String content;    @Temporal(TemporalType.DATE)    @Column(updatable = false)    private Date createDate;    @ColumnDefault(\"0\")    private Long cnt;    @PrePersist    protected void onCreate() {        createDate = new Date();    }}spring.jpa.hibernate.ddl-auto 속성값을 create로 설정했기 때문에 Entity를 기준으로 테이블이 자동생성됩니다. 메인 클래스를 하나 만들어 다음과 같은 코드를 작성해주세요.SpringDataJpaApplication.javaimport org.springframework.boot.SpringApplication;import org.springframework.boot.WebApplicationType;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringDataJpaApplication {    public static void main(String[] args) {        SpringApplication application = new SpringApplication(SpringDataJpaApplication.class);        application.setWebApplicationType(WebApplicationType.NONE);        application.run(args);    }}WebApplicationType을 NONE으로 설정하여 내장 톰캣을 껐습니다. 메인 클래스를 실행하면 다음과 같은 내용이 콘솔창에 출력됩니다.Hibernate:         drop table board cascade constraintsHibernate:         drop sequence hibernate_sequenceHibernate: create sequence hibernate_sequence start with 1 increment by 1Hibernate:         create table board (       seq number(19,0) not null,        cnt number(19,0) default 0,        content varchar(100) default 'No Contents',        create_date date,        title varchar2(255) not null,        writer varchar2(40) not null,        primary key (seq)    )시퀀스와 테이블이 자동으로 생성되었으며, createData 필드가 스네이크 표기법으로 바뀌었습니다. (create_data)ddl-auto가 create 이므로 테이블이 삭제되고 다시 생성됨을 확인할 수 있습니다.Repository 인터페이스 작성Entity의 CRUD 기능을 처리하기 위한 Repository 인터페이스를 작성하겠습니다. Repository는 위에서 설명했듯이 기존 DAO와 동일한 개념으로, 비즈니스 로직층에서는 Repository를 통해 DB 연동을 처리합니다. 스프링에서 제공하는 Repository 중 하나를 상속하여 작성하면 됩니다.일반적으로 CrudRepository를 사용하며, 이름에서 알 수 있듯이 CRUD 기능을 제공합니다.만약 검색 기능이 필요하고 페이징 처리를 하고자 한다면 PagingAndSortingRepository를 사용하고, Spring Data JPA에서 추가한 기능을 사용하고 싶으면 JpaRepository를 사용하면 됩니다.CrudRepository는 다음과 같이 T, ID 2개의 제네릭 타입을 지정해야 합니다.CrudRepository&lt;T, ID&gt;T는 Entity 클래스, ID는 식별자(Id)의 타입을 지정합니다.BoardRepository.javaimport org.springframework.data.repository.CrudRepository;public interface BoardRepository extends CrudRepository&lt;Board, Long&gt; {    }CRUD 기능 테스트CrudRepository 인터페이스가 제공하는 메소드는 다음과 같습니다.            메소드      반환형      기능                  count()      long      모든 Entity 개수 리턴              delete(ID)      void      식별키 삭제              delete(Iterable&lt;?Extends T&gt;)      void      주어진 모든 Entity 삭제              deleteAll()      void      모든 Entity 삭제              exists(ID)      boolean      식별키를 가진 Entity 존재 확인              findAllById(ID)      Iterable&lt;T&gt;      모든 Entity 목록 리턴              findAll(Iterable&lt;ID&gt;)      Iterable&lt;T&gt;      해당 식별키를 가진 Entity 목록 리턴              findById(ID)      Optional&lt;T&gt;      해당 식별키에 해당하는 Entity 리턴              saveAll&lt;Iterable&gt;      &lt;S extends T&gt;Iterable&lt;S&gt;      여러 Entity들을 한 번에 등록, 수정              save&lt;S entity&gt;      &lt;S extends T&gt;S      하나의 Entity를 등록, 수정      CRUD 기능 테스트를 하기 전에 application.properties에서 spring.jpa.hibernate.ddl-auto를 update로 바꿔주세요.spring.jpa.hibernate.ddl-auto=update등록(Create)src/test/java 폴더에 Junit 기반의 BoardRepositoryTest라는 테스트 케이스를 작성합니다.BoardRepositoryTest.javaimport org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class BoardRepositoryTest {    @Autowired    private BoardRepository boardRepo;    @Test    public void testInsertBoard() {        Board board = Board.builder()                        .title(\"테이블 제목\")                        .writer(\"Rubisco\")                        .content(\"첫번째 글입니다.\")                        .build();                boardRepo.save(board);    }}JPA에서는 persist() 메소드로 INSERT를 했지만, CrudRepository 인터페이스는 save() 메소드를 통해 INSERT를 합니다.Hibernate:     select        hibernate_sequence.nextval     from        dualHibernate:     insert     into        board        (content, create_date, title, writer, seq) 시퀀스를 하나 증가시킨 후 INSERT 쿼리가 실행됨을 확인할 수 있습니다.조회(Read)조회 기능을 테스트 하기 위해 testGetBoard라는 메소드를 작성합니다.BoardRepositoryTest.java@Testpublic void testGetBoard() {    Board board = boardRepo.findById(1L).get();    System.out.println(board.toString());}데이터 하나를 조회하기 위해서는 findById() 메소드를 사용합니다. 그러면 Optional 타입의 객체가 리턴되며, get() 메소드를 통해 영속성 컨텍스트에 저장된 Board 객체를 받을 수 있습니다.Hibernate:     select        board0_.seq as seq1_0_0_,        board0_.cnt as cnt2_0_0_,        board0_.content as content3_0_0_,        board0_.create_date as create_d4_0_0_,        board0_.title as title5_0_0_,        board0_.writer as writer6_0_0_     from        board board0_     where        board0_.seq=?Board(seq=1, title=제목 수정, writer=Rubisco, content=첫번째 글입니다., createDate=2022-08-08, cnt=0)테스트 케이스를 실행하면 SELECT 쿼리가 실행되고, 터미널에 seq=1인 Entity의 속성이 출력되는 것을 확인할 수 있습니다.수정(Update)수정 기능을 테스트 하기 위해 testUpdateBoard 라는 메소드를 작성합니다.BoardRepositoryTest.java@Testpublic void testUpdateBoard() {    Board board = boardRepo.findById(1L).get();    board.setTitle(\"제목 수정\");    boardRepo.save(board);}JPA에서는 merge() 메소드를 사용했지만, CrudRepository는 INSERT 할때와 동일하게 save() 메소드를 사용합니다.Hibernate:     select        board0_.seq as seq1_0_0_,        board0_.cnt as cnt2_0_0_,        board0_.content as content3_0_0_,        board0_.create_date as create_d4_0_0_,        board0_.title as title5_0_0_,        board0_.writer as writer6_0_0_     from        board board0_ where        board0_.seq=?Hibernate:     select        board0_.seq as seq1_0_0_,        board0_.cnt as cnt2_0_0_,        board0_.content as content3_0_0_,        board0_.create_date as create_d4_0_0_,        board0_.title as title5_0_0_,        board0_.writer as writer6_0_0_     from        board board0_     where        board0_.seq=?Hibernate:     update        board     set        title=?     where        seq=?수정할 Entity를 영속성 컨텍스트에 저장하기 위해 처음 SELECT 구문을 실행했으며, 수정하기 직전 다시 한번 수정할 Entity를 영속성 컨텍스트에 저장하고 수정 작업이 이루어지기 때문에 2번의 SELECT와 1번의 UPDATE 쿼리가 실행되었음을 확인할 수 있습니다.삭제(Delete)삭제 기능을 테스트 하기 위해 testDeleteBoard 라는 메소드를 작성합니다.BoardRepositoryTest.java@Testpublic void testDeleteBoard() {    boardRepo.deleteById(1L);}단 한줄입니다.. JPA도 구문이 간단하다고 느꼈는데 Spring Data JPA는 더욱 단순화 되고 직관적입니다.Hibernate:     select        board0_.seq as seq1_0_0_,        board0_.cnt as cnt2_0_0_,        board0_.content as content3_0_0_,        board0_.create_date as create_d4_0_0_,        board0_.title as title5_0_0_,        board0_.writer as writer6_0_0_     from        board board0_     where        board0_.seq=?Hibernate:     delete     from        board     where        seq=?수정과 마찬가지로 SELECT 쿼리를 통해 Entity를 영속성 컨텍스트에 저장한 후 DELETE 쿼리가 실행됨을 확인할 수 있습니다.Hibernate로 CRUD를 만들때는 EntityManagerFactory를 짓고 EntityManager를 생성하여 EntityManager를 통해 Entity의 CRUD를 처리했습니다.반면 Spring Data JPA로 CRUD를 만들때는 EntityManager가 등장하지 않았습니다. EntityManager는 Repository에 포함되어있어 직접 작성하지 않아도 내부에서 자동적으로 호출되는 모양새 입니다.아직 완전히 이해하진 못했지만 Spring Data JPA를 사용하면 효율적인 개발이 될 것임은 확실해 보입니다.",
        "url": "/java/jpa"
    }
    ,
    
    "design-pattern-mvc-pattern": {
        "title": "MVC 패턴",
            "author": "rubisco",
            "category": "",
            "content": "MVC 패턴이란?MVC 패턴(Model-View-Controller Pattern)은 어플리케이션을 개발함에 있어서 컴포넌트를 모델(Model), 뷰(View), 컨트롤러(Controller)로 역할을 나누어 개발하는 디자인 패턴 즉, 설계 방식을 말합니다.클라이언트(Client)가 뷰를 통해 컨트롤러에게 요청(Request)를 보내면 해당 요청을 컨트롤러가 받고, 컨트롤러는 모델을 통해 데이터를 가져와서 뷰를 제어합니다.모델(Model)모델은 애플리케이션의 데이터를 책임지는 컴포넌트 입니다. 내부 비즈니스 로직을 처리하는 역할을 하며, 다음과 같은 규칙을 가집니다.사용자(Client)가 편집하길 원하는 모든 데이터를 가지고 있어야한다.사용자가 게시판의 글을 수정하길 원한다면 모델은 제목, 내용, 작성자 등을 포함한 게시글에 대한 모든 데이터를 가지고 있어야 합니다.뷰나 컨트롤러에 대한 어떤 정보도 알지 못한다.모델은 자기 자신이 수행하는 일에 대한 정보만 알고 있어야 하며, 이를 넘어서는 작업을 해서는 안됩니다. 예를 들어 게시글 내용을 변경하는 역할을 하는 모델이 뷰의 정보를 가지고 게시글 색상을 변경하는 등의 작업을 해서는 안됩니다.변경이 일어나면 통지에 대한 처리방법을 구현해야 한다.모델의 데이터가 변경된다면 이를 컨트롤러에게 알리기 위한 처리 방법을 구현해야 하며, 재사용이 가능해야 합니다. 그렇기 때문에 MCV 패턴은 옵저버(Observer) 패턴과 많은 연관점이 있습니다. 하나의 모델에 대하여 다수의 뷰가 모델을 구독(Subscribe)하는 형태입니다.뷰(View)뷰는 사용자 인터페이스(User Interface, UI)를 책임지는 컴포넌트 입니다. 모델이 가지고 있는 데이터를 기반으로 사용자에게 화면을 출력해주는 역할을 하며, 다음과 같은 규칙을 가집니다.모델이 가지고 있는 정보를 저장해서는 안된다.데이터 출력을 위해서는 필연적으로 모델의 정보를 전달받게 되는데, 이때 알게 된 모델의 정보를 따로 저장해서는 안됩니다.모델이나 컨트롤러에 대한 어떤 정보도 알지 못한다.모델과 마찬가지로 뷰 역시 자기 자신이 수행하는 일에 대한 정보만 알고 있어야 하며, 이를 넘어서는 작업을 해서는 안됩니다.변경이 일어나면 통지에 대한 처리방법을 구현해야 한다.모델과 같이 뷰에 변경이 있으면 통지할 수단이 필요합니다. 모델에서 설명했듯이 이는 보통 옵저버 패턴을 통해 구현됩니다.컨트롤러(Controller)컨트롤러는 뷰와 모델을 연결하여 실질적으로 사용자의 요청을 처리하는 컴포넌트 입니다. 사용자의 요청에 대하여 모델에게 데이터를 처리할 방법을 알려주며, 모델이 작업을 완료하면 그 결과를 뷰에 전달합니다. 컨트롤러는 다음과 같은 규칙을 가집니다.모델이나 뷰의 정보를 알고 있어야 한다.모델과 뷰는 서로 알지 못하기 때문에 컨트롤러를 통해 변경을 중재받습니다. 컨트롤러가 모델과 뷰를 중재하려면 모델과 뷰에 대한 정보를 가지고 있어야만 합니다.모델이나 뷰의 변경을 모니터링 해야 한다.위의 규칙과 마찬가지로 모델과 뷰는 서로 알지 못하기에 컨트롤러가 중재자(Mediator)가 되어 서로의 변경을 통지해야 합니다.옵저버 패턴(Observer Pattern)옵저버 패턴(Observer Pattern)은 객체의 상태를 관찰하는 옵저버를 통해 객체의 상태가 변하면 종속된 객체들에게 통지를 보내는 패턴입니다.MVC 패턴은 옵저버 패턴(Observer Pattern)과 많은 연관점이 있습니다. 하나의 모델에 대하여 다수의 뷰가 옵저버를 통해 모델을 구독하는 형태를 가지고 있으며, 이는 컨트롤러의 중재를 받습니다.소스 코드모델의 상태를 관찰하기 위한 옵저버 인터페이스 입니다. update 메소드를 통해 뷰가 변경됩니다.Observer.javapublic interface Observer {    void update(String title);}옵저버 인터페이스를 구현한 뷰 클래스 입니다. 아래 코드에서는 콘솔창을 통해 새로운 글의 등록을 알리도록 인터페이스를 구현했습니다.View.javapublic class View implements Observer {    private String name;    public View(String name) {        this.name = name;    }    @Override    public void update(String title) {        System.out.println(name + \" &gt; 새로운 글이 등록되었습니다 : \" + title);    }    }모델에 대한 인터페이스 입니다. notifyObservers 메소드를 통해 알림을 발행하며, registerObserver 메소드를 통해 뷰가 모델을 구독할 수 있습니다.Observable.javapublic interface Observable {    void registerObserver(Observer observer);    void removeObserver(Observer observer);    void notifyObservers(String title);}모델 클래스 입니다. Observable 인터페이스를 구현했으며, notifyObservers 메소드를 통해 모델을 구독하고 있는 뷰의 update 메소드를 호출합니다.Model.javaimport java.util.ArrayList;import java.util.List;public class Model implements Observable {    private final List&lt;Observer&gt; observers;    public Model() {        this.observers = new ArrayList&lt;&gt;();    }    @Override    public void notifyObservers(String title) {        for(Observer observer : observers) {            observer.update(title);        }    }    @Override    public void registerObserver(Observer observer) {        this.observers.add(observer);    }    @Override    public void removeObserver(Observer observer) {        this.observers.remove(observer);    }    }컨트롤러 클래스 입니다. 뷰와 모델은 컨트롤러에 의하여 통제됩니다. 아래 코드에서는 하드코딩을 통해 모델과 게시판1 이라는 뷰 객체를 생성하고, 1번째 글이라는 클라이언트의 요청을 모델에 전달했습니다.Controller.javapublic class Controller {    public static void main(String[] args) {                Observable model = new Model();        Observer view = new View(\"게시판1\");        model.registerObserver(view);        model.notifyObservers(\"1번째 글\");    }}디버깅해보면 아래와 같은 로그를 볼 수 있습니다.게시판1 &gt; 새로운 글이 등록되었습니다 : 1번째 글JAVA MVC 모델자바의 MVC 패턴에는 MVC1과 MVC2가 있습니다.MVC1 모델MVC1 모델은 JSP 페이지가 뷰(View)와 컨트롤러(Controller) 부분을 담당하고 Java Bean이 모델(Model)과 컨트롤러(Controller)를 담당하는 구조입니다.페이지의 흐름이 단순하기 때문에 개발이 간편하고 개발 속도가 빠릅니다.반면 모델(비즈니스 로직)과 뷰(프레젠테이션 로직) 사이의 구분이 모호하여 디자이너와의 협업이 힘들며, 어플리케이션이 복잡해질수록 유지보수가 힘듭니다.MVC2 모델MVC2 모델은 JSP 페이지가 뷰를 담당하고 Servlet은 컨트롤러, Java Bean은 모델을 담당하는 구조입니다.뷰와 모델의 구분이 명확하고, JSP 페이지의 코드가 간결해져 유지보수가 용이하고 디자이너와이 협업이 쉬워집니다.반면 로직이 복잡해져 구조 설계를 위한 시간이 많이 소모되어 개발 기간이 증가합니다.Spring MVCSpring MVC는 MVC2 모델의 발전된 형태의 구조입니다.FrontController인 DispatcherServlet이 클라이언트의 요청을 받고 HandlerMapping을 통해 Controller와 매핑되어 해당 컨트롤러를 실행합니다.컨트롤러는 Model과 View가 Wrapping된 객체를 반환하고, ViewResolver를 통해 View 객체를 처리한 후 클라이언트에게 해당 객체를 반환합니다.",
        "url": "/design-pattern/mvc-pattern"
    }
    ,
    
    "algorithm-combination-permutation": {
        "title": "조합과 순열",
            "author": "rubisco",
            "category": "",
            "content": "조합과 순열은 알고리즘 문제를 풀다보면 자주 만나는 문제 유형 입니다. 백트래킹, 분할정복 등 많은 알고리즘에 조합과 순열이 포함됩니다.조합은 서로 다른 n개의 원소를 가지는 집합에서 r개의 원소를 순서에 상관없이 선택하는 것을 의미하며, 순열은 서로 다른 n개의 원소를 가지는 집합에서 r개의 원소를 순서대로 선택하는 것을 의미합니다.이번 글에서는 조합과 순열에 대해 자세히 알아보고, 예제를 통해 코드를 작성해보도록 하겠습니다.팩토리얼(Factorial)서로 다른 n개를 나열하는 경우의 수를 팩토리얼이라고 하며. 기호로는 !로 나타냅니다.$$n! = n(n-1)(n-2) \\cdots 1$$자바스크립트 코드function factorial(n) {    return n &gt; 1 ? n * factorial(n-1) : 1;}조합(Combination)서로 다른 n개의 원소를 가지는 어떤 집합에서 r개의 원소를 순서에 상관없이 선택하는 것을 조합이라고 하며, 기호로는 $ _{n}\\mathrm{C}_{r} $로 나타냅니다.$$_{n}\\mathrm{C}_{r} = {n! \\over (n-r)!n!}$$중복조합중복 가능한 n개의 원소 중 r개의 원소를 순서에 상관없이 선택하는 것을 조합이라고 하며, 기호로는 $ _{n}\\mathrm{H}_{r} $로 나타냅니다.$$_{n}\\mathrm{H}_{r} = _{n+r-1}\\mathrm{C}_{r}$$문제  음이 아닌 정수 xx, yy, zz에 대해, $ x+y+z \\le 3 $를 만족시키는 순서쌍 (x,y,z)의 수는?풀이  주어진 식은 $ x + y + z = 3 - n (0 \\le n \\le 3) $ 으로 나타낼 수 있으며, 정수 x, y, z, n 에 대하여 $ x+y+z+n=3 $을 만족해야 합니다.  즉, 0 ~ 3 중 3개를 순서에 상관 없이 선택하는 중복조합에 해당합니다.  그러므로 $ _4\\mathrm{H}_3 = _6\\mathrm{C}_3 = {6! \\over 3!3!} = 20$ 이 됩니다.순열(Permutation)서로 다른 n개의 원소를 가지는 어떤 집합에서 r개의 원소를 순서대로 선택하는 것을 순열이라고 하며, 기호로는 $ _{n}\\mathrm{P}_{r} $로 나타냅니다.$$_{n}\\mathrm{P}_{r} = {n! \\over (n-r)!}$$중복순열중복 가능한 n개의 원소 중 r개의 원소를 순서대로 선택하는 것을 중복순열이라고 하며, 기호로는 $ _{n}\\mathrm{\\Pi}_{r} $로 나타냅니다.$$_{n}\\mathrm{\\Pi}_{r} = n^r$$소스 코드조합과 순열은 백트래킹을 통해 구현할 수 있습니다.swap을 통한 백트래킹배열의 첫번째 값을 순차적으로 바꿔 전체적으로 한번씩 swap 된 형태로 순열을 출력합니다. depth를 기준으로 인덱스가 depth보다 작으면 고정시키고, depth보다 크면 다시 swap을 진행합니다.자바스크립트 코드function permutation(arr, n = arr.length, r = n, depth = 0, output = []) {        if(depth === r) {        output.push(arr.slice());        return;    }    for(let i = depth; i &lt; n; i++) {        swap(arr, depth, i);        permutation(arr, n, r, depth + 1, output);        swap(arr, depth, i);    }    if (depth === 0) return output;    function swap(arr, depth, i) {        const temp = arr[depth];        arr[depth] = arr[i];        arr[i] = temp;    }}console.log(permutation([\"A\", \"B\", \"C\"]));// ------- 출력 --------// 0: (3) ['A', 'B', 'C']// 1: (3) ['A', 'C', 'B']// 2: (3) ['B', 'A', 'C']// 3: (3) ['B', 'C', 'A']// 4: (3) ['C', 'B', 'A']// 5: (3) ['C', 'A', 'B']swap을 한 후 함수를 depth가 r이 될때까지 재귀호출을 합니다. 값이 돌아오면 다시 swap을 하여 배열을 원래상태로 되돌립니다.이 방법은 별도의 공간을 필요로 하지 않기 때문에 공간복잡도는 작지만 순열의 순서를 보장하지는 않습니다. 위에 출력된 코드를 보면 4번째 출력은 C -&gt; A -&gt; B 가 출력되어야 하지만, C -&gt; B -&gt; A 가 먼저 출력됨을 볼 수 있습니다.visited 배열을 통한 백트래킹이 방법은 깊이우선탐색(DFS)를 통해 모든 인덱스를 방문합니다. 이때 visited 배열을 통해 중복값이 다시 들어가지 않도록 하면서 output 배열을 채워나갑니다.자바스크립트 코드function permutation(arr, n = arr.length, r = n, depth = 0, visited = [], output = [], result = []) {        if(depth === r) {        result.push(output.slice());        return;    }    for(let i = 0; i &lt; n; i++) {        if(!visited[i]) {            visited[i] = true;            output[depth] = arr[i];            permutation(arr, n, r, depth + 1, visited, output, result);            visited[i] = false;        }      }    if (depth === 0) return result;}console.log(permutation([\"A\", \"B\", \"C\"]));// ------- 출력 --------// 0: (3) ['A', 'B', 'C']// 1: (3) ['A', 'C', 'B']// 2: (3) ['B', 'A', 'C']// 3: (3) ['B', 'C', 'A']// 4: (3) ['C', 'A', 'B']// 5: (3) ['C', 'B', 'A']추가적인 공간을 필요로 하기에 공간 복잡도가 증가하지만 순열의 순서를 보장합니다.비트셋을 통한 조합아이템의 존재 유무는 1 또는 0으로 표현할 수 있으므로, n개의 비트를 통해 n개의 아이템에 대한 하나의 상태를 표현할 수 있습니다.자바스크립트 코드const items = [\"A\", \"B\", \"C\"];위에 작성한 아이템 배열의 경우, A = 1 « 0, B = 1 « 1, C = 1 « 2 로 나타낼 수 있습니다. 이는 각각 $ 2^0, 2^1, 2^2 $을 나타냅니다. 즉, $ 2^n $까지 순회하여 비트셋을 해석하면 r에 대한 모든 조합을 얻을 수 있습니다.function combination(arr, r = 0) {        const output = [];    const length = arr.length;    for(let i = 0; i &lt; 2**length; i++) {        const cur = [];        for (let j = 0; j &lt; length; j++) {            if (i &amp; (1 &lt;&lt; j)) cur.push(arr[j]);        }        if(!r || cur.length === r) output.push(cur);    }    return output;}관련 문제  프로그래머스(Programmers)          [12936] 줄 서는 방법      [49993] 스킬트리      [84512] 모음사전      ",
        "url": "/algorithm/combination_permutation"
    }
    ,
    
    "algorithm-gcd-lcm": {
        "title": "최대공약수와 최소공배수",
            "author": "rubisco",
            "category": "",
            "content": "최대공약수와 최소공배수최대공약수(GCD, Greateast Common Division)는 두 수에 대한 공약수의 최대값을 의미하며, 최소공배수(LCM, Least Common Multiple)는 두 수에 대한 공배수의 최소값을 의미합니다.최대공약수와 최소공배수는 소인수분해(Integer factorization)를 통해 구할 수 있습니다.최대공약수는 소인수의 교집합을 모두 곱한 값이고, 최소공배수는 소인수의 합집합을 모두 곱한 값입니다. 예를 들어 a = 12, b = 20 인 경우, a와 b의 최대공약수와 최소공배수는 다음과 같이 구할 수 있습니다.  a = 12 = 2 * 2 * 3b = 20 = 2 * 2 * 5a와 b의 소인수에 대한 교집합은 [2, 2]가 되고, 이를 모두 곱한 4가 최대공약수가 됩니다. 또한 a와 b의 소인수에 대한 합집합은 [2, 2, 3, 5]가 되고, 이를 모두 곱한 60이 최소공배수가 됩니다.최대공약수를 G, 최소공배수를 L이라고 한다면, 다음과 같은 식이 성립합니다.  a = 12 = G * Ab = 20 = G * B  A = a/GB = b/G  L = G * A * B = G * (a/G) * (b/G) = a*b/G이때 A와 B는 서로소가 됩니다.이를 자바스크립트 코드로 나타내면 다음과 같습니다.function GCD(a, b) {    let result = 1;    if(a &gt; b) [a, b] = [b, a];    let i = 2;        while(1) {        while(a%i === 0 &amp;&amp; b%i === 0) {            a /= i;            b /= i;            result *= i;        }        if(a === 1 || a === i++) return result;    }}function LCM(a, b) {    return a * b / GCD(a, b);}유클리드 호제법(Euclidean algorithm)  두 양의 정수 a, b (a &gt; b)에 대하여 a = bq + r (0 ≤ r &lt; b)이라 하면, a, b의 최대공약수는 b, r의 최대공약수와 같다.  즉, gcd(a, b) = gcd(b, r)이다.  r = 0이라면, a, b의 최대공약수는 b가 된다.유클리드 호제법(Euclidean algorithm)은 두 양의 정수, 혹은 두 다항식의 최대공약수를 구하는 방법입니다. 이 알고리즘은 유클리드의 원론에 적혀있는 내용으로, 인류 최초의 알고리즘이라 합니다.소인수 분해를 통해 최대공약수를 구하면 시간 복잡도가 O(N) 이지만, 유클리드 호제법으로 최대공약수를 구하면 시간 복잡도를 O(logN)으로 줄일 수 있습니다.증명gcd(a, b) = G, gcd(b, r) = G' 라고 가정 한다면, 서로소인 두 정수 A, B에 대하여 a = GA, b = GB가 성립합니다.이를 a = bq + r에 대입하면, GA = GBq + r 이므로 r = G(A - Bq)가 됩니다. 여기서 G는 b와 r의 공약수임을 확인할 수 있으며, 그러므로 G는 G'의 약수임을 알 수 있습니다.G' = mG라고 가정한다면, 서로소인 두 정수 k, l에 대하여 b = GB = G'k = Gmk, r = G(A - Bq) = G'l = Gml이 성립하며, 양변을 G로 나누면 B = mk, A - Bq = ml이 됩니다.두 연립 방정식에 의하여 A = ml + Bq = ml + mkq = m(l + kq) 가 되므로, m은 A와 B의 공약수가 됨을 알 수 있습니다.여기에서 A와 B는 서로소 관계에 있으므로, m = 1 이 되며, G' = mG라고 가정했으므로 G' = G 가 됩니다.즉, gcd(a, b) = gcd(b, r)입니다.r = 0인 경우 a = bq 이므로, b가 최대공약수가 됩니다.소스 코드자바스크립트 코드function GCD(a, b) {    return b ? GCD(b, a % b) : a;}function LCM(a, b) {    return a * b / GCD(a, b);}자바 코드public Euclidean {    public static int GCD(int a, int b) {        return b == 0 ? a : GCD(b, a%b);    }    public static int LCM(int a, int b) {        return a * b / GCD(a, b);    }}파이썬 코드def GCD(a, b):    return a if b == 0 else GCD(b, a%b)def LCM(a, b):    return a * b / GCD(a, b)C 코드int GCD(int a, int b) {    return b ? GCD(b, a%b) : a;}int LCM(int a, int b):    return a * b / GCD(a, b);관련 문제  프로그래머스(Programmers)          [12969] 최대공약수와 최소공배수      [12953] N개의 최소공배수      ",
        "url": "/algorithm/gcd_lcm"
    }
    ,
    
    "etc-phaser3": {
        "title": "게임 프레임워크 : Phaser3",
            "author": "rubisco",
            "category": "",
            "content": "Phaser3이란?RPG 만들기(일명 알만툴) 이라고 아시나요? 게임 만들기에 관심이 있었다면 한번쯤 알만툴이나 스타크래프트 유즈맵 편집기를 통해 게임을 제작해 본 적이 있을 것입니다. Phaser 또한 이러한 툴과 비슷한 자바스크립트 기반 게임 프레임워크 입니다. 자바스크립트를 기반으로 하기때문에 웹브라우저 환경에서 게임실행이 가능하도록 합니다.기본적으로 씬(Scene)과 게임 오브젝트(Game Object)로 구성되며, 물리엔진을 포함하고 있어서 손쉽게 게임을 제작할 수 있습니다.공식문서의 튜토리얼을 통해 간단한 게임을 제작해보도록 하겠습니다.  완성 프로젝트 : phaser3_example.zip프로젝트 설정우분투 20.04 LTS 환경을 기준으로 프로젝트를 생성해보겠습니다. 웹브라우저 환경에서 실행되므로 웹서버를 필요로 합니다. 간단하게 nodejs를 통해 웹서버를 만들도록 합시다.$ mkdir phaser3 &amp;&amp; cd phaser3 &amp;&amp; mkdir public &amp;&amp;  npm i http-server웹서버를 실행하면 public 폴더가 루트폴더로 설정됩니다.$ npx http-server타입스크립트를 통해 프로젝트를 만들도록 하겠습니다. 새로운 터미널을 열고 npm을 통해 typescript와 phaser를 설치합니다.$ npm i typescript phaser타입스크립트 설정파일(tsconfig.json)을 생성하고 다음과 같이 작성해줍니다.$ npx tsc --init &amp;&amp; nano tsconfig.json tsconfig.json{    \"compilerOptions\": {        \"target\": \"ES2015\",        \"module\": \"commonJS\",        \"allowJs\": true,        \"checkJs\": true,        \"jsx\": \"preserve\",        \"outDir\": \"./public/assets/js/\",        \"removeComments\": true,        \"strict\": true,        \"noImplicitAny\": true,        \"strictNullChecks\": true,        \"strictFunctionTypes\": true,        \"strictPropertyInitialization\": true,        \"noImplicitThis\": true,        \"alwaysStrict\": true,        \"noUnusedLocals\": true,        \"noUnusedParameters\": true,        \"noImplicitReturns\": true,        \"noFallthroughCasesInSwitch\": true,        \"esModuleInterop\": true    }}모듈을 합치고 호환성을 위해 웹팩을 사용하도록 하겠습니다.$ npm i webpack webpack-cli ts-loader웹팩 설정파일을 작성합니다.$ touch webpack.config.js &amp;&amp; nano webpack.config.jswebpack.config.jsconst path = require(\"path\");module.exports = {  entry: \"./src/main.ts\",  mode: \"none\",  module: {    rules: [      {        test: /\\.tsx?$/,        use: \"ts-loader\",        exclude: /node_modules/,      },    ],  },  resolve: {    extensions: [\".tsx\", \".ts\", \".js\"],  },  output: {    filename: \"main.js\",    path: path.resolve(__dirname, \"public/assets/js\"),  },};웹팩을 watch mode로 실행하면 코드가 수정될 때마다 자동으로 컴파일 됩니다.$ npx webpack -w게임 생성우선 메인 문서를 생성합시다. http-server는 index.html를 메인 문서로 인식합니다.$ touch public/index.html다음과 같이 컴파일된 자바스크립트 파일을 추가해주세요.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=\"/assets/js/main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;게임 인스턴스는 new Phaser.Game()을 호출하여 생성할 수 있습니다. 타입스크립트 파일을 작성하겠습니다.$ touch /src/main.ts &amp;&amp; nano /src/main.tsmain.tsimport Phaser from 'phaser';const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,};new Phaser.Game(config);Game 인스턴스는 매개변수로 GameConfig 객체를 받습니다. GameConfig 객체는 게임에 필요한 여러 설정값을 프로퍼티로 가지고 있습니다.type 프로퍼티는 그래픽의 렌더링 방식을 설정합니다. 캔버스를 사용하는 Phaser.CANVAS, WebGL을 사용하는 Phaser.WEBGL, 자동설정인 Phaser.AUTO 중 하나를 입력합니다.width와 height 프로퍼티는 화면 크기를 설정합니다. number 타입이며, 픽셀 단위로 입력합니다.backgroundColor는 화면의 색상을 설정합니다. number 타입의 hex 색상코드 또는 string 타입의 rgb 색상코드를 입력합니다.다양한 프로퍼티를 알고 싶다면 공식문서를 참고하세요.씬(Scene) 생성게임 객체의 동적인 작용을 위해서는 씬 객체를 생성해야 합니다. 씬 객체의 라이프 사이클은 다음과 같습니다.mainScene.tsclass MainScene extends Phaser.Scene {    constructor() {        super({ key: 'main', active: true })    }    preload(): void {}    create(): void {}    update(time: number, delta: number): void {}    destroy(): void {}}Scene 클래스를 상속받아 각각 오버라이드 하면 됩니다.preload() 메소드는 게임에 필요한 이미지나 오디오 파일 등의 리소스를 로드할 때 사용합니다. 게임에 필요한 리소스를 Asset 이라고 합니다. asset을 로드할 때 Scene 객체의 load 프로퍼티를 사용합니다. 일단 asset이 로드되면 Loader 객체는 키값을 통해 asset에 접근할 수 있도록 해줍니다.첨부파일의 이미지를 로드하기위해 다음 코드를 작성하세요.preload(): void {    this.load.image('sky', 'assets/image/sky.png');    this.load.image('ground', 'assets/image/platform.png');    this.load.image('star', 'assets/image/star.png');    this.load.image('bomb', 'assets/image/bomb.png');         this.load.spritesheet('dude', 'assets/image/dude.png', { frameWidth: 32, frameHeight: 48 });}하나의 이미지를 로드하려면 Sene.load.image 메소드를 호출합니다. 첫번째 파라미터로 키값을, 두번째 파라미터로 asset 경로를 입력합니다.spriteSheet의 경우 Sene.load.spritesheet 메소드를 호출하여 불러올 수 있습니다. 역시 첫번째 파라미터로 키값을, 두번째 파라미터로 asset 경로를 받으며, 3번째 파라미터로 sprite 설정 객체를 받습니다. 하나의 프레임에 대한 넓이와 높이를 설정해줍니다.로드한 asset은 create() 메소드에 Scene 객체의 add 프로퍼티를 통해 Scene에 추가할 수 있습니다.create(): void {    this.add.image(400, 300, 'sky');    this.add.image(400, 300, 'star');}첫번째 파라미터는 x축 좌표, 두번째 파라미터는 y축 좌표, 세번째 파라미터는 asset의 키값에 해당합니다.씬 코드를 작성했다면 게임 설정 객체의 scene 프로퍼티에 배열로 넣어주면 됩니다. 다음과 같이 작성하고 컴파일 후 localhost:8080 으로 들어가봅시다.main.tsimport Phaser from 'phaser';import { MainScene } from './mainScene';const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,    scene: [MainScene]};new Phaser.Game(config);mainScene.tsexport class MainScene extends Phaser.Scene {    constructor() {        super({ key: 'main', active: true });    }    preload(): void {        this.load.image('sky', 'assets/image/sky.png');        this.load.image('ground', 'assets/image/platform.png');        this.load.image('star', 'assets/image/star.png');        this.load.image('bomb', 'assets/image/bomb.png');        this.load.spritesheet('dude', 'assets/image/dude.png', { frameWidth: 32, frameHeight: 48 });    }    create(): void {        this.add.image(400, 300, 'sky');        this.add.image(400, 300, 'star');    }}다음과 같이 배경과 별 이미지가 출력된 것을 확인할 수 있습니다.물리객체 생성대부분의 게임들은 물리 효과가 적용되어 있습니다. 예를 들어 캐릭터가 점프를 하면 중력의 영향을 받아 낙하 하거나 충돌시 작용 반작용 효과를 받습니다. 이런 효과를 구현하려면 많은 노력이 필요하겠지만 Phaser는 2가지 물리엔진 arcade와 matter를 포함하고 있어 손쉽게 물리 효과를 부여할 수 있습니다.arcade는 Phaser 개발자가 만든 간단한 물리 엔진입니다. 간단히 사용하기에 편하지만 복잡한 게임을 만들기에는 조금 부족합니다.matter는 상용화 된 물리 엔진입니다. 앵그리버드 물리 엔진으로 유명한 Box2d에 이어 자바스크립트에서 사용되는 양대 산맥의 물리 엔진으로 알려져 있습니다.Phaser 튜토리얼에 따라 arcade 엔진으로 물리 객체를 생성해보겠습니다. 우선 게임 설정 객체에 physics 프로퍼티를 설정해주세요.const config: Phaser.Types.Core.GameConfig = {    type: Phaser.AUTO,    width: 800,    height: 600,    backgroundColor: 0xfff,    scene: [MainScene],    physics: {        default: 'arcade',        arcade: {            gravity: { y: 300 },            debug: false        }    }};씬 객체의 create 메소드에 다음과 같이 물리 객체를 생성하는 코드를 작성해 주세요.create(): void {    this.add.image(400, 300, 'sky');    const platforms = this.physics.add.staticGroup();    platforms.create(400, 568, 'ground').setScale(2).refreshBody();    platforms.create(600, 400, 'ground');    platforms.create(50, 250, 'ground');    platforms.create(750, 220, 'ground');}씬 객체에서 physics 프로퍼티는 arcade 물리 엔진을 의미합니다. 물리 객체에는 dynamic 객체와 static 객체가 있습니다. dynamic 객체는 중력이나 가속도의 영향을 받아 상호작용 할 수 있는 객체이고, static 객체는 벽과 같이 중력의 영향도 받지 않을 뿐더러 부딪쳐도 움직이지 않는 객체입니다.위에 코드에서는 우선 지형을 static 객체로 만들어보았습니다. static 그룹 객체를 만들고 4개의 static 객체를 추가했습니다. create 메소드에서 첫번째 파라미터는 x축 좌표, 두번째 파라미터는 y축 좌표, 세번째 파라미터는 asset의 키값입니다.캐릭터 생성이제 지형 위를 움직일 캐릭터를 생성해 보겠습니다.다음 코드를 create 메소드에 추가해주세요.const player = this.physics.add.sprite(100, 450, 'dude').setName(\"player\");player.setBounce(0.2);player.setCollideWorldBounds(true);this.anims.create({    key: 'left',    frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),    frameRate: 10,    repeat: -1});this.anims.create({    key: 'turn',    frames: [ { key: 'dude', frame: 4 } ],    frameRate: 20});this.anims.create({    key: 'right',    frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),    frameRate: 10,    repeat: -1});this.physics.add.sprite() 메소드를 통해 캐릭터의 sprite를 추가했습니다. sprite는 2d 이미지 합성을 통해 애니메이션 효과를 내는 기술입니다. 움직임이 있는 이미지라고 보시면 됩니다.  setName 함수를 통해 나중에 호출할 수 있도록 이름을 설정합니다.Physics Game Object Factory에 의해 생성된 sprite는 기본적으로 dynamic 객체가 됩니다. 플레이어 객체에 setBounce()를 통해 바운스를 설정하면 충돌시 작용 반작용 효과를 나타낼 수 있습니다. 또한 setCollideWorldBounds()를 통해 WoldBounds를 true로 설정하면 화면 경계에서 충돌 효과가 나타납니다. setGravityY()를 통해서는 중력의 크기를 설정할 수 있습니다.Scene 객체의 anims.create() 메소드를 통해서는 애니메이션 객체를 만들 수 있습니다. key는 애니메이션 객체의 키가 되고 frames는 프레임을, frameRate는 fps를 나타냅니다. repeat는 애니메이션의 반복수를 나타내는데 -1은 무한을 의미합니다.지형 객체는 static 객체이기 때문에 dinamic 객체인 캐릭터와 상호작용하기 위해서는 collider 객체로 충돌을 설정해야 합니다. 다음 코드를 씬 객체의 create 메소드에 추가해주세요.this.physics.add.collider(player, platforms);캐릭터 이동이제 키보드를 통해 캐릭터를 이동할 수 있도록 해보겠습니다.update 메소드에 다음 코드를 작성합니다. update 메소드는 씬 객체가 존재하는 동안 주기적으로 실행되는 메소드 입니다.update(_time: number, _delta: number): void {    const cursors = this.input.keyboard.createCursorKeys();    const player = this.children.getByName(\"player\") as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody;    if (cursors.left.isDown)    {        player.setVelocityX(-160);        player.anims.play('left', true);    }    else if (cursors.right.isDown)    {        player.setVelocityX(160);        player.anims.play('right', true);    }    else    {        player.setVelocityX(0);        player.anims.play('turn');    }    if (cursors.up.isDown &amp;&amp; player.body.touching.down)    {        player.setVelocityY(-330);    }}의미는 알기 쉬울 것입니다. 주기적으로 해당 키보드를 누르고 있는지 체크하여 속도를 설정하고 키에 해당하는 애니메이션을 실행합니다.별 모으기이제 별을 모으는 코드를 작성해보겠습니다. 우선 별을 static 객체로 생성합니다. 다음 코드를 create 메소드에 추가합니다.let stars = this.physics.add.group({    key: 'star',    repeat: 11,    setXY: { x: 12, y: 0, stepX: 70 }});this.data.set(\"stars\", stars);stars.children.iterate(function (child) {    (child as Phaser.Physics.Arcade.Image).setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));});static 그룹 객체를 만들고 12개의 별 객체를 만듭니다. 그룹 객체를 만들때 처음 1개는 자동으로 생성되므로 11번 반복하여 12개의 별 객체가 생성됩니다. x축 좌표는 12픽셀부터 시작하여 70픽셀 간격으로 생성됩니다. iterate 메소드를 통해 순차적으로 Y축 바운스를 설정해줍니다.static 객체인 지형과 별 그룹 객체가 상호작용 하도록 다음 코드를 create 메소드에 추가합니다.this.physics.add.collider(stars, platforms);캐릭터가 별을 수집하면 별 객체가 사라지도록 설정해줍시다. 이것은 arcade 물리 객체의 overlap 메소드를 통해 가능합니다. 다음 코드를 create 메소드에 추가해 주세요.this.physics.add.overlap(player, stars, this.collectStar, undefined, this);player 객체가 stars 객체와 overlap 되면 collectStar 메소드를 호출합니다. 해당 메소드를 작성해주세요.collectStar (_player: Phaser.Types.Physics.Arcade.GameObjectWithBody, star: Phaser.Types.Physics.Arcade.GameObjectWithBody): void {    (star as Phaser.Physics.Arcade.Image).disableBody(true, true);}star 객체의 disableBody 함수를 호출하면 해당 객체가 사라집니다.점수 설정별을 모으면 점수가 증가 하도록 하겠습니다. 우선 create 메소드에 점수 데이터와 텍스트 asset을 추가해주세요.this.data.set(\"score\", 0);this.add.text(16, 16, 'score: 0', { fontSize: '32px', backgroundColor: '#000' }).setName(\"scoreText\");다음으로 위에서 생성한 collectStar 메소드에 다음 코드를 추가합니다.this.data.set(\"score\", this.data.get(\"score\") as number + 10);(this.children.getByName(\"scoreText\") as Phaser.GameObjects.Text).setText('Score: ' + (this.data.get(\"score\") as number));장애물 설정마지막으로 장애물을 설정해 보겠습니다. 별을 모두 수집하면 폭탄이 하나 나오고 새로운 별 그룹 객체가 생성됩니다. create 메소드에 다음 코드를 추가합니다.const bombs = this.physics.add.group();this.data.set(\"bombs\", bombs);this.physics.add.collider(bombs, platforms);this.physics.add.collider(player, bombs, this.hitBomb, undefined, this);폭탄의 그룹인 dynamic 그룹 객체를 생성하여 collider 객체로 충돌을 설정합니다. 또한 플레이어가 폭탄에 닿으면 hitBomb 메소드를 호출합니다.hitBomb 메소드는 다음과 같이 작성합니다.hitBomb (player: Phaser.Types.Physics.Arcade.GameObjectWithBody, _bomb: Phaser.Types.Physics.Arcade.GameObjectWithBody): void {    this.physics.pause();    (player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).setTint(0xff0000);    (player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).anims.play('turn');}폭탄에 닿으면 물리 객체의 상호작용이 정지되고 플레이어 캐릭터의 색이 빨같게 됩니다.마지막으로 collectStar 메소드에 다음 코드를 추가합니다.const stars = this.data.get(\"stars\") as Phaser.Physics.Arcade.Group;if (stars.countActive(true) === 0) {    stars.children.iterate(function (child) {        (child as Phaser.Physics.Arcade.Image).enableBody(true, (child as Phaser.Physics.Arcade.Image).x, 0, true, true);    });    const x = ((player as Phaser.Types.Physics.Arcade.SpriteWithDynamicBody).x &lt; 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);    const bombs = this.data.get(\"bombs\") as Phaser.Physics.Arcade.Group;    const bomb = bombs.create(x, 16, 'bomb');    bomb.setBounce(1);    bomb.setCollideWorldBounds(true);    bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);}별 객체가 하나도 없다면 새로운 별 객체 그룹을 생성하고 폭탄을 하나 생성하도록 합니다. 폭탄에 각각 바운스와 월드 바운스, 속도를 설정합니다.",
        "url": "/etc/phaser3"
    }
    ,
    
    "typescript-interface": {
        "title": "클래스와 인터페이스",
            "author": "rubisco",
            "category": "",
            "content": "클래스(class)클래스(class)는 자바스크립트 es6에 추가된 타입입니다. es6 이전에는 클래스가 없고 프로토타입을 기반으로 클래스를 만들었으나, 클래스가 추가되면서 조금 더 명료하게 클래스를 작성할 수 있게 되었습니다.클래스 선언클래스 선언은 다음과 같이 합니다.class User { }함수의 선언과 달리 클래스는 호이스팅 되지 않습니다. 선언된 클래스는 new 키워드를 통해 인스턴스화(Instantiation) 될 수 있습니다.let user: User = new User(); 클래스 생성자생성자는 constructor 키워드를 통해 정의할 수 있습니다.class User {    constructor(name: String) {        console.log(name);    }}let user: User = new User(\"rubisco\"); 인스턴스 속성객체의 속성과 마찬가지로 인스턴스도 속성을 가질 수 있으며, 클래스 내부에서는 this 키워드를 통해 접근 가능합니다. 또한 다른 언어들과 비슷하게 접근자 키워드를 통해 속성 접근을 제한할 수 있습니다.접근자에는 public, protected, private가 있으며, 기본값은 public입니다.타입스크립트 컴파일시 환경설정에 --strictPropertyInitialization 옵션이 있다면 반드시 속성을 초기화 해주어야 합니다.class User {    private name: string;    constructor(name: string) {        this.name = name;    }}let user: User = new User(\"rubisco\"); 만약 읽기전용 속성을 생성하려면 자바에서 final 키워드를 붙이는 것과 같이 readonly 키워드를 속성 앞에 붙입니다.class User {    private readonly name: string;    constructor(name: string) {        this.name = name;    }}let user: User = new User(\"rubisco\"); Getter / Setter자바스크립트의 클래스 또한 Getter와 Setter를 선언할 수 있습니다. 메소드 앞에 get 키워드를 붙이면 getter, set 키워드를 붙이면 setter가 됩니다.class User {    private _name: string;    constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }}let user: User = new User(\"rubisco\");console.log(user.name); // \"rubisco\" 출력user.name = \"spot\";console.log(user.name); // \"spot\" 출력클래스의 확장자바와 마찬가지로 타입스크립트의 클래스도 extends 키워드를 통해 상속이 가능합니다. 또한 super 키워드를 통해 부모 클래스에 접근할 수 있습니다.class Animal {        private _name: string;    protected constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }}class Dog extends Animal {    constructor(name: string) {        super(name);    }    sniff(): void {        console.log(`${ this.name }이(가) 냄새를 맡습니다.`);    }}class Bird extends Animal {    constructor(name: string) {        super(name);    }    fly(): void {        console.log(`${ this.name }이(가) 날아다닙니다.`);    }}let dog: Dog = new Dog(\"코커스파니엘\");let bird: Bird = new Bird(\"까마귀\");dog.sniff();bird.fly();추상 클래스추상 클래스는 클래스 앞에 abstract 키워드를 통해 선언할 수 있습니다. 일반 클래스와 달리 추상 클래스는 인스턴스화가 불가능하며, 추상 클래스를 상속받은 자식 클래스에게 추상 메소드의 구현을 강제합니다.abstract class Animal {        private _name: string;    protected constructor(name: string) {        this._name = name;    }    get name() {        return this._name;    }    set name(name: string) {        this._name = name;    }    abstract move(): void;}class Dog extends Animal {    constructor(name: string) {        super(name);    }    move(): void {        console.log(\"네발로 걷습니다.\");    }}class Bird extends Animal {    constructor(name: string) {        super(name);    }    move(): void {        console.log(\"날개로 날아다닙니다.\");    }}let dog: Dog = new Dog(\"코커스파니엘\");let bird: Bird = new Bird(\"까마귀\");dog.move();bird.move();인터페이스(Interface)타입스크립트의 핵심 원리 중 하나는 값이 가지는 형태에 초점을 맞추어 타입체크를 한다는 것입니다. 이러한 동적 타이핑을  덕 타이핑(duck typing)이라고 합니다.  “어떤 새가 오리처럼 보이고 오리처럼 헤엄치는 오리처럼 운다면 그것은 오리일 것이다.”덕 타이핑은 덕 테스트에서 유래한 단어로, 타입스크립트에서 데이터의 타입은 인터페이스 형태에 의하여 결정됩니다.자바스크립트만 다뤄 본 개발자들은 인터페이스라는 개념이 생소하게 느껴질 것입니다. 인터페이스는 자바나 C# 등 정적 타입 언어에서 이미 많이 쓰이고 있는 개념으로, 여러가지 타입을 가지는 프로퍼티로 이루어진 새로운 타입을 정의하는 규칙입니다. 인터페이스에 선언된 프로퍼티나 메소드의 구현을 강제하여 일관성을 유지하도록 하는 역할을 합니다.인터페이스는 타입의 이름을 짓는 코드 내부의 계약을 정의할 뿐만 아니라 프로젝트 외부에서 사용하는 코드의 계약을 정의하는 강력한 방법입니다. 프로퍼티와 메소드를 가진다는 점에서 클래스와 유사하지만 직접적으로 인스턴스를 생성할 수 없으며, 모든 메소드는 추상 메소드로 구성됩니다.인터페이스 정의인터페이스를 정의하는 문법은 객체(object) 타입과 유사합니다.let user: {    index: number;    name: string;    level: number;};위에 객체를 인터페이스로 정의하면 다음과 같습니다.interface User {    index: number;    name: string;    level: number;};인터페이스나 클래스는 파스칼 표기법(Pascal case)를 사용하여 정의하는 것이 관례이며, 정의된 인터페이스는 다음과 같이 사용가능합니다.let user: User = { index: 1, name: 'rubisco', level: 4 };객체 타입과 마찬가지로 읽기 전용 속성 또는 선택 속성을 정의할 수도 있습니다.interface User {    readonly index: number;    name: string;    level: number;    item?: string;};let player: User = { index: 2, name: 'spot', level: 4 };함수형 인터페이스(Functional Interface)인터페이스를 통해 함수 타입을 정의하는 것도 가능합니다. 함수 타입을 정의하기 위해서는 호출 시그니쳐(call signature) 즉, 매개변수의 타입 정의가 필요합니다.interface User {    readonly name: string;    hp: number;    mp: number;    item?: string;};interface GetUserName {    (player: User): string;}const getUserName: GetUserName = function(user) {    return user.name;}위의 코드를 보면 GetUserName이라는 인터페이스를 통해 해당 타입의 함수는 User 타입의 매개변수를 받고 문자열을 반환한다는 것을 알 수 있습니다.함수형 인터페이스를 통해 람다식을 작성함으로써 코드를 간결하게 표현할 수도 있습니다.const getUserNameLambda: GetUserName = (user) =&gt; user.name;하이브리드 타입(Hybrid Type)호출 시그니처와 속성 타입을 동시에 가지는 인터페이스를 하이브리드 타입(Hybrid Type)이라고 합니다.interface Player {    readonly name: string;    hp: number;    mp: number;    power: number;    items?: string[];};interface Battle {    (player: Player, opponent: Player): Battle;    attack(): void;    turn: number;}let battle = &lt;Battle&gt; function (player: Player, opponent: Player): Battle {    if (battle.turn == null) battle.turn = 0;    battle.turn += 1;    battle.attack = () =&gt; player.hp -= opponent.power;    return battle;};let player1: Player = { name: 'rubisco', hp: 50, mp: 10, power: 10 };let player2: Player = { name: 'enemy', hp: 50, mp: 10, power: 10 };battle(player1, player2).attack();console.log(battle.turn, player1.hp);위에 코드에서 Battle 인터페이스는 호출 시그니처와 속성을 모두 가진 하이브리드 타입 입니다.인덱서블 타입 (Indexable Types)인덱서블 타입은 타입을 인덱스로 사용할 수 있도록 합니다. 자바에서 list와 map 타입이 인덱서블 타입에 해당합니다. 인덱서의 타입은 number와 string, symbol만  지정할 수 있습니다.interface User {    readonly name: string;};interface UserArray {    [index: number]: User;}let user1: User = { name: \"Kim\" };let user2: User = { name: \"Lee\" };let users:UserArray = [user1, user2];console.log(users[1].name);인터페이스 확장인터페이스는 자바와 마찬가지로 extends 키워드를 통해 상속이 가능합니다.interface GameObject {    name: string;    hp: number;    mp?: number;}interface Player extends GameObject {    attack(): void;    defense(): void;}let player: Player = {    name: \"rubisco\",    hp: 50,    mp: 10,    attack: function (): void {        console.log(\"공격!\");    },    defense: function (): void {        console.log(\"방어!\");    }}player.attack();인터페이스의 경우 클래스와 달리 extends 키워드를 통해 다중 상속이 가능합니다.interface GameObject {    name: string;    hp: number;    mp?: number;}interface Attack {    attack(): void;}interface Defense {    defense(): void;}interface Player extends GameObject, Attack, Defense {}let player: Player = {    name: \"rubisco\",    hp: 50,    mp: 10,    attack: function() {        console.log(\"공격!\");    },    defense: function() {        console.log(\"방어!\");    },}player.attack();클래스의 인터페이스 구현클래스에서 인터페이스를 구현하기 위해서는 implements 키워드를 사용합니다.interface Animal {    move(): void;}class Dog implements Animal {        move(): void {        console.log(\"네발로 걷습니다.\");    }}let dog: Dog = new Dog();dog.move();구현을 강제한다는 점에서 추상 클래스와 비슷하지만 추상 클래스와 달리 인터페이스는 다중 상속이 가능합니다. 상황에 따라 중복된 기능을 가지며 같은 조상으로 부터 물려받을 것이 보장되길 원한다면 추상클래스를, 기능이 중복되지만 조상이 다르다면 인터페이스를 사용하면 됩니다.",
        "url": "/typescript/interface"
    }
    ,
    
    "typescript-syntax": {
        "title": "타입스크립트 문법(TypeScript Syntax)",
            "author": "rubisco",
            "category": "",
            "content": "기본 타입자바스크립트는 다음과 같이 7가지 내장 타입을 제공합니다.  Number  String  Boolean  Symbol  Null  Undefined  Object타입스크립트에는 자바스크립트의 내장 타입에 해당하는 원시 타입이 있습니다.  number  string  boolean  symbol  null  undefined  object타입스크립트에만 존재하는 원시 타입도 있습니다.  unknown  never  void  any그 외에도 다음과 같은 참조 타입이 있습니다.  Array  Tuple  Enum원시 타입(Primitive Type)불리언(Boolean)boolean은 가장 기본적인 데이터 타입으로, 참/거짓(true/false)값을 나타냅니다.let isDone: boolean = false;숫자(Number)자바스크립트처럼 타입스크립트의 모든 숫자는 부동소수점을 사용합니다. 16진수, 10진수 literal과 2진수, 8진수 literal도 지원합니다.let decimal: number = 10;let hex: number = 0xff0a;let binary: number = 0b1010;let octet: number = 0o777;문자열(String)자바스크립트와 마찬가지로 큰따옴표(\") 또는 작은따옴표(')를 통해 문자열을 나타냅니다.let color: string = \"red\";let name: string = 'rubisco';백틱(`)으로 문자열을 감싸서 템플릿 문자열을 만들 수도 있습니다.let name: string = \"rubisco\";let introduce: string = `안녕하세요? ${ name } 입니다.`; // \"안녕하세요? \" + name + \" 입니다.\" 와 동일Null / Undefinednull과 undefined 타입은 각각 null과 undefined라는 하나의 값만을 가집니다. null은 변수를 선언했지만 빈값을 할당한 상태를 의미하며, undefined는 변수를 선언했지만 값이 없는 상태 즉, 타입이 없는 상태를 의미합니다. typeof 메소드를 통해 자료형을 확인해보면 null은 object, undefined는 undefined 타입인 것을 확인할 수 있습니다.null과 undefined는 기본적으로 모든 타입의 하위타입이므로 아무런 설정이 없다면 아래와 같은 할당이 허용됩니다.let name: string = null;하지만 이러한 동작은 버그를 양산하기 쉽습니다. 엄격한 타입 체크를 위해 타입스크립트 2.0부터 옵션으로 --strictNullChecks 플래그가 추가되었습니다. 옵션에 이 플래그를 추가하면 null과 undefined 값을 다른 타입에 할당하는 것을 방지할 수 있습니다.Any / Unknownany 타입은 모든 데이터 타입을 허용할 때 사용합니다. 데이터 타입을 미리 알 수 없는 경우 사용할 수 있지만 불가피한 경우를 제외하고는 사용하지 않는것이 권장됩니다. 보통 자바스크립트 문법을 점진적으로 타입스크립트 문법으로 바꿀때 사용합니다.let letter: any = \"문자\";letter = 20; // string 타입이 들어있지만 number 타입이 들어갈 수 있습니다.unknown 타입은 타입스크립트 3.0부터 도입되었습니다. any 타입과 동일하게 모든 타입의 값을 허용하지만 엄격한 타입 체크를 요구합니다.let num: any = 10;console.log(num.length); // undefined 출력let unknownValue: unknown = 10;console.log(unknownValue.length); // 에러 발생 : Object is of type 'unknown'.ts(2571)num 변수와 unknwonValue 변수에는 숫자가 할당되어 length 메소드를 가지고 있지 않습니다. any타입인 num의 경우 length 메소드를 호출하면 undefined 값을 출력합니다. 반면에 unknown 타입인 unknownValue는 오류를 출력합니다.unknown 타입의 경우 다음과 같은 엄격한 타입체크가 필요합니다.let unknownValue: unknown = 10;if(typeof unknownValue === \"string\") {    console.log(unknownValue.length);} else {    console.log(undefined);}Void / Nevervoid 타입은 null과 undefined만 값으로 가질 수 있는 타입입니다. 함수에서는 리턴값이 없을때 사용합니다.function msg_logger(msg: any): void {    console.log(msg);}never 타입은 아무런 값을 가지지 않는 타입입니다. null, undefined를 포함한 모든 타입의 최하위 타입에 속하기 때문에 never을 제외한 어떤 값도 할당될 수 없습니다. 무한 루프를 돌거나 에러를 출력하는 함수의 경우 리턴값 자체가 없기때문에 never 타입을 가집니다.function infiniteLoop(): never {    while (true) {} // 무한 루프}function error(message: string): never {    throw new Error(message); // 에러 출력}참조 타입(Reference Type)객체(Object)자바스크립트는 프로토타입 객체 기반 언어로, 원시 자료형을 제외한 모든 데이터가 객체(Object)로 구성됩니다.object 타입은 중괄호({})를 사용하여 선언할 수 있습니다.let user: {name: string, age: number} = {name: '홍길동', age: 19};위에 코드에 보는 바와 같이 콜론(:)의 좌변에는 속성의 키워드값이, 우변에는 속성 타입이 들어갑니다. 각 속성의 구분은 위에 코드처럼 콤마(,)로 구분하며, 세미콜론(;)을 통해서도 구분가능합니다.let user: {    name: string;     age: number;} = {name: '홍길동', age: 19};속성명 뒤에 물음표(?)를 붙이면 해당 속성을 선택 속성으로 선언할 수 있습니다.let user: {    name: string;     age: number;    comment?: string;} = {name: '홍길동', age: 19};위 코드에서 comment의 값은 할당되지 않았지만 선택속성이므로 오류없이 객체 값이 할당될 수 있습니다.속성명 앞에 readonly 키워드를 붙이면 값의 재할당을 막을 수 있습니다. 변수에서 const 키워드를 통한 변수 할당과 동일합니다.let user: {    readonly name: string;     age: number;} = {name: '홍길동', age: 19};user.name = '고길동'; // error TS2540: Cannot assign to 'name' because it is a constant or a read-only property.배열(Array)배열의 경우 2가지 방법으로 타입을 지정할 수 있습니다.첫번째 방법은 타입 뒤에 []을 붙이는 것입니다.let colors: string[] = ['red','orange','yellow','green'];두번째 방법은 제네릭(generic) 배열 타입을 사용하는 것입니다.let colors: Array&lt;string&gt; = ['red','orange','yellow','green'];튜플(Tuple)튜플은 배열과 유사하며, 요소(element)의 수가 고정된 배열을 나타낼 수 있습니다.let member: [number, string] = [1, 'rubisco'];열거(Enum)열거형은 자바의 열거형과 마찬가지로 숫자 또는 문자열 값의 집합에 이름을 부여할 수 있습니다.enum Week { SUN, MON, TUE, WED, THU, FRI, SAT }let today: Week = Week.WED;인덱스 번호로도 접근가능합니다.enum Week { SUN, MON, TUE, WED, THU, FRI, SAT }let tomarrow: Week = Week[4]; // Week.THU와 동일자바처럼 초기 인덱스 번호를 지정해 줄 수도 있습니다.enum Week { SUN = 1, MON, TUE, WED, THU, FRI, SAT }let yesterday: Week = Week[3]; // Week.TUE와 동일또한 자바와 달리 문자열 값을 지정해 줄 수 있습니다.enum Color {    RED = \"red\",    BLUE = \"blue\",    GREEN = \"green\"}let color: Color = Color.RED; // 문자열 \"red\"와 동일타입 추론과 타입 단언타입 추론(Type Inference)타입 추론(Type Inference)이란 타입스크립트가 코드를 해석해나가는 동작을 의미합니다. 아래와 같이 타입을 선언하지 않고 변수에 값을 할당하면 타입스크립트에서는 str 변수를 string 타입으로 추론합니다.let str = \"spot\" // string 타입 값이 할당되었으므로 string 타입으로 추론그러므로 str 변수에 문자열이 아닌 숫자를 재할당한다면 오류가 발생합니다.str = 1 // Type 'number' is not assignable to type 'string'.const나 readonly 키워드가 있는 경우 타입스크립트는 구체적인 literal 타입을 추론합니다.const x = 1 // 1로 추론타입 단언(type assertion)타입스크립트 컴파일러는 타입 표기, 타입 추론 등을 이용해 값의 타입을 판단합니다. 하지만 때로는 컴파일러가 가진 정보를 무시하고 개발자가 원하는 임의의 타입을 값에 할당하고 싶을 수 있는데, 이때 필요한 것이 타입 단언(type assertion)입니다.let div = document.querySelector('div');div.innerText = \"rubisco\"; // Object is possibly 'null'.ts(2531)위의 코드의 경우 타입스크립트는 div가 null일 경우까지 추론하게 됩니다. div가 null일 경우 innerText 메소드가 존재하지 않게 되므로 오류를 출력하게 됩니다. 이럴때 변수 뒤에 as 키워드를 붙여 타입 단언을 해줄 수 있습니다. 자바에서 명시적 형변환(Casting)과 같은데, 형변환은 런타임에서 발생하는 동작이고 타입 단언은 컴파일시 발생하는 동작이라는 차이가 있습니다.let div = document.querySelector('div');(div as HTMLDivElement).innerText = \"rubisco\";변수 뒤에 느낌표(!)를 붙여서 값이 무조건 존재한다는 확정적 할당 단언(definitive assignment assertion)을 함으로써 이를 해결할 수도 있습니다.let div = document.querySelector('div');div!.innerText = \"rubisco\";제네릭(Generic)제네릭은 자바 또는 C# 등의 언어에서 재사용성이 높은 컴포넌트를 만들 때 자주 활용되는 특징입니다. 특히, 한가지 타입보다 여러 가지 타입에서 동작하는 컴포넌트를 생성하는데 사용됩니다. 함수나 클래스를 사용하는 시점에 타입을 선언함으로써 타입을 파라미터처럼 사용할 수 있습니다.제네릭 타입은 함수 이름 뒤에 괄호(&lt;&gt;)로 표기하며 괄호안에 타입명을 적습니다. 관습적으로 T는 Type, E는 Element, K는 Key, V는 Value, N은 Number를 뜻합니다.아래와 같이 코드를 작성해 봅시다.function toArray(a: number | string, b: number | string): (number | string)[] {    return [a, b];}let o1 = toArray(1, 2); // 배열 [1, 2]가 대입let o2 = toArray(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 선언에서 | 기호는 OR를 의미합니다. 다시 말해서 toArray 함수의 파라미터는 숫자형이나 문자형의 데이터를 받을 수 있습니다. 이를 제네릭을 통해 선언하면 다음과 같이 작성할 수 있습니다.function toArray&lt;T&gt;(a: T, b: T): T[] {    return [a, b];}let o1 = toArray&lt;number&gt;(1, 2); // 배열 [1, 2]가 대입let o2 = toArray&lt;string&gt;(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 추론을 통해 아래와 같이 타입 변수를 생략해도 됩니다.function toArray&lt;T&gt;(a: T, b: T): T[] {    return [a, b];}let o1 = toArray(1, 2); // 배열 [1, 2]가 대입let o2 = toArray(\"a\", \"b\"); // 배열 [\"a\", \"b\"]가 대입타입 변수를 여러 개 지정할 수도 있습니다.function toArray&lt;T, U&gt;(a: T, b: U): [T, U] {    return [a, b];}let o1 = toArray(1, \"a\"); // 배열 [1, \"a\"]가 대입제네릭을 사용하지 않으면 선언해준 데이터 타입으로만 반환값을 선언할 수 있습니다. 즉, 정적입니다. 하지만 제네릭을 사용한다면 동적으로 반환값을 선언할 수 있습니다.물론 다음과 같이 any 타입으로 동적 선언을 해줄 수도 있습니다.function toArray(a: any, b: any): any {    return [a, b];}이렇게 타입을 선언한다고 해서 함수의 동작에 문제가 발생하지는 않지만, 타입 검사를 하지 않기때문에 오류를 찾아내는 것이 힘들어집니다. 제네릭을 통해 타입을 선언한다면 타입 검증 과정을 거치기 때문에 좀 더 효율성 있는 개발이 이루어질 수 있을 것입니다.",
        "url": "/typescript/syntax"
    }
    ,
    
    "typescript-typescript": {
        "title": "타입스크립트(TypeScript)란?",
            "author": "rubisco",
            "category": "",
            "content": "자바스크립트(JavaScript)자바스크립트는 모질라 재단에서 개발한 프로토타입 기반의 스크립트 언어입니다. HTML, CSS와 함께 웹을 구성하는 요소중 하나입니다. HTML이 웹페이지의 구조를 정의하고 CSS가 웹페이지를 디자인 한다면 자바스크립트는 클라이언트 단에서 웹페이지가 동적으로 동작하도록 합니다.HTML5가 등장하기 이전에 웹 애플리케이션(Web Application)은 어도비 플래시(Adobe Flash)나 마이크로소프트 실버라이트(Microsoft Silverlight), 마이크로소프트 액티브X(Microsoft ActiveX) 등의 외부 플러그인에 의존했습니다.그러나 HTML5의 등장 이후 플러그인의 기능이 자바스크립트로 구현가능해졌고, AJAX의 활성화로 SPA(Single Page Application)가 대세가 되었습니다.또한 예전에는 웹브라우저의 인터프리터에 의해 클라이언트 단에서만 동작했지만 Node.js가 등장하면서 서버 단에서도 런타임 환경에서 동작이 가능해졌습니다.타입스크립트(TypeScript)타입스크립트는 마이크로소프트에서 구현한 자바스크립트 슈퍼셋 프로그래밍 언어입니다. 즉, 자바스크립트 문법에 타입스크립트 문법을 추가한 언어입니다. 이때문에 올바르게 작성된 자바스크립트 코드는 타입스크립트 코드로 사용가능합니다.자바스크립트가 동적 타입의 인터프리터 언어로 런타임에서 오류를 발견할 수 있는 반면 타입스크립트는 정적 타입의 컴파일 언어로 타입스크립트 컴파일러 또는 바벨(Babel)을 통해 자바스크립트 코드로 컴파일해야합니다. 즉, 타입스크립트는 변수나 함수에 타입을 명시하여 사전에 오류를 발견하여 자바스크립트 개발의 생산성을 높일 수 있습니다.타입스크립트는 2020년 스택 오버플로(Stack Overflow)에서 전세계 6만 5천 명의 개발자를 대상으로 실시한 설문조사에서 개발자가 가장 좋아하고 관심을 가지는 프로그래밍 언어 2위에 오를 정도로 인기있는 언어입니다. 요즘은 대형 SI 프로젝트에서 흔하게 사용되고 있으며, 개발자 구인 시 자바스크립트보다 타입스크립트를 우대기술로 언급하고 있습니다.타입스크립트 사용 이유에러를 사전에 발견앞서 설명했듯이 타입스크립트는 코드를 컴파일을 필요로 정적인 언어이며, 타입을 명시하기때문에 사전에 에러를 검출하는 것이 가능합니다.function sum(a, b) {    return a + b;}sum('1', '2'); // '12'위의 덧셈 함수는 1 + 2를 의도했을테지만, 자바스크립트의 경우 타입이 명시적이지 않기 때문에 동적 타이핑(Dynamic Typing)에 의하여 숫자 3이 아닌 문자열 '12'를 출력합니다.즉, 개발자가 의도하지 않은 값이 나올 수 있으며 디버깅이 어렵게 됩니다.function sum(a: number, b: number) {    return a + b;}sum('1', '2'); // error TS2345: Argument of type '\"1\"' is not assignable to parameter of type 'number'.반면 타입스크립트의 경우 타입을 number라고 명시했기때문에 문자열이 들어간다면 컴파일 단계에서 사전에 오류를 포착할 수 있습니다. 명시적인 정적 타입 지정은 개발자의 의도를 명확하게 기술하여 코드 가독성을 높이고 디버깅을 쉽게 할 수 있도록 합니다.도구의 지원타입스크립트는 IDE를 포함한 다양한 도구의 지원을 받을 수 있습니다. Visual Studio Code의 경우 툴의 내부가 타입스크립트로 작성되어 있기 때문에 타입스크립트 개발에 최적화 되어 있습니다.변수 a의 타입은 number 이므로 toLocaleString 함수를 사용가능합니다. 자바스크립트의 경우 함수명을 직접 입력해야 하지만, 타입스크립트는 스니펫을 통해 빠른 코드 작성이 가능합니다.자바스크립트 호환타입스크립트는 자바스크립트의 슈퍼셋 언어이므로 자바스크립트와 100% 호환됩니다. 따라서 자바스크립트로 작성된 코드를 쉽게 타입스크립트로 변환할 수 있습니다.개발환경 구축우분투 20.04 LTS 버전을 기준으로 타입스크립트 개발환경을 구축해 보겠습니다.작업공간(work space) 만들기프로젝트를 위한 작업공간을 하나 생성합시다.~$ mkdir -p ws/typescript &amp;&amp; cd ws/typescriptnodejs 설치apt를 통해 nodejs와 npm을 설치합니다.~/ws/typescript$ sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt install nodejs npmnodejs의 여러버전을 관리하고 싶다면 nvm을 통해 설치할 수도 있습니다.NVM GitHub에서 버전을 확인후 설치해주세요.~/ws/typescript$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash설치후 다음 명령어를 입력하여 NVM을 활성화 시킵니다.~/ws/typescript$ source ~/.bashrcnodejs 설치는 다음과 같습니다.$ nvm install node  # 최신 버전 설치$ nvm install --lts # 최신 LTS 버전 설치$ nvm install 16.14.0  # 특정 버전 설치$ nvm install 16  # 특정 버전 16의 최신 릴리즈 설치typescript 설치npm을 통해 타입스크립트를 전역으로 설치합니다. nodejs와 npm이 설치되어있어야 합니다.~/ws/typescript$ sudo npm i -g typescript설치가 되었는지 확인하기 위해 다음 명령어를 입력합니다.~/ws/typescript$ tsc -v프로젝트 내에서만 타입스크립트를 설치하고 싶다면 다음과 같이 명령어를 입력합니다.~/ws/typescript$ npm i typescript -D~/ws/typescript$ npx tsc -v타입스크립트 파일 코드 작성타입스크립트의 확장자는 .ts입니다. app.ts 파일을 생성후 에디터로 엽니다.~/ws/typescript$ touch app.ts &amp;&amp; nano app.ts다음 예제 코드를 작성하세요.const message: string = 'hello world';console.log(message);컴파일(Compile)코드를 저장하고 다음 명령어를 입력하여 컴파일합니다.~/ws/typescript$ tsc app.ts컴파일이 완료되면 자바스크립트 파일(app.js)이 생성됩니다.var message = 'hello world';console.log(message);자동으로 컴파일하고 싶다면 --watch 또는 -w 옵션을 주면 됩니다.설정파일 : tsconfig.json컴파일시 명령어를 통해 여러 옵션을 줄 수 있습니다.~$ tsc app.ts --strict true --target ES6 --lib ES2015,DOM --module CommonJS옵션 명령어 뿐만 아니라 tsconfig.json 파일을 통해서도 옵션을 줄 수 있습니다. 다음 명령어를 통해 default 설정파일을 생성할 수 있습니다.~$ tsc --init컴파일 옵션에 대해서는 다음 페이지를 참조하세요: 영문 / 한글",
        "url": "/typescript/typescript"
    }
    ,
    
    "etc-iso-standard-7498": {
        "title": "OSI 7계층(ISO Standard 7498)",
            "author": "rubisco",
            "category": "",
            "content": "OSI 7계층데이터를 주고 받는 과정에는 많은 단계가 있습니다. 국제표준화기구(ISO)에서는 이를 역할에 따라 7개의 계층으로 나누었습니다. 이것을 OSI 7계층(Open Systems Interconnection 7 Layer)이라고 합니다.각 계층은 독립적으로 작용하며 수많은 프로토콜(Protocol)이 존재하는데 프로토콜이란 데이터를 주고 받기위한 일종의 약속을 말합니다. 프로토콜에 의해 하위 계층으로 갈수록 헤더가 붙으면서 데이터의 크기는 커집니다.            OSI 모델      프로토콜                  1층: 물리 계층      1000BASE-T, RS-232, RS-485              2층: 데이터 링크 계층      이더넷(Ethernet), PPP, UART              3층: 네트워크 계층      IP, ICMP              4층: 전송 계층      TCP, UDP              5층: 세션 계층      SSH, TLS, RPC              6층: 표현 계층      ASCII, MPEG, JPEG              7층: 응용 계층      HTTP, FTP, Telnet, DHCP      물리 계층 (Physical Layer)물리 계층의 데이터 단위는 비트(bit)이며, 네트워크 케이블과 신호에 관한 규칙을 다루고 있는 계층입니다. 통신 케이블의 종류와 신호의 규격 및 무선통신 주파수 설정, 커넥터 형태 등을 정합니다.물리 계층과 관련된 장비로는 동축 케이블의 아날로그 신호를 디지털 데이터로 변환하는 모뎀(Modem), 다수의 컴퓨터를 연결하여 하나의 네트워크로 보내는 허브(Hub), 디지털 신호를 증폭해주는 리피터(Repeater) 등이 있습니다.데이터 링크 계층 (Datalink Layer)데이터 링크 계층의 데이터 단위는 프레임(frame)이며, 물리적 매체를 통해 데이터를 전달하는 계층입니다. 네트워크 계층에 데이터를 전달하고 물리계층에서 발생하는 오류를 탐지하고 수정하는 기능을 담당합니다. 또한 MAC주소(Media Access Control Address)라는 물리적 주소를 사용하여 각 기기들의 구분을 가능하게 합니다.이 계층과 관련된 프로토콜에는 HDLC, PPP, LLC 등이 있으며, 관련된 장비로는 데이터를 MAC주소를 기반으로 빠르게 전달하는 스위치(Switch), 2개의 랜을 연결하는 브릿지(Bridge) 등이 있습니다.네트워크 계층 (Network Layer)네트워크 계층의 데이터 단위는 패킷(packet)이며, 네트워크를 논리적으로 구분하는 계층입니다. 인터넷에서는 IP주소(Internet Protocol Address)라는 논리적 주소를 사용합니다. 이 계층에서는 전송 계층에서 요구하는 서비스 품질(Qos)를 위한 수단을 제공합니다. 또한 라우팅 프로토콜을 통해 데이터를 전송하는 최적의 경로를 찾아냅니다.관련된 프로토콜에는 IP, ARP, RARP, ICMP, IGMP 등이 있으며, 관련된 장비로는 랜을 연결하는 라우터(Router)가 있습니다.전송 계층 (Transport Layer)전송 계층은 서비스를 구분하고 사용자 사이의 신뢰성 있는 데이터 전달을 담당하는 계층입니다.이 계층의 프로토콜에는 신뢰성있는 데이터 전송이 목적인 TCP(Transmission Control Protocol)와 빠른 데이터 전송이 목적인 UDP(User Datagram Protocol)가 있습니다.TCP는 세그먼트(Segment)라는 데이터 단위를 사용하며 UDP는 데이터그램(Datagram)이라는 데이터 단위를 사용합니다.TCP는 세그먼트를 작은 패킷으로 나눠 여러 경로를 통해 데이터를 전송하고 목적지에서 순서대로 패킷을 조립하여 데이터를 전달합니다. 반면 데이터그램은 순서에 상관없이 데이터를 전달하기때문에 신뢰성은 없습니다.세션 계층 (Session Layer)세션 계층은 두 컴퓨터 사이에 연결을 형성하고 유지 및 종료하는 기능을 담당하는 계층입니다. 일종의 대화통로라고 보면 됩니다. 데이터의 송수신 타이밍과 방법은 이 계층에서 규정됩니다.세션 계층의 프로토콜에는 SSH, TLS, RPC 등이 있으며, 데이터 전송 보안과 관련있습니다.표현 계층 (Presentation Layer)표현 계층은 전송되는 정보의 구문(Syntax) 및 의미(Semantics)에 관여하는 계층으로, 인코딩(Encoding), 데이터 압축(Compression), 암호화(Cryptography) 등 주요한 동작을 수행합니다. 파일의 확장자(txt, jpeg, mp4, html 등)는 이 계층과 관련된 프로토콜입니다.응용 계층 (Application Layer)응용 계층은 응용 서비스를 수행하고 사용자 인터페이스를 제공하는 계층입니다. 대표적인 프로토콜로는 html 문서 전송 프로토콜인 HTTP(HyperText Transfer Protocol), 파일 전송 프로토콜인 FTP(File Transfer Protocol), 메일 전송 프로토콜인 SMTP(Simple Mail Transfer Protocol) 등이 있습니다.TCP/IP인터넷에서 데이터를 주고 받을때 대부분 전송 계층에 속하는 TCP(Transmission Control Protocol)​와 네트워크 계층에 속하는 IP(Internet Protocol)를 많이 사용하는데 이를 묶어 TCP/IP(Transmission Control Protocol/Internet Protocol)라고 합니다. 1960년대 미 국방성에서 개발한 통신 프로토콜이며, 현재는 대부분의 컴퓨터가 기본으로 제공하는 인터넷 표준 프로토콜입니다. TCP/IP는 데이터 전송 과정을 4계층으로 나누며, OSI 모델과 다르게 각 계층이 서로 종속적입니다.네트워크 인터페이스(Network Interface) 계층네트워크 인터페이스 계층은 운영체제의 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련된 모든 것을 지원하는 계층입니다. 상위 계층(IP)에서 패킷이 도착하면 헤더에 프리앰블(Preamble)과 CRC(Cyclic Redundancy Check)를 추가합니다. 송신 측 단말기는 인터넷 계층으로부터 전달받은 패킷에 물리적 주소(MAC) 정보를 가지는 헤더를 추가하여 프레임을 만들어 전달합니다.관련 프로토콜에는 이더넷(Ethernet), 802.11x, MAC/LLC, PPP 등이 있습니다.인터넷(Internet) 계층인터넷 계층은 패킷의 인터넷 주소를 결정하고 경로를 배정하는 역할을 합니다. 관련된 프로토콜에는 IP(Internet Protocol), IP를 MAC으로 변환하는 ARP(Address Resolution Protocol), IP 패킷을 전달하는 동안 발생한 오류를 보고하는 ICMP(Internet Control Message Protocol) 등이 있습니다.인터넷은 INTERconnected NETwork에서 만들어진 합성어로, TCP/IP를 통해 연결된 모든 네트워크의 집합체입니다.IP 주소에는 32비트 체계인 IPv4와 128비트 체계인 IPv6가 있습니다.IPv4는 최대 65,532byte로 이루어져 있으며, 5개의 클래스로 나눠집니다. 유니캐스트, 브로드캐스트, 멀티캐스트를 지원합니다.IPv6는 IPv4의 주소 부족 문제를 해결하기 위해 만들어졌으며, 유니캐스트, 멀티캐스트, 애니캐스트를 지원합니다.전송(Transport) 계층전송 계층은 네트워크 양단의 호스트 사이의 신뢰성 있는 전송 기능을 제공합니다. 시스템의 논리 주소와 포트를 가지며, TCP와 UDP가 사용됩니다.TCP의 경우 3 Way-Handshake라는 방식으로 통신합니다. 장치간에 연결이 잘 되었는를 3번의 과정을 통해 확인하여 데이터 전송의 신뢰성을 확보합니다.SYN은synchronize sequence numbers의 약자이고 ACK는 acknowledgements의 약자입니다. 상태에 대한 설명은 아래 테이블을 참조하세요.            상태      설명                  CLOSED      닫힌 상태              LISTEN      요청 대기 상태              SYN-SENT      SYN 요청 상태              SYN-RECEIVED      SYN 요청을 받은 상태              ESTABLISHED      연결 확인 상태      (1) 클라이언트가 서버에게 SYN을 요청하고 SYN-SENT 상태가 됩니다.(2) SYN을 요청받은 서버는 SYN-RECEIVED 상태가 되고, SYN과 함께 ACK를 클라이언트에게 읍답합니다.(3) SYN+ACK를 응답받은 클라이언트는 ACK를 서버에 요청하고 클라이언트와 서버는 ESTABLISHED 상태가 됩니다.쉽게 말해서 클라이언트가 “내말 들려?” 라고 요청을 보내면 서버가 “응 들려, 넌 내말 들려?” 라고 응답하고,  클라이언트가 “응, 나도 들려” 라고 대답하면서 대화가 시작되는겁니다.응용(Application) 계층OSI 참조 모델의 세션, 표현, 응용 계층을 합친 계층입니다.",
        "url": "/etc/iso-standard-7498"
    }
    ,
    
    "etc-docker": {
        "title": "도커(Docker) 설치하기",
            "author": "rubisco",
            "category": "",
            "content": "도커란?도커는 컨테이너 기반 오픈소스 가상화 플랫폼입니다. 컨테이너란 격리된 공간에서 프로세스가 실행되도록 하는 기술입니다.버추얼머신(VM)이라고 들어보셨을겁니다. 버추얼머신은 격리된 공간에서 OS가 실행되도록 하는 기술입니다. 윈도우에 격리된 리눅스를 설치한 것이라 보면 됩니다. 쉽게말해서 컴퓨터 안에 가상의 컴퓨터가 있는겁니다.버추얼머신은 이미 설치되어 있는 OS위에 새로운 OS를 실행시키기때문에 조금 무겁습니다. 그에 비하여 도커는 기존 OS 위에 격리된 프로세스 공간을 만들어 실행시키때문에 가볍고 빠르게 동작합니다.도커를 사용하는 이유는 프로그램마다 운영환경이 다르기때문입니다. 예를 들어 A라는 프로그램은 파이썬3.8을 기반으로 작동하는데 OS에는 파이썬 3.5가 설치되어있다면 파이썬3.8을 추가적으로 설치해야합니다. ‘그럼 그냥 파이썬 3.8을 설치하면 되지’라고 생각하는 분도 있을겁니다.  하지만 프로그램은 무수히 많고 프로그램을 설치할때마다 환경을 따로 설정하는 것은 여간 번거로운 일이 아닙니다.도커를 사용한다면 격리된 가상의 공간에 배포자가 작성한 운영환경에 필요한 라이브러리를 설치하여 프로세스를 실행시키게 됩니다. 즉 따로 프로그램에 맞춰 환경설정을 할 필요가 없다는 뜻입니다.도커 설치오라클 클라우드를 통해 우분투 20.04 환경에서 도커를 설치해보겠습니다.(1) 우선 SSH를 통해 오라클 클라우드에 원격접속해주세요.$ ssh [USER]@[HOSTNAME] -p [PORT](2) 패키지를 최신상태로 업데이트 해주세요.$ sudo apt update &amp;&amp; sudo apt upgrade(3) 필수 패키지를 설치하세요.$ sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release(4) 도커와 암호화 통신을 위한 GPG 키를 추가해주세요.$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg(5) apt로 설치하기위해 stable repository를 등록합니다.echo \\  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null(6) apt로 도커 엔진을 설치합니다.$ sudo apt update$ sudo apt install docker-ce docker-ce-cli containerd.io(7) 버전을 확인해봅시다.$ sudo docker version(8) 권한을 지정하여 sudo 없이 도커를 사용할 수 있도록 합시다.$ sudo usermod -aG docker $USER포테이너(Portainer) 설치포테이너는 도커를 웹에서 GUI로 관리할 수 있는 도구입니다. 포테이너를 도커에 설치하겠습니다.(1) 포테이너 데이터를 저장할 볼륨(공간)을 만듭니다.$ docker volume create portainer_data(2) 도커로 포테이너 컨테이너를 생성합니다.$ docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce-d : 백그라운드 모드(detached mode) 실행-p 9000:9000 : 호스트 포트를 컨테이너 포트에 연결 (호스트:컨테이너)--name portainer : 컨테이너 이름 설정--restart aloways : 도커 실행시 컨테이너 실행 여부 설정-v portainer_data:/data : 호스트 볼륨을 컨테이너 볼륨에 연결portainer/portainer-ce : 컨테이너 이미지 이름포테이너가 9000번 포트에서 실행됩니다. 그러나 오라클 클라우드의 경우 22번 포트만 열려 있으므로 방화벽을 Open해야합니다. 아래 방화벽 오픈(Open)를 참조하세요.(3) 아이디와 암호를 입력하고 Create user를 클릭하여 계정을 생성합니다.(4) Get Started를 클릭합니다.(5) 설정이 완료되었습니다! 아래 사진과 같이 도커의 상태를 확인할 수 있습니다.방화벽 오픈(Open)(1) 오라클 클라우드에 로그인 후 홈 -&gt; 인스턴스를 선택합니다.(2) 생성된 인스턴스를 클릭합니다.(3) 보안 목록을 클릭합니다.22번 포트만 열려있는 것을 확인할 수 있습니다.(4) 수신 규칙 추가를 클릭합니다.(5) 소스 CIDR에 0.0.0.0/0, 대상 포트 범위에 9000을 입력하고 수신 규칙 추가를 클릭합니다.(6) OS 방화벽을 오픈합니다.iptables은 재부팅할때마다 설정 내용이 초기화되므로 iptables을 날리고 ufw를 사용하겠습니다.우선 iptables 룰 정책을 저장하기 위한 패키지를 설치합니다.$ sudo apt install iptables-persistent netfilter-persistent net-tools(7) 정책을 영구 저장합니다.$ sudo netfilter-persistent save(8) ufw에서 9000번 포트를 허용해줍니다. SSH 접속을 유지하기위해 22번 포트도 추가해줍니다.$ sudo ufw allow 9000$ sudo ufw allow 22(9) ufw를 켭니다.$ sudo ufw enable",
        "url": "/etc/docker"
    }
    ,
    
    "design-pattern-creational-singleton-pattern": {
        "title": "싱글톤 패턴(Singleton Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        싱글톤 패턴(Singleton Pattern)싱글톤 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 접근할 수 있는 방법을 제공합니다. 즉, 특정 클래스의 객체는 하나만 생성되도록 하여 동일 인스턴스를 재사용 하는 패턴입니다.구조참여 객체Singleton생성자의 접근자를 private로 설정하여 새로운 인스턴스를 생성하지 못하도록 하고, 인스턴스(Instance)의 접근을 위한 오퍼레이션(Operation)을 static으로 정의하여 해당 메소드에 의해서만 인스턴스의 접근이 가능하도록 합니다.인스턴스는 싱글턴 객체의 클래스 변수로 설정되어 클래스가 메모리의 데이터영역에 저장될 때 같이 저장됨으로써 오직 한번만 인스턴스를 생성할 수 있습니다. 이로써 싱글턴 객체는 유일한 인스턴스의 생성에 대한 책임을 지게 됩니다.종류이른 초기화 방식 (Eager Initialization)이른 초기화 방식은 싱글톤 패턴의 가장 기본적인 유형입니다.전역변수로 인스턴스를 생성하고 접근자를 private로 설정함으로써 싱글톤 객체의 오퍼레이션 메소드에 의해서만 접근이 가능하도록 합니다. 또한 생성자의 접근자를 private로 절정함으로써 외부에서 인스턴스를 생성할 수 없도록 만듭니다.EagerSingleton.javapackage design_pattern.creational.singleton;public class EagerSingleton {        private static final EagerSingleton INSTANCE = new EagerSingleton();    private EagerSingleton() {}    public static EagerSingleton getInstance() {        return INSTANCE;    }}자바에서는 static으로 선언한 클래스 변수가 곧 전역변수입니다. 클래스가 메모리의 데이터 영역에 저장될 때 클래스 변수인 INSTANCE는 싱글톤 인스턴스를 한번만 생성하여 참조함으로써 동일한 인스턴스를 재사용하는 싱글톤 원칙을 지킬 수 있게 됩니다.이른 초기화 방식의 장점은 전역변수로 싱글톤 인스턴스를 만들었기때문에 클래스 로더에 의하여 클래스가 로딩될 때 오직 한번만 인스턴스가 생성되므로 Thread-safe하게 싱글톤 객체를 생성할 수 있습니다.단점은 객체의 사용여부와 상관없이 클래스 로딩 시점에 인스턴스가 생성되어 프로그램이 종료될때까지 메모리를 점유하기때문에 자주 사용하지 않는 객체라면 비효율적일 수 있습니다.늦은 초기화 방식 (Lazy Initialization)늦은 초기화 방식은 이른 초기화 방식과 반대로 클래스의 오퍼레이션 메소드가 호출될 때 인스턴스를 생성합니다. 즉, 클래스 메소드가 호출될 때까지 메모리를 점유하지 않습니다.LazySingleton.javapackage design_pattern.creational.singleton;public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {}    public static LazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new LazySingleton();        }        return INSTANCE;    }}늦은 초기화 방식의 장점은 필요할때 객체를 생성할 수 있다는 것입니다.단점은 멀티 쓰레드(Thread) 환경에서 동시에 호출되어 싱글톤 원칙을 보장할 수 없다는 것입니다.쓰레드 안전 이른 초기화 방식 (Thread safe Lazy Initialization)늦은 초기화 방식을 보완하여 synchronized 키워드를 메소드에 선언하여 쓰레드 안전(Thread safe) 상태로 싱글톤을 생성할 수 있는 방식입니다. synchronized로 선언된 메소드는 하나의 쓰레드가 메소드를 사용하면 lock을 걸어 다른 쓰레드를 대기상태로 만듭니다.ThreadSafeLazySingleton.javapackage design_pattern.creational.singleton;public class ThreadSafeLazySingleton {    private static ThreadSafeLazySingleton INSTANCE = null;    private ThreadSafeLazySingleton() {}    public static synchronized ThreadSafeLazySingleton getInstance() {        if(INSTANCE == null){            INSTANCE = new ThreadSafeLazySingleton();        }        return INSTANCE;    }}이 방식의 장점은 Thread-safe 환경이라는 것입니다.단점은 syncronized가 선언된 메소드가 호출이 많으면 성능이 나빠질 수 있습니다.DCL 방식 (Double-Checked locking)DCL 방식은 syncronized를 메소드에 선언하는 것이 아니라 메소드 내부에 syncronized 블락을 만드는 방식입니다.DCLSingleton.javapackage design_pattern.creational.singleton;public class DCLSingleton {    private volatile static DCLSingleton INSTANCE = null;    private DCLSingleton() {}    public static DCLSingleton getInstance() {        if(INSTANCE == null){            synchronized(DCLSingleton.class){                if(INSTANCE == null){                    INSTANCE = new DCLSingleton();                }            }        }        return INSTANCE;    }}위에 코드와 같이 인스턴스가 없을때 synchronized 키워드를 통해 블락을 만들어 하나의 쓰레드만 작업할 수 있도록 하고 블락 내부에서 다시한번 인스턴스 존재 여부를 체크하게 됩니다. 2번 체크하기때문에 DCL(Double Checking Locking) 방식이라 불립니다.private 접근자로 설정한 INSTANCE 클래스를 보면 volatile이라는 키워드를 사용했습니다. 하나의 프로세서(CPU)는 최적화를 위해 변수를 메인 메모리에 바로 저장하지 않고 캐쉬메모리에 저장하여 성능을 향상시킵니다. 그러나 volatile로 선언된 변수는 변수를 캐쉬메모리에 저장하지 않고 곧바로 메인메모리에 반영하도록 합니다.volatile 키워드를 사용하지 않고 멀티코어 환경에서 작업한다면 인스턴스를 캐쉬메모리에 저장하여 메인메모리에 인스턴스를 생성하기전에 다른 코어의 쓰레드가 비어있는 메모리를 참조하기때문에 문제가 발생할 수 있습니다.Holder에 의한 초기화 방식 (Initialization on demand holder idiom)이 방식은 클래스안에 클래스 홀더(Holder)를 두어 JVM 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방식입니다. 현재까지 가장 많이 이용되고 있는 방식입니다.StaticHolderSingleton.javapackage design_pattern.creational.singleton;public class StaticHolderSingleton {    private StaticHolderSingleton(){}\t\tprivate static class SingleTonHolder {\t\tprivate static final StaticHolderSingleton INSTANCE = new StaticHolderSingleton();\t}\t\tpublic static StaticHolderSingleton getInstance(){\t\treturn SingleTonHolder.INSTANCE;\t}}위에 코드에서 보는 바와 같이 클래스 안에 private 접근자로 중첩클래스를 선언하고 중첩클래스 내부에 private 접근자로 클래스 변수를 선언했습니다. 중첩 클래스는 오퍼레이션 메소드(Operation Method)에 의하여 호출되기 전까지 참조되지 않으며, 오퍼레이션 메소드에 의하여 호출될때 클래스 로더에 의하여 싱글톤 인스턴스를 생성하게 됩니다.중첩클래스 내부에 선언된 클래스 변수는 static으로 선언되었기 때문에 중첩클래스가 로드되는 시점에 한번만 싱글톤 인스턴스를 생성할 수 있게 됩니다. 또한 final 키워드를 통해 다시 값이 할당되지 않도록 하여 싱글톤 원칙을 지킬 수 있게 됩니다.",
        "url": "/design-pattern/creational/singleton-pattern"
    }
    ,
    
    "design-pattern-intro": {
        "title": "디자인 패턴(Design Pattern)",
            "author": "rubisco",
            "category": "",
            "content": "GOF 디자인 패턴                생성 패턴                                                                    싱글톤 패턴(Singleton Pattern)                                                                                        팩토리 메서드 패턴(Factory Method Pattern)                                                                                        추상 팩토리 패턴(Abstract Factory Pattern)                                                                                        빌더 패턴(Builder Pattern)                                                                                        프로토타입 패턴(Prototype Pattern)                                                                    구조 패턴                                                                    어댑터 패턴(Adapter Pattern)                                                                                        브리지 패턴(Bridge Pattern)                                                                                        컴포지트 패턴(Composit Pattern)                                                                                        데코레이터 패턴(Decorator Pattern)                                                                                        퍼사드 패턴(Facade Pattern)                                                                                        플라이웨이트 패턴(Flyweight Pattern)                                                                                        프록시 패턴(Proxy Pattern)                                                                    행위 패턴                                                                    책임 연쇄 패턴(Chain of Responsibility Pattern)                                                                                        커맨드 패턴(Command Pattern)                                                                                        이터레이터 패턴(Iterator Pattern)                                                                                        메디에이터 패턴(Mediator Pattern)                                                                                        메멘토 패턴(Memento Pattern)                                                                                        옵저버 패턴(Observer Pattern)                                                                                        상태 패턴(State Pattern)                                                                                        전략 패턴(Strategy Pattern)                                                                                        템플릿 메소드 패턴(Template Method Pattern)                                                                                        비지터 패턴(Visitor Pattern)                                                        디자인 패턴디자인 패턴(Design Pattern)은 객체지향 프로그래밍을 할때 자주 접할 수 있는 문제를 해결하고자 만든 일종의 코드 패턴에 대한 템플릿(template)입니다.1990년대 초반 에리히 감마(Erich Gamma)에 의해 첫 소개된 이후 1995년에 이분야의 GoF(Gang of Four)라 불리는 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)에 의해 집대성 되었고, 이것이 GoF의 디자인 패턴(Design Pattern)으로 널리 알려졌습니다.디자인 패턴은 객체지향 모델링의 장점인 재사용성과 모듈성을 극대화 시켜서 이를 적용하면 시스템 개발은 물론 유지보수에도 큰 효과를 얻을 수 있습니다. 반면 객체지향 모델에 사용되므로 초기 개발시간이 길어져 소규모 프로젝트에는 적합하지 않을 수도 있습니다.디자인 패턴의 종류디자인 패턴은 크게 생성 패턴(Creational Pattern)과 구조 패턴(Structural Patterns), 행위 패턴(Behavioral Patterns)으로 나눠집니다.생성 패턴(Creational Pattern)은 객체(Object)의 인스턴스(Instance) 생성을 위한 패턴입니다. 클라이언트와 객체 인스턴스 사이의 연결을 끊어줍니다.생성 패턴에는 싱글톤 패턴(Singleton Pattern), 빌더 패턴(Builder Pattern), 팩토리 메서드 패턴(Factory Method Pattern), 추상 팩토리 패턴(Abstract Factory Pattern), 프로토타입 패턴(Prototype Pattern)이 있습니다.구조 패턴(Structural Patterns은 객체(Object)의 합성에 관한 패턴입니다. 객체의 조직화에 대한 패턴을 제공합니다.구조 패턴에는 어댑터 패턴(Adapter Pattern), 브리지 패턴(Bridge Pattern), 컴포지트 패턴(Composit Pattern), 데코레이터 패턴(Decorator Pattern), 퍼사드 패턴(Facade Pattern), 플라이웨이트 패턴(Flyweight Pattern), 프록시 패턴(Proxy Pattern)이 있습니다.행위 패턴(Behavioral Patterns)은 객체(Object)의 상호작용과 책임 분산에 대한 패턴을 제공합니다.행위 패턴에는 책임 연쇄 패턴(Chain of Responsibility Pattern), 커맨드 패턴(Command Pattern), 인터프리터 패턴(Interpreter Pattern), 이터레이터 패턴(Iterator Pattern), 메디에이터 패턴(Mediator Pattern), 메멘토 패턴(Memento Pattern), 옵저버 패턴(Observer Pattern), 상태 패턴(State Pattern), 전략 패턴(Strategy Pattern), 템플릿 메소드 패턴(Template Method Pattern), 비지터 패턴(Visitor Pattern)이 있습니다.",
        "url": "/design-pattern/intro"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://huimang2.github.io/">Rubisco's Programming Note</a> &copy; 2023</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search Rubisco's Programming Note</h1>
            <p class="subscribe-overlay-description">
            lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>


    <!-- highlight.js -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script> -->

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
